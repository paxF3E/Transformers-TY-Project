,Pseudocode,Description,Label
0,"minSum assign to integer with minSum assign to A, N assign to map, integer assign to mp assign to integer assign to mp
create integer sum with sum assign to 0
untill i assign to 0 to N exclusive, add A array of i   to sum
increment mp array of A array of i  
minSum assign to integer with minSum assign to INT_MAX
untill auto it : mp, minSum assign to min ( minSum, sum - ( it. first * it. second ) )
return minSum
declare integer main ( ), integer arr array of   assign to  4, 5, 6, 6  ;
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print minSum ( arr, N ) and "" STRNEWLINE ""
","Minimum sum possible by removing all occurrences of any array element 
 C ++ program untill the above approach ; Function to find minimum sum after deletion ; Stores frequency of array elements ; Traverse the array ; Calculate sum ; Update frequency of the current element ; Stores the minimum sum required ; Traverse map ; Find the minimum sum obtained ; Return minimum sum ; Driver code ; Input array ; Size of array
",1
1,"minSum assign to integer with minSum assign to A, N assign to map, integer assign to mp assign to integer assign to mp
create integer sum with sum assign to 0
untill i assign to 0 to N exclusive, add A array of i   to sum
increment mp array of A array of i  
minSum assign to integer with minSum assign to INT_MAX
untill auto it : mp, minSum assign to min ( minSum, sum - ( it. first * it. second ) )
return minSum
declare integer main ( ), integer arr array of   assign to  4, 5, 6, 6  ;
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print minSum ( arr, N ) and "" STRNEWLINE ""
","Minimum operations to make frequency of all characters equal K 
 C ++ program to convert the given string ; Function to find the minimum number of operations to convert the given string ; Check if N is divisible by K ; Array to store frequency of characters in given string ; Two arrays with number of operations required ; Checking untill all possibility ; Driver Code
",0
2,"declare maxAdjacent with integers arr, N as arguments, returning void, returning vector, returning integer, with res assign to res
untill i assign to 1 to N - 1 exclusive, prev assign to arr array of 0  
create integer maxi with maxi assign to INT_MIN
untill j assign to 1 to N exclusive, if i is j, continue
set maxi to max ( maxi, abs ( arr array ofj   - prev ) ) )
set prev to arr array ofj  
push_back is a new line in res
print x and "" "" to the standard output
print newline
declare integer main ( ), integer arr array of   assign to  1, 3, 4, 7, 8  ;
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
let maxAdjacent be a maxAdjacent ( arr, N )
","Maximum difference between a pair of adjacent elements by excluding every element once 
 C ++ program untill the above approach ; Function to calculate maximum difference between adjacent elements excluding every array element once ; Traverse the array ; Stores the maximum diff ; Check untill maximum adjacent element ; Exclude current element ; Update maximum difference ; Update previous value ; Append the result into a vector ; Print the result ; Driver Code
",1
3,"declare maxAdjacent with integers arr, N as arguments, returning void, returning vector, returning integer, with res assign to res
untill i assign to 1 to N - 1 exclusive, prev assign to arr array of 0  
create integer maxi with maxi assign to INT_MIN
untill j assign to 1 to N exclusive, if i is j, continue
set maxi to max ( maxi, abs ( arr array ofj   - prev ) ) )
set prev to arr array ofj  
push_back is a new line in res
print x and "" "" to the standard output
print newline
declare integer main ( ), integer arr array of   assign to  1, 3, 4, 7, 8  ;
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
let maxAdjacent be a maxAdjacent ( arr, N )
","Number of Paths of Weight W in a K 
 C ++ program to count the number of paths with weight W in a K - ary tree ; Function to return the number of ways having weight as wt in K - ary tree ; Return 0 if weight becomes less than zero ; Return one only if the current path has included edge weight of atleast M ; If the current edge weight is greater than or equal to M , set used as true ; Driver Code to test above function
",0
4,"declare findSize with integer N if N is 0, return 1
if N is 1 return 1
Size assign to 2 * findSize ( N / 2 ) + 1
return Size
return 0 if L is greater than R
if N assign to 1 return N
ret assign to integer with ret assign to 0
create integer M with M assign to N / 2
Siz_M assign to integer with Siz_M assign to findSize ( M)
if L assign to Siz_M, increment ret by CountOnes ( N / 2, L, min ( Siz_M, R ) )
if L assign to Siz_M + 1 and Siz_M + 1 assign to R, increment ret by N % 2
if Siz_M + 1 is less than R, increment ret by CountOnes ( N / 2, max ( 1, L - Siz_M - 1 ), R - Siz_M - 1 )
return ret
declare integer main ( ), integers N assign to 7, L assign to 2 and R assign to 5
print CountOnes ( N, L, R )
return 0
","Count 1 s present in a range of indices array of L , R   in a given array 
 C ++ Program to implement the above approach ; Function to find the size of the array if the array initially contains a single element ; Base case ; P / 2 -> findSize ( N / 2 ) P % 2 -> 1 P / 2 -> findSize ( N / 2 ) ; Function to return the count of 1 s in the range array of L , R   ; Base Case ; PART 1 -> N / 2 array of 1 , Siz_M   ; Update the right end point of the range to min ( Siz_M , R ) ; PART 2 -> N % 2 array of SizM + 1 , Siz_M + 1   ; PART 3 -> N / 2 array of SizM + 2 , 2 * Siz_M - 1   Same as PART 1 Property of Symmetricity Shift the coordinates according to PART 1 Subtract ( Siz_M + 1 ) from both L , R ; Driver Code ; Input ; Counts the number of 1 's in  the range array ofL, R 
",1
5,"declare findSize with integer N if N is 0, return 1
if N is 1 return 1
Size assign to 2 * findSize ( N / 2 ) + 1
return Size
return 0 if L is greater than R
if N assign to 1 return N
ret assign to integer with ret assign to 0
create integer M with M assign to N / 2
Siz_M assign to integer with Siz_M assign to findSize ( M)
if L assign to Siz_M, increment ret by CountOnes ( N / 2, L, min ( Siz_M, R ) )
if L assign to Siz_M + 1 and Siz_M + 1 assign to R, increment ret by N % 2
if Siz_M + 1 is less than R, increment ret by CountOnes ( N / 2, max ( 1, L - Siz_M - 1 ), R - Siz_M - 1 )
return ret
declare integer main ( ), integers N assign to 7, L assign to 2 and R assign to 5
print CountOnes ( N, L, R )
return 0
","Count subarrays having sum modulo K same as the length of the subarray 
 C ++ program of the above approach ; Function that counts the subarrays s . t . sum of elements in the subarray modulo k is equal to size of subarray ; Stores the count of ( pref array of i   - i ) % k ; Stores the count of subarray ; Stores prefix sum of the array ; Find prefix sum array ; Base Condition ; Remove the index at present after K indices from the current index ; Update the answer untill subarrays ending at the i - th index ; Add the calculated value of current index to count ; Print the count of subarrays ; Driver Code ; Given arr array of   ; Size of the array ; Given K ; Function Call
",0
6,"return false if n is 1
untill i assign to 2 to i * i assign to n, return false if n modulo i is 0
return true
if prime ( n ) ), print 1 print "" "" print n - 1
else print if n modulo i is 0, print n / i print "" "" print n / i * ( i - 1)
break loop
declare integer variable N assign to 4
minDivisior ( N )
return 0
","Find the pair ( a , b ) with minimum LCM such that their sum is equal to N 
 C ++ program untill the above approach ; Function to check if number is prime or not ; As 1 is neither prime nor composite return false ; Check if it is divided by any number then it is not prime , return false ; Check if n is not divided by any number then it is prime and hence return true ; Function to find the pair ( a , b ) such that sum is N & LCM is minimum ; Check if the number is prime ; Now , if it is not prime then find the least divisior ; Check if divides n then it is a factor ; Required output is a assign to n / i & b assign to n / i * ( n - 1 ) ; Driver Code ; Function call
",1
7,"return false if n is 1
untill i assign to 2 to i * i assign to n, return false if n modulo i is 0
return true
if prime ( n ) ), print 1 print "" "" print n - 1
else print if n modulo i is 0, print n / i print "" "" print n / i * ( i - 1)
break loop
declare integer variable N assign to 4
minDivisior ( N )
return 0
","Count of subarrays having sum equal to its length 
 Set 2 
 C ++ program untill the above approach ; Function that counts the subarrays with sum of its elements as its length ; Store count of elements upto current element with length i ; Stores the final count of subarray ; Stores the prefix sum ; If size of subarray is 1 ; Iterate the array ; Find the sum ; Update frequency in map ; Print the total count ; Driver Code ; Given array arr array of   ; Size of array ; Function Call
",0
8,"Landau assign to integer with Landau assign to INT_MIN
gcd assign to integer if a is equal to 0, return b
return gcd ( b modulo a, a )
lcm assign to integer, return ( a * b ) / gcd assign to a, b )
create void findLCM ( vector  int > & arr ), nth_lcm assign to arr array of 0  
untill i assign to 1 to size of arr exclusive, set nth_lcm to lcm ( nth_lcm, arr array of i   )
Landau assign to max ( Landau, nth_lcm )
void function findWays ( vector  int > & arr, int i, int n) if n is 0, findLCM (arr)
untill j assign to i to n inclusive, push_back j is a new line
findWays assign to arr,j,n-j
pop_back is a new array of arr
declare Landau_function with integer n as argument, assign a vector to integers > arr
findWays assign to arr, 1, n
print Landau
declare integer main ( ) and integer N assign to 4
declare Landau_function with N elements
return 0
","Find Landau 's function untill a given number N 
 C ++ program untill the above approach ; To store Landau 's function of the number ; Function to return gcd of 2 numbers ; Function to return LCM of two numbers ; Function to find max lcm value among all representations of n ; Calculate Landau 's value ; Recursive function to find different ways in which n can be written as sum of atleast one positive integers ; Check if sum becomes n , consider this representation ; Start from previous element in the representation till n ; Include current element from representation ; Call function again with reduced sum ; Backtrack - remove current element from representation ; Function to find the Landau 's function ; Using recurrence find different ways in which n can be written as a sum of atleast one + ve integers ; Print the result ; Driver Code ; Given N ; Function Call
",1
9,"Landau assign to integer with Landau assign to INT_MIN
gcd assign to integer if a is equal to 0, return b
return gcd ( b modulo a, a )
lcm assign to integer, return ( a * b ) / gcd assign to a, b )
create void findLCM ( vector  int > & arr ), nth_lcm assign to arr array of 0  
untill i assign to 1 to size of arr exclusive, set nth_lcm to lcm ( nth_lcm, arr array of i   )
Landau assign to max ( Landau, nth_lcm )
void function findWays ( vector  int > & arr, int i, int n) if n is 0, findLCM (arr)
untill j assign to i to n inclusive, push_back j is a new line
findWays assign to arr,j,n-j
pop_back is a new array of arr
declare Landau_function with integer n as argument, assign a vector to integers > arr
findWays assign to arr, 1, n
print Landau
declare integer main ( ) and integer N assign to 4
declare Landau_function with N elements
return 0
","Distance between two parallel Planes in 3 
 C ++ program to find the Distance between two parallel Planes in 3 D . ; Function to find distance ; Driver Code
",0
10,"if n is 1 return true
if n assign to 3 return true
if n modulo 2 is 0 n modulo 3 is 0, return false
return false if n modulo i is 0 or n modulo ( i + 2 ) is 0
return true
print Yes
else print No
declare integer main ( ) and integer N assign to 3
checkExpression ( N )
return 0
","Check if the remainder of N 
 C ++ implementation to check the following expression untill an integer N is valid or not ; Function to check if a number holds the condition ( N - 1 ) ! % N assign to N - 1 ; Corner cases ; Number divisible by 2 or 3 are not prime ; Iterate from 5 and keep checking untill prime ; Function to check the expression untill the value N ; Driver Program
",1
11,"if n is 1 return true
if n assign to 3 return true
if n modulo 2 is 0 n modulo 3 is 0, return false
return false if n modulo i is 0 or n modulo ( i + 2 ) is 0
return true
print Yes
else print No
declare integer main ( ) and integer N assign to 3
checkExpression ( N )
return 0
","Count occurrences of a character in a repeated string 
 CPP program to find the occurrences of character x in the infinite repeated string upto length n ; Function to count the character ' a ' ; atleast k repetition are required ; if n is not the multiple of the string size check untill the remaining repeating character . ; Driver code
",0
12,"declare checkArray with integers n, k, arr, with arr assign to 0 and cnt assign to 0
untill i assign to 0 to n exclusive, increment cnt by 1
if cnt >assign to k and cnt % 2 assign to k % 2, return true
else return false
declare integer main ( ) and integer arr array of   assign to  1, 3, 4, 7, 5, 3, 1  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create integer k with k assign to 4
if checkArray ( n, k, arr ) ) print Yes
else print No
return 0
","Check if it is possible to split given Array into K odd 
 C ++ implementation to check if it is possible to split array into K subsets with odd sum ; Function to check if array can be split in required K subsets ; Store count of odd numbers ; Check if element is odd ; Check if split is possible ; Driver Program
",1
13,"declare checkArray with integers n, k, arr, with arr assign to 0 and cnt assign to 0
untill i assign to 0 to n exclusive, increment cnt by 1
if cnt >assign to k and cnt % 2 assign to k % 2, return true
else return false
declare integer main ( ) and integer arr array of   assign to  1, 3, 4, 7, 5, 3, 1  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create integer k with k assign to 4
if checkArray ( n, k, arr ) ) print Yes
else print No
return 0
","String containing first letter of every word in a given string with spaces 
 C ++ program to find the string which contain the first character of each word of another string . ; Function to find string which has first character of each word . ; Traverse the string . ; If it is space , set v as true . ; Else check if v is true or not . If true , copy character in output string and set v as false . ; Driver cpde
",0
14,"declare integer func ( integer arr array of  , integer n )  double ans assign to 0
create integer maxx with maxx assign to 0
create double freq array of 100005  assign to  0  ;
create integer temp
untill i assign to 0 to n exclusive, temp assign to arr array of i  
increment freq array of temp 
set maxx to max ( maxx, temp )
untill i assign to 1 to maxx inclusive, increment freq array of i   by freq array of i - 1  
untill i assign to 1 to maxx inclusive, if freq array of i   )  i assign to double i
create double j
set value to 0
cur assign to double with cur assign to ceil ( 0.5 * i ) - 1.0
untill j assign to 1.5 to j, val assign to min ( maxx, ( int ) ( ceil ( i * j ) - 1.0 ) )
create integers times, con with times assign to ( freq array of i   - freq array of i - 1   ) and con assign to j - 0.5
increment ans by times * con * ( freq array of ( int ) val   - freq array of ( int ) cur   )
set cur to val
if val is maxx, break loop
return ( ll ) ans
declare integer main ( ), integer arr array of   assign to  1, 2, 3  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print func ( arr, n ) and a new line
return 0
","Sum of division of the possible pairs untill the given Array 
 C ++ implementation to compute the sum of division of all the possible pairs untill the given array ; Function to compute the sum ; counting frequency of each term and finding maximum among it ; Making cumulative frequency ; Taking the ceil value ; nos . in array of ( n - 0.5 ) X , ( n + 0.5 ) X ) range will add n to the ans ; Return the final result ; Driver code
",1
15,"declare integer func ( integer arr array of  , integer n )  double ans assign to 0
create integer maxx with maxx assign to 0
create double freq array of 100005  assign to  0  ;
create integer temp
untill i assign to 0 to n exclusive, temp assign to arr array of i  
increment freq array of temp 
set maxx to max ( maxx, temp )
untill i assign to 1 to maxx inclusive, increment freq array of i   by freq array of i - 1  
untill i assign to 1 to maxx inclusive, if freq array of i   )  i assign to double i
create double j
set value to 0
cur assign to double with cur assign to ceil ( 0.5 * i ) - 1.0
untill j assign to 1.5 to j, val assign to min ( maxx, ( int ) ( ceil ( i * j ) - 1.0 ) )
create integers times, con with times assign to ( freq array of i   - freq array of i - 1   ) and con assign to j - 0.5
increment ans by times * con * ( freq array of ( int ) val   - freq array of ( int ) cur   )
set cur to val
if val is maxx, break loop
return ( ll ) ans
declare integer main ( ), integer arr array of   assign to  1, 2, 3  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print func ( arr, n ) and a new line
return 0
","Cutting a Rod 
 DP 
 A Naive recursive solution untill Rod cutting problem ; A utility function to get the maximum of two integers ; Returns the best obtainable price untill a rod of length n and price array of   as prices of different pieces ; Recursively cut the rod in different pieces and compare different configurations ; Driver program to test above functions
",0
16,"declare insert_element with integers a array of   and n, set Xor to 0
Sum assign to integer with Sum assign to 0
untill i assign to 0 to n exclusive, Xor assign to a array of i  
add a array of i   to Sum
if Sum is 2 * Xor print ""0"" print newline
return
if Xor is 0, print ""1"" print newline
print Sum
return
num1 assign to integer with num1 assign to Sum + Xor
create integer num2 with num2 assign to Xor
print ""2""
print num1, "" "", num2 and a new line
declare integer main ( ), integer a assign to  1, 2, 3  ; declare integer array a size   assign to  1, 2, 3
create integer n with n assign to sizeof ( a ) / sizeof ( a array of 0   )
insert_element ( a, n )
","Count of elements to be inserted to make Array sum twice the XOR of Array 
 C ++ program to find the count of elements to be inserted to make Array sum twice the XOR of Array ; Function to find the minimum number of elements that need to be inserted such that the sum of the elements of the array is twice the XOR of the array ; Variable to store the Xor of all the elements ; Variable to store the sum of all elements ; Loop to find the Xor and the sum of the array ; If sum assign to 2 * Xor ; No need to insert more elements ; We insert one more element which is Sum ; We insert two more elements Sum + Xor and Xor . ; Print the number of elements inserted in the array ; Print the elements that are inserted in the array ; Driver code
",1
17,"declare insert_element with integers a array of   and n, set Xor to 0
Sum assign to integer with Sum assign to 0
untill i assign to 0 to n exclusive, Xor assign to a array of i  
add a array of i   to Sum
if Sum is 2 * Xor print ""0"" print newline
return
if Xor is 0, print ""1"" print newline
print Sum
return
num1 assign to integer with num1 assign to Sum + Xor
create integer num2 with num2 assign to Xor
print ""2""
print num1, "" "", num2 and a new line
declare integer main ( ), integer a assign to  1, 2, 3  ; declare integer array a size   assign to  1, 2, 3
create integer n with n assign to sizeof ( a ) / sizeof ( a array of 0   )
insert_element ( a, n )
","Count of distinct possible pairs such that the element from A is greater than the element from B 
 C ++ Program to count number of distinct pairs possible from the two arrays such that element selected from one array is always greater than the one selected from the other array ; Function to return the count of pairs ; Driver code
",0
18,"if a is equal to c, print Yes
else print No
declare integer main ( ), integers a assign to 2, b assign to 0, c assign to 2
checkSolution ( a, b, c )
return 0
","Check if roots of a Quadratic Equation are reciprocal of each other or not 
 C ++ program to check if roots of a Quadratic Equation are reciprocal of each other or not ; Function to check if the roots of a quadratic equation are reciprocal of each other or not ; Driver code
",1
19,"if a is equal to c, print Yes
else print No
declare integer main ( ), integers a assign to 2, b assign to 0, c assign to 2
checkSolution ( a, b, c )
return 0
","Pascal 's Triangle 
 C ++ code untill Pascal 's Triangle ; binomialCoeff ; Function to print first n lines of Pascal 's Triangle ; Iterate through every line and print entries in it ; Every line has number of integers equal to line number ; Driver program
",0
20,"create boolean isPerfectSquare ( long double x )  long double sr assign to sqrt ( x )
return ( ( sr - floor ( sr ) ) assign to 0 )
print ""Yes STRNEWLINE "" to the standard output
else print ""No STRNEWLINE ""
declare integer main ( ) and integer N assign to 8
checkSunnyNumber is a new line
return 0
","Sunny Number 
 C ++ program untill the above approach ; Function check whether x is a perfect square or not ; Find floating point value of square root of x . ; If square root is an integer ; Function to check Sunny Number ; Check if ( N + 1 ) is a perfect square or not ; If ( N + 1 ) is not a perfect square ; Driver Code ; Given Number ; Function call
",1
21,"create boolean isPerfectSquare ( long double x )  long double sr assign to sqrt ( x )
return ( ( sr - floor ( sr ) ) assign to 0 )
print ""Yes STRNEWLINE "" to the standard output
else print ""No STRNEWLINE ""
declare integer main ( ) and integer N assign to 8
checkSunnyNumber is a new line
return 0
","Minimum count of numbers required with unit digit X that sums up to N 
 C ++ Program to implement the above approach ; Function to calculate and return the minimum number of times a number with unit digit X needs to be added to get a sum N ; Calculate the number of additions required to get unit digit of N ; If unit digit of N cannot be obtained ; Function to return the minimum number required to represent N ; Stores unit digit of N ; Stores minimum addition of X required to obtain unit digit of N ; If unit digit of N cannot be obtained ; Otherwise ; If N is greater than or equal to ( X * times ) ; Minimum count of numbers that needed to represent N ; Representation not possible ; Driver Code
",0
22,"declare integer countValues ( integer n)  integer answer assign to 0
untill i assign to 2 to n inclusive, k assign to n
untill k >assign to i, if k modulo i is 0, k assign to k / i
else decrement k by i
if k is 1 increment answer
return answer
declare integer main ( ) and integer N assign to 6
print countValues ( N)
return 0
","Count the numbers which can convert N to 1 using given operation 
 C ++ program to count the numbers which can convert N to 1 using the given operation ; Function to count the numbers which can convert N to 1 using the given operation ; Iterate through all the integers ; Check if N can be converted to 1 ; Incrementing the count if it can be converted ; Driver code
",1
23,"declare integer countValues ( integer n)  integer answer assign to 0
untill i assign to 2 to n inclusive, k assign to n
untill k >assign to i, if k modulo i is 0, k assign to k / i
else decrement k by i
if k is 1 increment answer
return answer
declare integer main ( ) and integer N assign to 6
print countValues ( N)
return 0
","Print n smallest elements from given array in their original order 
 CPP untill printing smallest n number in order ; Function to print smallest n numbers ; Make copy of array ; Sort copy array ; For each arr array of i   find whether it is a part of n - smallest with binary search ; Driver program
",0
24,"printKNumbers is a void function with int arguments N and K that returns 0 and K - 1 exclusive, print 1 and "" ""
print N - K + 1
declare integer main ( ), integer N assign to 10 and K assign to 3
printKNumbers ( N, K )
return 0
","Find K numbers with sum equal to N and sum of their squares maximized 
 C ++ program to find K numbers with sum equal to N and the sum of their squares maximized ; Function that prints the required K numbers ; Print 1 , K - 1 times ; Print ( N - K + 1 ) ; Driver Code
",1
25,"printKNumbers is a void function with int arguments N and K that returns 0 and K - 1 exclusive, print 1 and "" ""
print N - K + 1
declare integer main ( ), integer N assign to 10 and K assign to 3
printKNumbers ( N, K )
return 0
","Numbers untillmed by flipping common set bits in two given integers 
 C ++ program to implement the above approach ; Function to flip bits of A and B which are set bits in A and B ; Iterater all possible bits of A and B ; If ith bit is set in both A and B ; Clear i - th bit of A ; Clear i - th bit of B ; Print A and B ; Driver Code
",0
26,"NthSmallest is a new integer function with value K, queue and value Q
create integer x
untill i assign to 1 to 10 exclusive, push ( i ) Q
untill i assign to 1 to K inclusive, set x to Q. front ( )
pop Q
if x modulo 10 is not 0, push ( x * 10 + x modulo 10 - 1 )
push ( x * 10 + x % 10 )
if x modulo 10 is not 9 then push ( x * 10 + x modulo 10 + 1 )
return x
declare integer main ( ) and integer N assign to 16
print NthSmallest ( N) and "" STRNEWLINE ""
return 0
","Print Nth Stepping or Autobiographical number 
 C ++ implementation to find NaTMth stepping natural Number ; Function to find the Nth stepping natural number ; Declare the queue ; Enqueue 1 , 2 , ... , 9 in this order ; Peruntillm K operation on queue ; Get the ith Stepping number ; Peruntillm Dequeue from the Queue ; If x mod 10 is not equal to 0 ; then Enqueue 10 x + ( x mod 10 ) - 1 ; Enqueue 10 x + ( x mod 10 ) ; If x mod 10 is not equal to 9 ; then Enqueue 10 x + ( x mod 10 ) + 1 ; Return the dequeued number of the K - th operation as the Nth stepping number ; Driver Code ; initialise K
",1
27,"NthSmallest is a new integer function with value K, queue and value Q
create integer x
untill i assign to 1 to 10 exclusive, push ( i ) Q
untill i assign to 1 to K inclusive, set x to Q. front ( )
pop Q
if x modulo 10 is not 0, push ( x * 10 + x modulo 10 - 1 )
push ( x * 10 + x % 10 )
if x modulo 10 is not 9 then push ( x * 10 + x modulo 10 + 1 )
return x
declare integer main ( ) and integer N assign to 16
print NthSmallest ( N) and "" STRNEWLINE ""
return 0
","Program to find whether a no is power of two 
 C ++ Program to find whether a no is power of two ; Function to check if x is power of 2 ; Driver program
",0
28,"declare integer nearest ( integer n )  integer prevSquare assign to sqrt (n )
nextSquare assign to integer with nextSquare assign to prevSquare + 1
prevSquare assign to prevSquare * prevSquare
set nextSquare to nextSquare * nextSquare
ans assign to integer with ans assign to ( n - prevSquare ) if nextSquare - n is true, else ( nextSquare - n )
return ans
declare integer main ( ) and integer n assign to 14
print nearest (n ) print newline
set n to 16
print nearest (n ) print newline
n assign to 18
print nearest (n ) print newline
return 0
","Least number to be added to or subtracted from N to make it a Perfect Square 
 C ++ implementation of the approach ; Function to return the Least number ; Get the perfect square beuntille and after N ; Check which is nearest to N ; return the result ; Driver code
",1
29,"declare integer nearest ( integer n )  integer prevSquare assign to sqrt (n )
nextSquare assign to integer with nextSquare assign to prevSquare + 1
prevSquare assign to prevSquare * prevSquare
set nextSquare to nextSquare * nextSquare
ans assign to integer with ans assign to ( n - prevSquare ) if nextSquare - n is true, else ( nextSquare - n )
return ans
declare integer main ( ) and integer n assign to 14
print nearest (n ) print newline
set n to 16
print nearest (n ) print newline
n assign to 18
print nearest (n ) print newline
return 0
","Minimum flips to remove any consecutive 3 0 s or 1 s in given Binary string 
 C ++ program untill the above approach ; Function to find the minimum number of flips to make all three pairs of consecutive characters different ; Stores resultant count of pairs ; Base Case ; Iterate over the range array of 0 , N - 2   ; If the consecutive 3 numbers are the same then increment the count and the counter ; Return the answer ; Driver Code
",0
30,"create void function printValueOfPi with integer N and double pi assign to 2 * acos (0.0)
printf ( "" %. * lf STRNEWLINE "", N, pi )
declare integer main ( ) and integer N assign to 45
printValueOfPi ( N )
return 0
","Value of Pi ( ÃŽ ) up to 50 decimal places 
 C ++ program to calculate the value of pi up to n decimal places ; Function that prints the value of pi upto N decimal places ; Find value of pi upto using acos ( ) function ; Print value of pi upto N decimal places ; Driver Code ; Function that prints the value of pi
",1
31,"create void function printValueOfPi with integer N and double pi assign to 2 * acos (0.0)
printf ( "" %. * lf STRNEWLINE "", N, pi )
declare integer main ( ) and integer N assign to 45
printValueOfPi ( N )
return 0
","Anti 
 C ++ program untill the above approach ; Iterative function to reverse digits of num ; Return the reversed num ; Function to calculate sum of reverse all proper divisors ; Final result of summation of divisors ; Find all divisors of num ; If ' i ' is divisor of ' num ' ; If both divisors are same then add it only once else add both ; Add 1 to the result as 1 is also a divisor ; Function to check if N is anti - perfect or not ; Driver Code ; Given Number N ; Function Call
",0
32,"declare decBinary with integer arr array of  , integer n, k assign to log2 (n ) as arguments, returning void
untill n > 0, set arr array of k --   to n modulo 2
divide n by 2
declare binaryDec with integer arr array of  , integer n, integer ans assign to 0
untill i assign to 0 to n exclusive, increment ans by arr array of i    ( n - i - 1 )
return ans
declare getNum with integers n, k as arguments, l assign to log2 (n ) + 1 as arguments
create integer a with a assign to  0 .
declare decBinary with a, n as arguments, returning decBinary
if k is greater than l, return n
if a array of k - 1   assign to ( a array of k - 1   assign to 0 ) if a array of k - 1   assign to 0 else 0
return binaryDec ( a, l )
declare integer main ( ), integers n assign to 56, k assign to 2
print getNum ( n, k )
return 0
","Invert the Kth most significant bit of N 
 C ++ implementation of the approach ; Function to convert decimal number n to its binary representation stored as an array arr array of   ; Function to convert the number represented as a binary array arr array of   into its decimal equivalent ; Function to return the updated integer after flipping the kth bit ; Number of bits in n ; Find the binary representation of n ; The number of bits in n are less than k ; Flip the kth bit ; Return the decimal equivalent of the number ; Driver code
",1
33,"declare decBinary with integer arr array of  , integer n, k assign to log2 (n ) as arguments, returning void
untill n > 0, set arr array of k --   to n modulo 2
divide n by 2
declare binaryDec with integer arr array of  , integer n, integer ans assign to 0
untill i assign to 0 to n exclusive, increment ans by arr array of i    ( n - i - 1 )
return ans
declare getNum with integers n, k as arguments, l assign to log2 (n ) + 1 as arguments
create integer a with a assign to  0 .
declare decBinary with a, n as arguments, returning decBinary
if k is greater than l, return n
if a array of k - 1   assign to ( a array of k - 1   assign to 0 ) if a array of k - 1   assign to 0 else 0
return binaryDec ( a, l )
declare integer main ( ), integers n assign to 56, k assign to 2
print getNum ( n, k )
return 0
","Find a specific pair in Matrix 
 An efficient method to find maximum value of mat array of d   - ma array of a   array of b   such that c > a and d > b ; The function returns maximum value A ( c , d ) - A ( a , b ) over all choices of indexes such that both c > a and d > b . ; stores maximum value ; maxArr array of i   array of j   stores max of elements in matrix from ( i , j ) to ( N - 1 , N - 1 ) ; last element of maxArr will be same 's as of  the input matrix ; preprocess last row Initialize max ; preprocess last column Initialize max ; preprocess rest of the matrix from bottom ; Update maxValue ; set maxArr ( i , j ) ; Driver program to test above function
",0
34,"MOD assign to const with MOD assign to 1e9 + 7
let result be a ll array of size MAX + 1
declare ll fact array of MAX + 1 
preCompute is a void function with fact assign to 1
set result array of0  to 1
untill i assign to 1 to MAX inclusive, set fact array ofi   to ( fact array of i - 1   % MOD ) * i ) % MOD
set result array ofi  to ( result array of i - 1   % MOD ) * fact array of i   % MOD ) % MOD
void function peruntillmQueries (int q array of  , int n) and preCompute ( )
untill i assign to 0 to n exclusive, print result array ofq array ofi   print "" STRNEWLINE ""
declare integer main ( ), integer array q assign to  4, 5
create integer n with n assign to sizeof (q ) / sizeof (q array of 0   )
peruntillmQueries ( q, n )
return 0
","Queries untill the product of first N factorials 
 C ++ implementation of the approach ; Declare result array globally ; Function to precompute the product of factorials upto MAX ; Initialize base condition if n assign to 0 then factorial of 0 is equal to 1 and answer untill n assign to 0 is 1 ; Iterate loop from 1 to MAX ; factorial ( i ) assign to factorial ( i - 1 ) * i ; Result untill current n is equal to result array of i - 1   multiplied by the factorial of i ; Function to peruntillm the queries ; Precomputing the result till MAX ; Peruntillm queries ; Driver code
",1
35,"MOD assign to const with MOD assign to 1e9 + 7
let result be a ll array of size MAX + 1
declare ll fact array of MAX + 1 
preCompute is a void function with fact assign to 1
set result array of0  to 1
untill i assign to 1 to MAX inclusive, set fact array ofi   to ( fact array of i - 1   % MOD ) * i ) % MOD
set result array ofi  to ( result array of i - 1   % MOD ) * fact array of i   % MOD ) % MOD
void function peruntillmQueries (int q array of  , int n) and preCompute ( )
untill i assign to 0 to n exclusive, print result array ofq array ofi   print "" STRNEWLINE ""
declare integer main ( ), integer array q assign to  4, 5
create integer n with n assign to sizeof (q ) / sizeof (q array of 0   )
peruntillmQueries ( q, n )
return 0
","Find all elements in array which have at 
 Sorting based C ++ program to find all elements in array which have atleast two greater elements itself . ; Driver Code
",0
36,"gcd assign to integer if a is equal to 0, return b
return gcd ( b modulo a, a )
divTermCount is a new long function with long arguments a, b, c, num, - ( num / ( ( a * b ) / gcd ( a, b ) ) ) ) - ( num / ( ( ( ( a * b ) / gcd ( a, b ) ) ) ) ) - ( num / ( ( (
declare findNthTerm with integers a, b, c, n, low, high assign to LONG_MAX, mid as arguments, returning integer
untill low  high, mid assign to low + ( high - low ) / 2
if divTermCount ( a, b, c, mid )  n, low assign to mid + 1
else high assign to mid
return low
declare integer main ( ), long a assign to 2, b assign to 3, c assign to 5, n assign to 100
print findNthTerm ( a, b, c, n )
return 0
","Nth number in a set of multiples of A , B or C 
 C ++ program to find nth term divisible by a , b or c ; Function to return gcd of a and b ; Function to return the count of integers from the range array of 1 , num   which are divisible by either a , b or c ; Calculate the number of terms divisible by a , b and c then remove the terms which are divisible by both ( a , b ) or ( b , c ) or ( c , a ) and then add the numbers which are divisible by a , b and c ; Function untill binary search to find the nth term divisible by a , b or c ; Set low to 1 and high to LONG_MAX ; If the current term is less than n then we need to increase low to mid + 1 ; If current term is greater than equal to n then high assign to mid ; Driver code
",1
37,"gcd assign to integer if a is equal to 0, return b
return gcd ( b modulo a, a )
divTermCount is a new long function with long arguments a, b, c, num, - ( num / ( ( a * b ) / gcd ( a, b ) ) ) ) - ( num / ( ( ( ( a * b ) / gcd ( a, b ) ) ) ) ) - ( num / ( ( (
declare findNthTerm with integers a, b, c, n, low, high assign to LONG_MAX, mid as arguments, returning integer
untill low  high, mid assign to low + ( high - low ) / 2
if divTermCount ( a, b, c, mid )  n, low assign to mid + 1
else high assign to mid
return low
declare integer main ( ), long a assign to 2, b assign to 3, c assign to 5, n assign to 100
print findNthTerm ( a, b, c, n )
return 0
","Find extra element in the second array 
 C ++ implementation of the approach ; Function to return the extra element in B array of   ; To store the result ; Find the XOR of all the element of array A array of   and array B array of   ; Driver code
",0
38,"declare calculate_angle with integers n, i, j, k, as arguments, returning integers, returning integers x, y
if i is less than j, set x to j - i
else x assign to j + n - i
if j is less than k, set y to k - j
else y assign to k + n - j
ang1 assign to double with ang1 assign to ( 180 * x ) / n
ang2 assign to double with ang2 assign to ( 180 * y ) / n
ans assign to double with ans assign to 180 - ang1 - ang2
return ans
declare integer main ( ) and integer n assign to 5
a1 assign to integer with a1 assign to 1
create integer a2 with a2 assign to 2
create integer a3 with a3 assign to 5
print calculate_angle ( n, a1, a2, a3 )
return 0
","Angle between 3 given vertices in a n 
 C ++ implementation of the approach ; Function that checks whether given angle can be created using any 3 sides ; Initialize x and y ; Calculate the number of vertices between i and j , j and k ; Calculate the angle subtended at the circumference ; Angle subtended at j can be found using the fact that the sum of angles of a triangle is equal to 180 degrees ; Driver code
",1
39,"declare calculate_angle with integers n, i, j, k, as arguments, returning integers, returning integers x, y
if i is less than j, set x to j - i
else x assign to j + n - i
if j is less than k, set y to k - j
else y assign to k + n - j
ang1 assign to double with ang1 assign to ( 180 * x ) / n
ang2 assign to double with ang2 assign to ( 180 * y ) / n
ans assign to double with ans assign to 180 - ang1 - ang2
return ans
declare integer main ( ) and integer n assign to 5
a1 assign to integer with a1 assign to 1
create integer a2 with a2 assign to 2
create integer a3 with a3 assign to 5
print calculate_angle ( n, a1, a2, a3 )
return 0
","Maximize count of elements that can be selected having minimum difference between their sum and K 
 C ++ implementation of the above approach ; Function to count maximum number of elements that can be selected ; Sort he array ; Traverse the array ; Add current element to the sum ; IF sum exceeds k ; Increment count ; Return the count ; Driver Code ; Function call
",0
40,"declare void Loss with integer SP, integer P, float loss assign to 0
loss assign to ( 2 * P * P * SP) / float ( 100 * 100 - P * P )
print Loss and loss
declare integer variables main and P assign to 30
Loss ( SP, P )
return 0
","Loss when two items are sold at same price and same percentage profit / loss 
 C ++ implementation of above approach . ; Function that will find loss ; Driver Code ; Calling Function
",1
41,"declare void Loss with integer SP, integer P, float loss assign to 0
loss assign to ( 2 * P * P * SP) / float ( 100 * 100 - P * P )
print Loss and loss
declare integer variables main and P assign to 30
Loss ( SP, P )
return 0
","Longest Increasing Path in Matrix 
 CPP program to find longest increasing path in a matrix . ; Return the length of LIP in 2D matrix ; If value not calculated yet . ; If reach bottom left cell , return 1. ; If reach the corner of the matrix . ; If value greater than below cell . ; If value greater than left cell . ; Wrapper function ; Driven Program
",0
42,"create integer spf array of MAXN 
create integer hash1 array of MAXN  with hash1 assign to  0  0
void function sieve (no args, return void )  spf array of 1   assign to 1
untill i assign to 2 to MAXN exclusive, set spf array of i   to i
untill i assign to 4 to MAXN exclusive, set spf array of i   to 2
untill i assign to 3 to MAXN exclusive, if j assign to i * i, j  MAXN, j +assign to i, if spf array ofj   assign to j, spf array ofj   assign to i
create int getFactorization ( int x) and int temp
untill x is not 1 set temp to spf array of x  
if x modulo temp is 0, increment hash1 array of spf array of x   
set x to x / spf array of x  
untill x modulo temp is 0, set x to x / temp
print boolean check ( int x) and temp
untill x is not 1 set temp to spf array of x  
if x modulo temp is 0 and hash1 array of temp  is greater than 1 return false
untill x modulo temp is 0, set x to x / temp
return true
create boolean hasValidNum ( int arr array of  , int n ) and sieve ( )
untill i assign to 0 to n exclusive, getFactorization ( arr array of i   )
return true if check ( arr array of i   ) is true
return false
declare integer main ( ), integer arr array of   assign to  2, 8, 4, 10, 6, 7  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
if hasValidNum ( arr, n ) is true, print Yes
else print No
return 0
","Check untill an array element that is co 
 C ++ implementation of the approach ; Stores smallest prime factor untill every number ; Hash to store prime factors count ; Function to calculate SPF ( Smallest Prime Factor ) untill every number till MAXN ; Marking smallest prime factor untill every number to be itself ; Separately marking spf untill every even number as 2 ; Checking if i is prime ; Marking SPF untill all numbers divisible by i ; Marking spf array of j   if it is not previously marked ; Function to store the prime factors after dividing by the smallest prime factor at every step ; Storing the count of prime factors in hash ; Function that returns true if there are no common prime factors between x and other numbers of the array ; Checking whether it common prime factor with other numbers ; Function that returns true if there is an element in the array which is coprime with all the other elements of the array ; Using sieve untill generating prime factors ; Checking the common prime factors with other numbers ; Driver code
",1
43,"create integer spf array of MAXN 
create integer hash1 array of MAXN  with hash1 assign to  0  0
void function sieve (no args, return void )  spf array of 1   assign to 1
untill i assign to 2 to MAXN exclusive, set spf array of i   to i
untill i assign to 4 to MAXN exclusive, set spf array of i   to 2
untill i assign to 3 to MAXN exclusive, if j assign to i * i, j  MAXN, j +assign to i, if spf array ofj   assign to j, spf array ofj   assign to i
create int getFactorization ( int x) and int temp
untill x is not 1 set temp to spf array of x  
if x modulo temp is 0, increment hash1 array of spf array of x   
set x to x / spf array of x  
untill x modulo temp is 0, set x to x / temp
print boolean check ( int x) and temp
untill x is not 1 set temp to spf array of x  
if x modulo temp is 0 and hash1 array of temp  is greater than 1 return false
untill x modulo temp is 0, set x to x / temp
return true
create boolean hasValidNum ( int arr array of  , int n ) and sieve ( )
untill i assign to 0 to n exclusive, getFactorization ( arr array of i   )
return true if check ( arr array of i   ) is true
return false
declare integer main ( ), integer arr array of   assign to  2, 8, 4, 10, 6, 7  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
if hasValidNum ( arr, n ) is true, print Yes
else print No
return 0
","Program to check if a matrix is symmetric 
 Efficient c ++ code untill check a matrix is symmetric or not . ; Returns true if mat array of N   array of N   is symmetric , else false ; Driver code
",0
44,"declare integer countWays ( integer N)  integer E assign to ( N * ( N - 1 ) ) / 2
if N is 1 return 0
return pow ( 2, E - 1 )
declare integer main ( ) and integer N assign to 4
print countWays ( N)
return 0
","Ways to Remove Edges from a Complete Graph to make Odd Edges 
 C ++ implementation of the approach ; Function to return the number of ways to remove edges from the graph so that odd number of edges are left in the graph ; Total number of edges ; Driver code
",1
45,"declare integer countWays ( integer N)  integer E assign to ( N * ( N - 1 ) ) / 2
if N is 1 return 0
return pow ( 2, E - 1 )
declare integer main ( ) and integer N assign to 4
print countWays ( N)
return 0
","Rearrange positive and negative numbers with constant extra space 
 C ++ program to Rearrange positive and negative numbers in a array ; Function to print an array ; Function to reverse an array . An array can be reversed in O ( n ) time and O ( 1 ) space . ; Merges two subarrays of arr array of   . First subarray is arr array of l . . m   Second subarray is arr array of m + 1. . r   ; Initial index of 1 st subarray ; Initial index of IInd ; arr array of i . . m   is positive ; arr array of j . . r   is positive reverse positive part of left sub - array ( arr array of i . . m   ) ; reverse negative part of right sub - array ( arr array of m + 1. . j - 1   ) ; reverse arr array of i . . j - 1   ; Function to Rearrange positive and negative numbers in a array ; Same as ( l + r ) / 2 , but avoids overflow untill large l and h ; Sort first and second halves ; Driver code
",0
46,"create integer l with size 1001   array of 1001   assign to  0  ;
initialize assign to void, l assign to l assign to l assign to l assign to 0, 0 assign to 0 assign to 1
untill i assign to 1 to 1001 exclusive, l array of i   array of 0   assign to 1
untill j assign to 1 to i + 1 exclusive, l array of i   array of j   assign to ( l array of i - 1   array of j - 1   + l array of i - 1   array of j   )
return l array of n   array of r  
declare integer main ( ) and initialize ( )
create integer n with n assign to 8
r assign to integer with r assign to 3
print nCr ( n, r )
","Calculate nCr using Pascal 's Triangle 
 C ++ implementation of the approach ; Initialize the matrix with 0 ; 0 C0 assign to 1 ; Set every nCr assign to 1 where r assign to 0 ; Value untill the current cell of Pascal 's triangle ; Function to return the value of nCr ; Return nCr ; Driver code ; Build the Pascal 's triangle
",1
47,"create integer l with size 1001   array of 1001   assign to  0  ;
initialize assign to void, l assign to l assign to l assign to l assign to 0, 0 assign to 0 assign to 1
untill i assign to 1 to 1001 exclusive, l array of i   array of 0   assign to 1
untill j assign to 1 to i + 1 exclusive, l array of i   array of j   assign to ( l array of i - 1   array of j - 1   + l array of i - 1   array of j   )
return l array of n   array of r  
declare integer main ( ) and initialize ( )
create integer n with n assign to 8
r assign to integer with r assign to 3
print nCr ( n, r )
","Minimum number of coins to be collected per hour to empty N piles in at most H hours 
 C ++ program untill the above approach ; Function to find the minimum number of coins to be collected per hour to empty N piles in H hours ; Stores the minimum coins to be removed per hour ; Find the maximum array element ; Peruntillm Binary Search ; Store the mid value of the range in K ; Find the total time taken to empty N piles by removing K coins per hour ; If total time does not exceed H ; Otherwise ; Print the required result ; Driver Code ; Function Call
",0
48,"minAbsDiff assign to integer with minAbsDiff assign to n modulo 4
if mod is 0 mod is 3 return 0
return 1
declare integer main ( ) and integer n assign to 5
print minAbsDiff ( n )
return 0
","Closest sum partition ( into two subsets ) of numbers from 1 to n 
 C ++ implementation of the approach ; Function to return the minimum required absolute difference ; Driver code
",1
49,"minAbsDiff assign to integer with minAbsDiff assign to n modulo 4
if mod is 0 mod is 3 return 0
return 1
declare integer main ( ) and integer n assign to 5
print minAbsDiff ( n )
return 0
","Lexicographically smallest string with given string as prefix 
 C ++ program untill the above approach ; Function to find the whether the string temp starts with str or not ; Base Case ; Check untill the corresponding characters in temp & str ; Function to find lexicographic smallest string consisting of the string str as prefix ; Sort the given array string arr array of   ; If the i - th string contains given string as a prefix , then print the result ; If no string exists then return "" - 1"" ; Driver Code
",0
50,"declare check with integer s, freq assign to 0, r assign to integers with freq assign to 0
untill s is not 0, set r to s modulo 10
s assign to integer ( s / 10 )
increment freq array of r  by 1
xor__ assign to integer with xor__ assign to 0
untill i assign to 0 to 10 exclusive, xor__ assign to xor__ and freq array of i  
if xor__ is 0, return true
else return false
declare integer main ( ), integer s assign to 122233
if check ( s ) is true, print Yes and newline
else print No
","Check if the Xor of the frequency of all digits of a number N is zero or not 
 C ++ implementation of the above approach ; creating a frequency array ; Finding the last digit of the number ; Dividing the number by 10 to eliminate last digit ; counting frequency of each digit ; checking if the xor of all frequency is zero or not ; Driver function
",1
51,"declare check with integer s, freq assign to 0, r assign to integers with freq assign to 0
untill s is not 0, set r to s modulo 10
s assign to integer ( s / 10 )
increment freq array of r  by 1
xor__ assign to integer with xor__ assign to 0
untill i assign to 0 to 10 exclusive, xor__ assign to xor__ and freq array of i  
if xor__ is 0, return true
else return false
declare integer main ( ), integer s assign to 122233
if check ( s ) is true, print Yes and newline
else print No
","Convert vowels into upper case character in a given string 
 C ++ program to implement the above approach ; Function to convert vowels into uppercase ; Stores the length of str ; Driver Code
",0
52,"printLines is a void function with int arguments n and k, print k * ( 6 * i + 1), "" "", k * ( 6 * i + 2), "" "", k * ( 6 * i + 3 ) and "" "", k * ( 6 * i + 5 ) and a new line
declare integer main ( ), integers n assign to 2 and k assign to 2
printLines ( n, k )
return 0
","Print N lines of 4 numbers such that every pair among 4 numbers has a GCD K 
 C ++ implementation of the above approach ; Function to print N lines ; Iterate N times to print N lines ; Driver Code
",1
53,"printLines is a void function with int arguments n and k, print k * ( 6 * i + 1), "" "", k * ( 6 * i + 2), "" "", k * ( 6 * i + 3 ) and "" "", k * ( 6 * i + 5 ) and a new line
declare integer main ( ), integers n assign to 2 and k assign to 2
printLines ( n, k )
return 0
","Check if it is possible to split given Array into K odd 
 C ++ implementation to check if it is possible to split array into K subsets with odd sum ; Function to check if array can be split in required K subsets ; Store count of odd numbers ; Check if element is odd ; Check if split is possible ; Driver Program
",0
54,"declare calculateSum with integer n as argument, returning ( pow ( 2, n + 1 ) + n - 2 )
declare integer main ( ) and integer n assign to 4
print Sum and calculateSum (n )
return 0
","Sum of first n term of Series 3 , 5 , 9 , 17 , 33. ... 
 C ++ program to find sum of first n terms ; Sn assign to n * ( 4 * n * n + 6 * n - 1 ) / 3 ; Driver code ; number of terms to be included in sum ; find the Sn
",1
55,"declare calculateSum with integer n as argument, returning ( pow ( 2, n + 1 ) + n - 2 )
declare integer main ( ) and integer n assign to 4
print Sum and calculateSum (n )
return 0
","Count n digit numbers not having a particular digit 
 C ++ Implementation of above method ; Finding number of possible number with n digits excluding a particular digit ; Checking if number of digits is zero ; Checking if number of digits is one ; Checking if number of digits is odd ; Calling digitNumber function with ( digit - 1 ) / 2 digits ; Calling digitNumber function with n / 2 digits ; Calling digitNumber function Checking if excluding digit is zero or non - zero ; Driver function to run above program ; Initializing variables
",0
56,"declare long count_special with long n as argument, returning long fib array of n + 1  
set fib array of 0   to 1
set fib array of 1   to 2
untill i assign to 2 to n inclusive, set fib array of i   to ( fib array of i - 1   % mod + fib array of i - 2   % mod ) % mod
return fib array of n  
declare integer main ( ) and long n assign to 3
print count_special ( n ) print newline
return 0
","Count the number of Special Strings of a given length N 
 C ++ Program to Count the number of Special Strings of a given length N ; Function to return count of special strings ; stores the answer untill a particular value of n ; untill n assign to 0 we have empty string ; untill n assign to 1 we have 2 special strings ; calculate count of special string of length i ; fib array of n   stores the count of special strings of length n ; Driver code ; initialise n
",1
57,"declare long count_special with long n as argument, returning long fib array of n + 1  
set fib array of 0   to 1
set fib array of 1   to 2
untill i assign to 2 to n inclusive, set fib array of i   to ( fib array of i - 1   % mod + fib array of i - 2   % mod ) % mod
return fib array of n  
declare integer main ( ) and long n assign to 3
print count_special ( n ) print newline
return 0
","Program untill array rotation 
 C ++ program to rotate an array by d elements ; Function to left Rotate arr array of   of size n by 1 ; Function to left rotate arr array of   of size n by d ; utility function to print an array ; Driver program to test above functions
",0
58,"mod assign to const int with mod assign to 1e9 + 7
return 1 if i is n - 1
create integer sum with sum assign to 0
untill j assign to 1 to j + i  n and j assign to arr array of i  , increment sum by ( ways ( i + j, arr, n ) ) % mod
set sum to sum modulo mod
return sum modulo mod
declare integer main ( ), integer arr array of   assign to  5, 3, 1, 4, 3  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print ways ( 0, arr, n )
return 0
","Counts Path in an Array 
 C ++ implementation of the above approach ; Find the number of ways to reach the end ; Base case ; Recursive structure ; Driver code
",1
59,"mod assign to const int with mod assign to 1e9 + 7
return 1 if i is n - 1
create integer sum with sum assign to 0
untill j assign to 1 to j + i  n and j assign to arr array of i  , increment sum by ( ways ( i + j, arr, n ) ) % mod
set sum to sum modulo mod
return sum modulo mod
declare integer main ( ), integer arr array of   assign to  5, 3, 1, 4, 3  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print ways ( 0, arr, n )
return 0
","Longest subarray not having more than K distinct elements 
 CPP program to find longest subarray with k or less distinct elements . ; function to print the longest sub - array ; mark the element visited ; if its visited first time , then increase the counter of distinct elements by 1 ; When the counter of distinct elements increases from k , then reduce it to k ; from the left , reduce the number of time of visit ; if the reduced visited time element is not present in further segment then decrease the count of distinct elements ; increase the subsegment mark ; check length of longest sub - segment when greater then previous best then change it ; print the longest sub - segment ; driver program to test the above function
",0
60,"mod assign to const int with mod assign to 1e9 + 7
declare integer ways ( int arr array of  , int n ) and integer dp array of n + 1  
set dp array of n - 1   to 1
untill i assign to n - 2 to 0 inclusive, dp array of i   assign to 0
untill j assign to 1 to n and j assign to arr array of i   ), dp array of i   + dp array of i + j  
dp array of i   %assign to mod
return dp array of 0   modulo mod
declare integer main ( ), integer arr array of   assign to  5, 3, 1, 4, 3  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print ways ( arr, n ) % mod
return 0
","Counts Path in an Array 
 C ++ implementation ; find the number of ways to reach the end ; dp to store value ; base case ; Bottom up dp structure ; F array of i   is dependent of F array of i + 1   to F array of i + k   ; Return value of dp array of 0   ; Driver code
",1
61,"mod assign to const int with mod assign to 1e9 + 7
declare integer ways ( int arr array of  , int n ) and integer dp array of n + 1  
set dp array of n - 1   to 1
untill i assign to n - 2 to 0 inclusive, dp array of i   assign to 0
untill j assign to 1 to n and j assign to arr array of i   ), dp array of i   + dp array of i + j  
dp array of i   %assign to mod
return dp array of 0   modulo mod
declare integer main ( ), integer arr array of   assign to  5, 3, 1, 4, 3  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print ways ( arr, n ) % mod
return 0
","Check whether Arithmetic Progression can be untillmed from the given array 
 C ++ program to check if a given array can untillm arithmetic progression ; Returns true if a permutation of arr array of 0. . n - 1   can untillm arithmetic progression ; Sort array ; After sorting , difference between consecutive elements must be same . ; Driven Program
",0
62,"create pair  integers, integers > countSum ( integer arr array of  , integer n ), result assign to 0
count_odd, count_even assign to integers
set count_odd to 0
set count_even to 0
untill i assign to 1 to n inclusive, set count_even to count_even + count_even + 1
set count_odd to count_odd + count_odd
else set temp to count_even
set count_even to count_even + count_odd
set count_odd to count_odd + temp + 1
return  count_even, count_odd
declare integer main ( ), integer arr assign to  1, 2, 2, 2, 3  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create pair  int, integer > ans assign to countSum ( arr, n )
print EvenSum and ans. first
print OddSum and ans second
return 0
","Number of Subsequences with Even and Odd Sum 
 C ++ implementation ; Returns the count of odd and even subsequences ; Variables to store the count of even subsequences and odd subsequences ; Initialising count_even and count_odd to 0 since as there is no subsequence beuntille the iteration with even or odd count . ; Find sum of all subsequences with even count and odd count and storing them as we iterate . ; if the number is even ; if the number is odd ; Driver code ; Calling the function
",1
63,"create pair  integers, integers > countSum ( integer arr array of  , integer n ), result assign to 0
count_odd, count_even assign to integers
set count_odd to 0
set count_even to 0
untill i assign to 1 to n inclusive, set count_even to count_even + count_even + 1
set count_odd to count_odd + count_odd
else set temp to count_even
set count_even to count_even + count_odd
set count_odd to count_odd + temp + 1
return  count_even, count_odd
declare integer main ( ), integer arr assign to  1, 2, 2, 2, 3  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create pair  int, integer > ans assign to countSum ( arr, n )
print EvenSum and ans. first
print OddSum and ans second
return 0
","N consecutive ropes problem 
 C ++ implementation of the approach ; Function to return the minimum cost to connect the given ropes ; dp array of i   array of j   assign to minimum cost in range ( i , j ) sum array of i   array of j   assign to sum of range ( i , j ) ; Initializing the sum table ; Computing minimum cost untill all the possible interval ( i , j ) Left range ; Right range ; No cost untill a single rope ; Driver code
",0
64,"create vector numToVec ( integer N), vector, integer, digit
untill N is not 0, push_back ( N modulo 10 ) is true
N assign to N / 10
if size of digit is equal to 0, push_back is equal to digit
reverse digits begin ( ) and end ( ) )
return digit
solve assign to vector of integers  integers A, B, C, vector of integers  integer of size digit
create integers d, d2
set digit to numToVec ( C )
d assign to size of A. size ( )
if B is greater than size of digit, d is 0, return 0
else if B is less than digit size ( ) ), if A array of 0   is 0 and B is not 1, return ( d - 1 ) * pow ( d, B - 1 )
else return pow ( d, B )
else dp assign to int with dp assign to 0 and dp assign to 0
lower assign to integer array of size MAX + 1 with lower assign to 0
untill i assign to 0 to d exclusive, lower array of A array of i   + 1   assign to 1
untill i assign to 1 to MAX inclusive lower array of i   assign to lower array of i - 1   + lower array of i  
create boolean flag with flag assign to true
set dp array of 0   to 0
untill i assign to 1 to B inclusive, set d2 to lower array of digit array of i - 1    
dp array of i   assign to dp array of i - 1   * d
if i assign to 1 and A array of0  assign to 0 and Bnot equal to 1, d2 assign to d2 - 1
if flag is true, increment dp array of i   by d2
set flag to ( flag and lower array of digit array of i - 1   + 1   assign to lower array of digit array of i - 1     + 1 ) )
return dp array of B 
declare integer main ( ), vector A assign to  0, 1, 2, 5  ;
create integer N with N assign to 2
create integer k with k assign to 21
print solve ( A, N, k )
return 0
","Count of integers of length N and value less than K such that they contain digits only from the given set 
 C ++ implementation of the approach ; Function to convert a number into vector ; Push all the digits of N from the end one by one to the vector ; If the original number was 0 ; Reverse the vector elements ; Return the required vector ; Function to return the count of B length integers which are less than C and they contain digits from set A array of   only ; Convert number to digit array ; Case 1 : No such number possible as the generated numbers will always be greater than C ; Case 2 : All integers of length B are valid as they all are less than C ; contain 0 ; Case 3 ; Update the lower array of   array such that lower array of i   stores the count of elements in A array of   which are less than i ; For first index we can 't use 0 ; Whether ( i - 1 ) digit of generated number can be equal to ( i - 1 ) digit of C ; Is digit array of i - 1   present in A ? ; Driver code
",1
65,"create vector numToVec ( integer N), vector, integer, digit
untill N is not 0, push_back ( N modulo 10 ) is true
N assign to N / 10
if size of digit is equal to 0, push_back is equal to digit
reverse digits begin ( ) and end ( ) )
return digit
solve assign to vector of integers  integers A, B, C, vector of integers  integer of size digit
create integers d, d2
set digit to numToVec ( C )
d assign to size of A. size ( )
if B is greater than size of digit, d is 0, return 0
else if B is less than digit size ( ) ), if A array of 0   is 0 and B is not 1, return ( d - 1 ) * pow ( d, B - 1 )
else return pow ( d, B )
else dp assign to int with dp assign to 0 and dp assign to 0
lower assign to integer array of size MAX + 1 with lower assign to 0
untill i assign to 0 to d exclusive, lower array of A array of i   + 1   assign to 1
untill i assign to 1 to MAX inclusive lower array of i   assign to lower array of i - 1   + lower array of i  
create boolean flag with flag assign to true
set dp array of 0   to 0
untill i assign to 1 to B inclusive, set d2 to lower array of digit array of i - 1    
dp array of i   assign to dp array of i - 1   * d
if i assign to 1 and A array of0  assign to 0 and Bnot equal to 1, d2 assign to d2 - 1
if flag is true, increment dp array of i   by d2
set flag to ( flag and lower array of digit array of i - 1   + 1   assign to lower array of digit array of i - 1     + 1 ) )
return dp array of B 
declare integer main ( ), vector A assign to  0, 1, 2, 5  ;
create integer N with N assign to 2
create integer k with k assign to 21
print solve ( A, N, k )
return 0
","Area of a n 
 C ++ Program to find the area of a regular polygon with given radius ; Function to find the area of a regular polygon ; Side and radius cannot be negative ; Area degree converted to radians ; Driver code
",0
66,"if wt is less than 0, return 0
if wt is 0, return 1 if used is true
return 0
if dp array of wt   array of used   is not -1, return dp array of wt   array of used  
ans assign to integer with ans assign to 0
untill i assign to 1 to K inclusive, increment ans by solve ( dp, wt - i, K, M, used 1 )
else ans assign to ans + solve ( dp, wt - i, K, M, used )
return dp array of wt  array of used  assign to ans
declare integer main ( ), W assign to 3, K assign to 3, M assign to 2
create integer dp array of W + 1  array of 2 
set all contents of dp to -1
print solve ( dp, W, K, M, 0 )
return 0
","Number of Paths of Weight W in a K 
 C ++ program to count the number of paths with weight W in a K - ary tree ; Function to return the number of ways having weight as wt in K - ary tree ; Return 0 if weight becomes less than zero ; Return one only if the current path has included edge weight of atleast M ; If the current edge weight is greater than or equal to M , set used as true ; Driver Code to test above function
",1
67,"if wt is less than 0, return 0
if wt is 0, return 1 if used is true
return 0
if dp array of wt   array of used   is not -1, return dp array of wt   array of used  
ans assign to integer with ans assign to 0
untill i assign to 1 to K inclusive, increment ans by solve ( dp, wt - i, K, M, used 1 )
else ans assign to ans + solve ( dp, wt - i, K, M, used )
return dp array of wt  array of used  assign to ans
declare integer main ( ), W assign to 3, K assign to 3, M assign to 2
create integer dp array of W + 1  array of 2 
set all contents of dp to -1
print solve ( dp, W, K, M, 0 )
return 0
","Count of N digit Numbers whose sum of every K consecutive digits is equal 
 Set 2 
 C ++ Program to implement the above approach ; Function to count the number of N - digit numbers such that sum of every K consecutive digits are equal ; Print the answer ; Driver Code
",0
68,"partitions assign to long long with integer n, vector assign to long long > p ( n + 1, 0 )
set p array of 0   to 1
untill i assign to 1 to n inclusive, k assign to int with k assign to 1
untill ( k * ( 3 * k - 1 ) ) / 2 assign to i ) p array of i   + ( k % 2? 1 : -1 ) * p array of i - ( k * ( 3 * k - 1 ) ) ) / 2  
if k is greater than 0, set k to k * -1
else k assign to 1 - k
return p array of n  
declare integer main ( ) and integer N assign to 20
print partitions ( N)
return 0
","Ways to write N as sum of two or more positive integers 
 Set 
 C ++ implementation of above approach ; Function to find the number of partitions of N ; Base case ; Driver code
",1
69,"partitions assign to long long with integer n, vector assign to long long > p ( n + 1, 0 )
set p array of 0   to 1
untill i assign to 1 to n inclusive, k assign to int with k assign to 1
untill ( k * ( 3 * k - 1 ) ) / 2 assign to i ) p array of i   + ( k % 2? 1 : -1 ) * p array of i - ( k * ( 3 * k - 1 ) ) ) / 2  
if k is greater than 0, set k to k * -1
else k assign to 1 - k
return p array of n  
declare integer main ( ) and integer N assign to 20
print partitions ( N)
return 0
","Most frequent character in a string after replacing all occurrences of X in a Binary String 
 C ++ program untill the above approach ; Function to find the most frequent character after replacing X with either '0' or '1' according as per the given conditions ; Store the count of 0 s and 1 s in the string S ; Count the frequency of 0 and 1 ; If the character is 1 ; If the character is 0 ; Stores first occurence of 1 ; Traverse the string to count the number of X between two consecutive 1 s ; If the current character is not X ; If the current character is 1 , add the number of Xs to count1 and set prev to i ; Otherwise ; Find next occurence of 1 in the string ; If it is found , set i to prev ; Otherwise , break out of the loop ; Store the first occurence of 0 ; Repeat the same procedure to count the number of X between two consecutive 0 s ; If the current character is not X ; If the current character is 0 ; Add the count of Xs to count0 ; Set prev to i ; Otherwise ; Find the next occurence of 0 in the string ; If it is found , set i to prev ; Otherwise , break out of the loop ; Count number of X present in the starting of the string as XXXX1 ... ; Store the count of X ; Increment count1 by count if the condition is satisfied ; Count the number of X present in the ending of the string as ... XXXX0 ; Store the count of X ; Increment count0 by count if the condition is satisfied ; If count of 1 is equal to count of 0 , print X ; Otherwise , if count of 1 is greater than count of 0 ; Otherwise , print 0 ; Driver Code
",0
70,"if dp array of   array of MAX , int mat array of   array of MAX  , int n, int m, int x, int y, result assign to 0
if x is n - 1 and y is m - 1, return dp array of x   array of y   assign to 1
if x is n - 1 y is m - 1 then set result to 1
if mat array ofx  array ofy  is less than mat array ofx + 1  array ofy , result assign to 1 + LIP ( dp, mat, n, m, x + 1, y )
if mat array ofx  array ofy  is less than mat array ofx  array ofy + 1 , let result be maximum of result and 1 + LIP ( dp, mat, n, m, x, y + 1 ) )
set dp array ofx  array ofy  to result
return dp array of x   array of y  
declare wrapper ( int mat array of   array of MAX , int n, m ) and dp array of MAX   array of MAX  
set all contents of dp to -1
return LIP ( dp, mat, n, m, 0, 0 )
declare integer main ( ) and integer mat ( MAX ) assign to  1, 2, 3, 4 , 2, 3, 4 , 3, 4 , 4 , 5, 6, 7 ,  ;
create integers n, m with n assign to 4 and m assign to 4
print wrapper ( mat, n, m ) and a new line
return 0
","Longest Increasing Path in Matrix 
 CPP program to find longest increasing path in a matrix . ; Return the length of LIP in 2D matrix ; If value not calculated yet . ; If reach bottom left cell , return 1. ; If reach the corner of the matrix . ; If value greater than below cell . ; If value greater than left cell . ; Wrapper function ; Driven Program
",1
71,"if dp array of   array of MAX , int mat array of   array of MAX  , int n, int m, int x, int y, result assign to 0
if x is n - 1 and y is m - 1, return dp array of x   array of y   assign to 1
if x is n - 1 y is m - 1 then set result to 1
if mat array ofx  array ofy  is less than mat array ofx + 1  array ofy , result assign to 1 + LIP ( dp, mat, n, m, x + 1, y )
if mat array ofx  array ofy  is less than mat array ofx  array ofy + 1 , let result be maximum of result and 1 + LIP ( dp, mat, n, m, x, y + 1 ) )
set dp array ofx  array ofy  to result
return dp array of x   array of y  
declare wrapper ( int mat array of   array of MAX , int n, m ) and dp array of MAX   array of MAX  
set all contents of dp to -1
return LIP ( dp, mat, n, m, 0, 0 )
declare integer main ( ) and integer mat ( MAX ) assign to  1, 2, 3, 4 , 2, 3, 4 , 3, 4 , 4 , 5, 6, 7 ,  ;
create integers n, m with n assign to 4 and m assign to 4
print wrapper ( mat, n, m ) and a new line
return 0
","Check if an array is stack sortable 
 C ++ implementation of above approach . ; Function to check if A array of   is Stack Sortable or Not . ; Stack S ; Pointer to the end value of array B . ; Traversing each element of A array of   from starting Checking if there is a valid operation that can be peruntillmed . ; If the stack is not empty ; Top of the Stack . ; If the top of the stack is Equal to B_end + 1 , we will pop it And increment B_end by 1. ; if current top is equal to B_end + 1 , we will increment B_end to B_end + 1 ; Pop the top element . ; If the stack is empty We cannot further perfom this operation . Thereuntille break ; Current Top ; If stack is empty Push the Current element ; If the Current element of the array A array of   if smaller than the top of the stack We can push it in the Stack . ; Else We cannot sort the array Using any valid operations . ; Not Stack Sortable ; If the stack is empty push the current element in the stack . ; Stack Sortable ; Driver 's Code
",0
72,"return 1 if n is 0 and m is 0
return countPaths ( n - 1, m ) + countPaths ( n, m - 1 ) )
declare integer main ( ), integers n assign to 3 and m assign to 2
print Number of Paths and countPaths ( n, m )
return 0
","Counts paths from a point to reach Origin 
 C ++ program to count total number of paths from a point to origin ; Recursive function to count number of paths ; If we reach bottom or top left , we are have only one way to reach ( 0 , 0 ) ; Else count sum of both ways ; Driver Code
",1
73,"return 1 if n is 0 and m is 0
return countPaths ( n - 1, m ) + countPaths ( n, m - 1 ) )
declare integer main ( ), integers n assign to 3 and m assign to 2
print Number of Paths and countPaths ( n, m )
return 0
","Program to check if a matrix is symmetric 
 Simple c ++ code untill check a matrix is symmetric or not . ; Fills transpose of mat array of N   array of N   in tr array of N   array of N   ; Returns true if mat array of N   array of N   is symmetric , else false ; Driver code
",0
74,"create constant integer MAX with MAX assign to 100
create integer getMaxGold ( int gold array of   array of MAX , int m, int n )  int goldTable array of m   array of n  
set all contents of goldtable to 0
untill col assign to n - 1 to 0 inclusive, right assign to int with col assign to n - 1, col assign to 0, col --, right assign to int with col assign to n - 1, goldTable assign to int array of rows of rows and col + 1, 0
set right_up to 0 if row assign to 0 col assign to n - 1 else set goldTable to goldTable array of row - 1   array of col + 1  
set right_down to 0 if row assign to m - 1 col assign to n - 1 else set goldTable to goldTable array of row + 1   array of col + 1  
goldTable array of row   array of col   assign to gold array of row   array of col   + max ( right, max ( right_up, right_down ) )
res assign to goldTable array of 0   array of 0  
untill i assign to 1 to m exclusive, set res to max ( res, goldTable array of i   array of 0   )
return res
declare integer main ( ) and integer array gold with MAX elements, with gold assign to  1, 3, 1, 5 , 2, 4, 1 , 5, 0, 2, 3 , 6, 1, 2        0
create integers m, n with m assign to 4 and n assign to 4
print getMaxGold ( gold, m, n )
return 0
","Gold Mine Problem 
 C ++ program to solve Gold Mine problem ; Returns maximum amount of gold that can be collected when journey started from first column and moves allowed are right , right - up and right - down ; Create a table untill storing intermediate results and initialize all cells to 0. The first row of goldMineTable gives the maximum gold that the miner can collect when starts that row ; Gold collected on going to the cell on the right ( -> ) ; Gold collected on going to the cell to right up ( / ) ; Gold collected on going to the cell to right down ( \ ) ; Max gold collected from taking either of the above 3 paths ; The max amount of gold collected will be the max value in first column of all rows ; Driver Code
",1
75,"create constant integer MAX with MAX assign to 100
create integer getMaxGold ( int gold array of   array of MAX , int m, int n )  int goldTable array of m   array of n  
set all contents of goldtable to 0
untill col assign to n - 1 to 0 inclusive, right assign to int with col assign to n - 1, col assign to 0, col --, right assign to int with col assign to n - 1, goldTable assign to int array of rows of rows and col + 1, 0
set right_up to 0 if row assign to 0 col assign to n - 1 else set goldTable to goldTable array of row - 1   array of col + 1  
set right_down to 0 if row assign to m - 1 col assign to n - 1 else set goldTable to goldTable array of row + 1   array of col + 1  
goldTable array of row   array of col   assign to gold array of row   array of col   + max ( right, max ( right_up, right_down ) )
res assign to goldTable array of 0   array of 0  
untill i assign to 1 to m exclusive, set res to max ( res, goldTable array of i   array of 0   )
return res
declare integer main ( ) and integer array gold with MAX elements, with gold assign to  1, 3, 1, 5 , 2, 4, 1 , 5, 0, 2, 3 , 6, 1, 2        0
create integers m, n with m assign to 4 and n assign to 4
print getMaxGold ( gold, m, n )
return 0
","Frequency Measuring Techniques untill Competitive Programming 
 C ++ program to count frequencies of array items ; Create an array to store counts . The size of array is limit + 1 and all values are initially 0 ; Traverse through string characters and count frequencies ; Driver Code
",0
76,"declare minAdjustmentCost with integers A, n, target as arguments, returning integer, returning integer, dp, M + 1
untill j assign to 0 to M inclusive, set dp array of 0   array of j   to abs ( j - A array of 0   )
untill i assign to 1 to n exclusive, set j to 0 and j assign to M, set dp array of i   array of j   to INT_MAX
untill k assign to max ( j - target, 0 ) ; k assign to min ( M, j + target ) ; k ++ ) dp array of i   array of j   assign to min ( dp array of i   array of j  , dp array of i - 1   array of k   + abs ( A array of i   - j ) ) ) ;
res assign to integer with res assign to INT_MAX
untill j assign to 0 to M inclusive, set res to min ( res, dp array of n - 1   array of j   )
return res
declare integer main ( ) and integer array arr with size   assign to  55, 77, 52, 61, 39, 6, 25, 60, 49, 47
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create integer target with target assign to 10
print "" Minimum adjustment cost is "" print minAdjustmentCost ( arr, n, target) print newline
return 0
","Find minimum adjustment cost of an array 
 C ++ program to find minimum adjustment cost of an array ; Function to find minimum adjustment cost of an array ; dp array of i   array of j   stores minimal adjustment cost on changing A array of i   to j ; handle first element of array separately ; do untill rest elements of the array ; replace A array of i   to j and calculate minimal adjustment cost dp array of i   array of j   ; initialize minimal adjustment cost to INT_MAX ; consider all k such that k >assign to max ( j - target , 0 ) and k <assign to min ( M , j + target ) and take minimum ; return minimum value from last row of dp table ; Driver Program to test above functions
",1
77,"declare minAdjustmentCost with integers A, n, target as arguments, returning integer, returning integer, dp, M + 1
untill j assign to 0 to M inclusive, set dp array of 0   array of j   to abs ( j - A array of 0   )
untill i assign to 1 to n exclusive, set j to 0 and j assign to M, set dp array of i   array of j   to INT_MAX
untill k assign to max ( j - target, 0 ) ; k assign to min ( M, j + target ) ; k ++ ) dp array of i   array of j   assign to min ( dp array of i   array of j  , dp array of i - 1   array of k   + abs ( A array of i   - j ) ) ) ;
res assign to integer with res assign to INT_MAX
untill j assign to 0 to M inclusive, set res to min ( res, dp array of n - 1   array of j   )
return res
declare integer main ( ) and integer array arr with size   assign to  55, 77, 52, 61, 39, 6, 25, 60, 49, 47
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create integer target with target assign to 10
print "" Minimum adjustment cost is "" print minAdjustmentCost ( arr, n, target) print newline
return 0
","Maximize number of days untill which P chocolates can be distributed consecutively to N people 
 C ++ program to implement the above approach ; Stores the frequency of each type of chocolate ; Function to check if chocolates can be eaten untill ' mid ' no . of days ; If cnt exceeds N , return true ; Function to find the maximum number of days untill which chocolates can be eaten ; Store the frequency of each type of chocolate ; Initialize start and end with 0 and P respectively ; Calculate mid ; Check if chocolates can be distributed untill mid days ; Check if chocolates can be distributed untill more than mid consecutive days ; Driver code ; Function call
",0
78,"declare totalCombination with integer L, R as arguments, assign 0 to integer count
create integer K with K assign to R - L
if K is less than L, return 0
ans assign to integer with ans assign to K - L
count assign to ( ( ans + 1 ) * ( ans + 2 ) ) / 2
return count
declare integer main ( ), L assign to 2 and R assign to 6
print totalCombination ( L, R )
return 0
","Count triplets from a given range having sum of two numbers of a triplet equal to the third number 
 C ++ program untill the above approach ; Function to find the number of triplets from the range array of L , R   having sum of two numbers from the triplet equal to the third number ; Stores the total number of triplets ; Find the difference of the range ; Case 1 : If triplets can 't  be untillmed, then return 0 ; Otherwise ; Update the total number of triplets ; Return the count ; Driver Code
",1
79,"declare totalCombination with integer L, R as arguments, assign 0 to integer count
create integer K with K assign to R - L
if K is less than L, return 0
ans assign to integer with ans assign to K - L
count assign to ( ( ans + 1 ) * ( ans + 2 ) ) / 2
return count
declare integer main ( ), L assign to 2 and R assign to 6
print totalCombination ( L, R )
return 0
","Count distinct pairs with given sum 
 C ++ program to implement the above approach ; Function to count distinct pairs in array whose sum equal to K ; Stores count of distinct pairs whose sum equal to K ; Sort the array ; Stores index of the left pointer ; Stores index of the right pointer ; Calculate count of distinct pairs whose sum equal to K ; If sum of current pair is equal to K ; Remove consecutive duplicate array elements ; Update i ; Remove consecutive duplicate array elements ; Update j ; Update cntPairs ; Update i ; Update j ; if sum of current pair less than K ; Update i ; Update j ; Driver Code
",0
80,"printArrays is a void function with integer arguments n and B
untill i assign to 1 to 2 * n inclusive, push_back A.
else B. push_back ( i )
print ""  ""
untill i assign to 0 to n exclusive, print A array of i  
if i is not n - 1, print "", ""
print ""  STRNEWLINE ""
print ""  ""
untill i assign to 0 to n exclusive, print B array of i  
if i is not n - 1, print "", ""
print ""  ""
declare integer main ( ) and integer N assign to 5
printArrays ( N )
return 0
","Construct two N 
 C ++ program untill the above approach ; Function to generate two arrays satisfying the given conditions ; Declare the two arrays A and B ; Iterate from range array of 1 , 2 * n   ; Assign consecutive numbers to same indices of the two arrays ; Print the first array ; Print the second array , B ; Driver Code ; Function Call
",1
81,"printArrays is a void function with integer arguments n and B
untill i assign to 1 to 2 * n inclusive, push_back A.
else B. push_back ( i )
print ""  ""
untill i assign to 0 to n exclusive, print A array of i  
if i is not n - 1, print "", ""
print ""  STRNEWLINE ""
print ""  ""
untill i assign to 0 to n exclusive, print B array of i  
if i is not n - 1, print "", ""
print ""  ""
declare integer main ( ) and integer N assign to 5
printArrays ( N )
return 0
","Add two numbers without using arithmetic operators 
 C ++ Program to add two numbers without using arithmetic operator ; Iterate till there is no carry ; carry now contains common set bits of x and y ; Sum of bits of x and y where at least one of the bits is not set ; Carry is shifted by one so that adding it to x gives the required sum ; Driver code
",0
82,"untill i assign to 0 to 32 exclusive, if A & ( 1  i ) ) && ( B & ( 1  i ) ), A assign to A  ( 1  i ),
B assign to B  ( 1  i )
print A, "" "" and B
declare integer main ( ), integers A assign to 7 and B assign to 4
flipBitsOfAandB ( A, B )
return 0
","Numbers untillmed by flipping common set bits in two given integers 
 C ++ program to implement the above approach ; Function to flip bits of A and B which are set bits in A and B ; Iterater all possible bits of A and B ; If ith bit is set in both A and B ; Clear i - th bit of A ; Clear i - th bit of B ; Print A and B ; Driver Code
",1
83,"untill i assign to 0 to 32 exclusive, if A & ( 1  i ) ) && ( B & ( 1  i ) ), A assign to A  ( 1  i ),
B assign to B  ( 1  i )
print A, "" "" and B
declare integer main ( ), integers A assign to 7 and B assign to 4
flipBitsOfAandB ( A, B )
return 0
","Recursive Bubble Sort 
 C / C ++ program untill recursive implementation of Bubble sort ; A function to implement bubble sort ; Base case ; One pass of bubble sort . After this pass , the largest element is moved ( or bubbled ) to end . ; swap arr array of i   , arr array of i + 1   ; Largest element is fixed , recur untill remaining array ; Function to print an array ; Driver program to test above functions
",0
84,"declare findDistinctSums with integer N as argument, returning 2 * N - 1
declare integer main ( ) and integer N assign to 3
print findDistinctSums ( N)
return 0
","Count of distinct pair sum between two 1 to N value Arrays 
 C ++ implementation to find count of distinct pair sum between two 1 to N value Arrays ; Function to find the distinct sums ; Driver code
",1
85,"declare findDistinctSums with integer N as argument, returning 2 * N - 1
declare integer main ( ) and integer N assign to 3
print findDistinctSums ( N)
return 0
","Check divisibility of binary string by 2 to the power k 
 C ++ implementation to check whether given binary number is evenly divisible by 2 to the power k or not ; function to check whether given binary number is evenly divisible by 2 to the power k or not ; count of number of 0 from last ; if count assign to k , number is evenly divisible , so returns true else false ; Driver program to test above ; first example ; Second example
",0
86,"declare integer array countSubstrings with string & str, integer freq assign to 0 and integer freq assign to 0
create integer count with count assign to 0
create integer i with i assign to 0
untill j assign to 0 to length of str ( ) exclusive, increment freq array of str array ofj  - '0'  
untill freq array of 0   > 0 and freq array of 1   > 0 and freq array of 2   > 0, freq array of str array of i ++   - '0'   --
increment count by i
return count
declare integer main ( ), string str assign to ""00021""
count assign to integer with countSubstrings ( str)
print count
return 0
","Count of substrings from given Ternary strings containing characters at least once 
 C ++ program untill above approach ; Function to count the number of substrings consists of 0 , 1 , and 2 ; Initialize frequency array of size 3 ; Stores the resultant count ; Traversing string str ; Update frequency array ; If all the characters are present counting number of substrings possible ; Update number of substrings ; Return the number of substrings ; Driver Code
",1
87,"declare integer array countSubstrings with string & str, integer freq assign to 0 and integer freq assign to 0
create integer count with count assign to 0
create integer i with i assign to 0
untill j assign to 0 to length of str ( ) exclusive, increment freq array of str array ofj  - '0'  
untill freq array of 0   > 0 and freq array of 1   > 0 and freq array of 2   > 0, freq array of str array of i ++   - '0'   --
increment count by i
return count
declare integer main ( ), string str assign to ""00021""
count assign to integer with countSubstrings ( str)
print count
return 0
","Count of ways to split N into Triplets untillming a Triangle 
 C ++ Program to implement the above approach ; Function to return the required number of ways ; Check if a , b and c can untillm a triangle ; Return number of ways ; Driver Code
",0
88,"declare integer variable minFlips with string str as argument, assign 0 to integer count
if str. size ( ) assign to 2 return 0
untill i assign to 0 to size of str - 2 exclusive, if str array of i   assign to str array of i + 1   and str array of i + 2   assign to str array of i + 1  , i assign to i + 3
increment count
else increment i
return count
declare integer main ( ) and string S assign to ""0011101""
print minFlips ( S)
return 0
","Minimum flips to remove any consecutive 3 0 s or 1 s in given Binary string 
 C ++ program untill the above approach ; Function to find the minimum number of flips to make all three pairs of consecutive characters different ; Stores resultant count of pairs ; Base Case ; Iterate over the range array of 0 , N - 2   ; If the consecutive 3 numbers are the same then increment the count and the counter ; Return the answer ; Driver Code
",1
89,"declare integer variable minFlips with string str as argument, assign 0 to integer count
if str. size ( ) assign to 2 return 0
untill i assign to 0 to size of str - 2 exclusive, if str array of i   assign to str array of i + 1   and str array of i + 2   assign to str array of i + 1  , i assign to i + 3
increment count
else increment i
return count
declare integer main ( ) and string S assign to ""0011101""
print minFlips ( S)
return 0
","Print bitwise AND set of a number N 
 CPP program to print all bitwise subsets of N ( Naive approach ) ; function to find bitwise subsets Naive approach ; Driver Code
",0
90,"convertToHex assign to string with integer num, temp assign to "" ""
untill num is not 0, set rem to num modulo 16
create character c
if rem is less than 10 then set c to rem + 48
else c assign to rem + 87
increment temp by c
set num to num / 16
return temp
create string encryptString ( string S, integer N), ans with ans assign to "" ""
untill i assign to 0 to N exclusive, ch assign to S array of i  
create integer count with count assign to 0
create string hex
untill i  N and S array of i   assign to ch, increment count
increment i
decrement i
set hex to convertToHex ( count )
increment ans by ch
increment ans by hex
reverse ans. begin ( ), ans. end ( ) )
return ans
declare integer main ( ) and string S assign to "" abc ""
create integer N with N assign to size of S
print encryptString ( S, N )
return 0
","Encrypt the string 
 C ++ program untill the above approach ; Function to convert Decimal to Hex ; Function to encrypt the string ; Iterate the characters of the string ; Iterate until S array of i   is equal to ch ; Update count and i ; Decrement i by 1 ; Convert count to hexadecimal representation ; Append the character ; Append the characters frequency in hexadecimal representation ; Reverse the obtained answer ; Return required answer ; Driver Code ; Given Input ; Function Call
",1
91,"convertToHex assign to string with integer num, temp assign to "" ""
untill num is not 0, set rem to num modulo 16
create character c
if rem is less than 10 then set c to rem + 48
else c assign to rem + 87
increment temp by c
set num to num / 16
return temp
create string encryptString ( string S, integer N), ans with ans assign to "" ""
untill i assign to 0 to N exclusive, ch assign to S array of i  
create integer count with count assign to 0
create string hex
untill i  N and S array of i   assign to ch, increment count
increment i
decrement i
set hex to convertToHex ( count )
increment ans by ch
increment ans by hex
reverse ans. begin ( ), ans. end ( ) )
return ans
declare integer main ( ) and string S assign to "" abc ""
create integer N with N assign to size of S
print encryptString ( S, N )
return 0
","Check if the remainder of N 
 C ++ implementation to check the following expression untill an integer N is valid or not ; Function to check if a number holds the condition ( N - 1 ) ! % N assign to N - 1 ; Corner cases ; Number divisible by 2 or 3 are not prime ; Iterate from 5 and keep checking untill prime ; Function to check the expression untill the value N ; Driver Program
",0
92,"declare binomialCoeff with unsigned long integers n, k as arguments, returning unsigned long integer res assign to 1
if k is greater than n - k, set k to n - k
untill i assign to 0 to k exclusive, res assign to res * ( n - i )
res assign to res / ( i + 1 )
return res
declare unsigned long integer countOfString ( integer N) and Stotal assign to pow ( 2, N )
create unsigned long integer Sequal with Sequal assign to 0
if N modulo 2 is 0, Sequal assign to binomialCoeff ( N, N / 2)
create unsigned long integer S1 with S1 assign to ( Stotal - Sequal ) / 2
return S1
declare integer main ( ) and integer N assign to 3
print countOfString ( N)
return 0
","Count of Binary Strings of length N such that frequency of 1 ' s â– exceeds â– frequency â– of â– 0' s 
 C ++ Program to implement the above approach ; Function to calculate and return the value of Binomial Coefficient C ( n , k ) ; Since C ( n , k ) assign to C ( n , n - k ) ; Calculate the value of array of n * ( n - 1 ) * -- - * ( n - k + 1 )   / array of k * ( k - 1 ) * -- - * 1   ; Function to return the count of binary strings of length N such that frequency of 1 ' s â– exceed â– that â– of â– 0' s ; Count of N - length binary strings ; Count of N - length binary strings having equal count of 0 ' s â– and â– 1' s ; For even length strings ; Driver Code
",1
93,"declare binomialCoeff with unsigned long integers n, k as arguments, returning unsigned long integer res assign to 1
if k is greater than n - k, set k to n - k
untill i assign to 0 to k exclusive, res assign to res * ( n - i )
res assign to res / ( i + 1 )
return res
declare unsigned long integer countOfString ( integer N) and Stotal assign to pow ( 2, N )
create unsigned long integer Sequal with Sequal assign to 0
if N modulo 2 is 0, Sequal assign to binomialCoeff ( N, N / 2)
create unsigned long integer S1 with S1 assign to ( Stotal - Sequal ) / 2
return S1
declare integer main ( ) and integer N assign to 3
print countOfString ( N)
return 0
","Find all elements in array which have at 
 Simple C ++ program to find all elements in array which have at - least two greater elements itself . ; Pick elements one by one and count greater elements . If count is more than 2 , print that element . ; Driver code
",0
94,"if str, length of str ( ) is 0, return "" ""
if str array of0  is X return removeCharRecursive ( str. substr ( 1 ), X )
return str array of 0   + removeCharRecursive ( str. substr ( 1 ), X )
declare integer main ( ) and string str assign to geeksuntillgeeks
create character X with X assign to'e '
set str to removeCharRecursive ( str, X )
print str
return 0
","Remove all occurrences of a character in a string 
 Recursive approach 
 C ++ program untill the above approach ; Function to remove all occurrences of a character in the string ; Base Case ; Check the first character of the given string ; Pass the rest of the string to recursion Function call ; Add the first character of str and string from recursion ; Driver Code ; Given String ; Given character ; Function Call
",1
95,"if str, length of str ( ) is 0, return "" ""
if str array of0  is X return removeCharRecursive ( str. substr ( 1 ), X )
return str array of 0   + removeCharRecursive ( str. substr ( 1 ), X )
declare integer main ( ) and string str assign to geeksuntillgeeks
create character X with X assign to'e '
set str to removeCharRecursive ( str, X )
print str
return 0
","Find the missing number in unordered Arithmetic Progression 
 C ++ program untill the above approach ; Function to find the missing element ; Fix left and right boundary untill binary search ; Find index of middle element ; Check if the element just after the middle element is missing ; Check if the element just beuntille mid is missing ; Check if the elements till mid follow the AP , then recur untill right half ; Else recur untill left half ; Function to find the missing element in AP series ; Sort the array arr array of   ; Calculate Common Difference ; Binary search untill the missing ; Driver Code ; Given array arr array of   ; Function Call
",0
96,"declare isValid with chars a1, a2, str, v1, v2 as arguments, returning boolean
if flag is 0, v1 assign to str array of 4  
set v2 to str array of 3  
else v1 assign to str array of 1 
set v2 to str array of 0  
if v1 is not a1 and v1 is not '?' return false
if v2 is not a2 and v2 is not '?' return false
return true
declare boolean inRange (int hh,int mm,int L,int R) and a assign to abs (hh - mm )
if a is less than L a, return false
return true
print displayTime ( hh, mm ) if hh is greater than 10 print hh print "" : ""
else if hh is less than 10 print ""0"" print hh print "" : ""
if mm is greater than 10, print mm
else if mm is less than 10 print ""0"" print mm print newline
void maximumTimeWithDifferenceInRange ( string str, integer L, integer R), integers i, j
create integers h1, h2, m1, m2
untill i assign to 23 to 0 inclusive, set h1 to i modulo 10
set h2 to i / 10
if! isValid ( h1 + '0', h2 + '0', str, 1 ) )
untill j assign to 59 to 0 inclusive, set m1 to j modulo 10
set m2 to j / 10
if! isValid ( m1 + '0', m2 + '0', str, 0 ) ), continue
if displayTime ( i, j, L, R ) is true
return
if displayTime ( i, j, L, R ) is true
else print "" - 1""
declare integer main ( ), string timeValue assign to ""?? :?? ""
let L, R be integers with L assign to 20 and R assign to 39
call maximumTimeWithDifferenceInRange ( timeValue, L, R )
return 0
","Maximum time such that absolute difference between hour and minute lies in given range 
 C ++ program untill the above approach ; Function checks whether given time is correct ; To check minute value of time ; To check hour value of time ; Changes in value is not allowed at position where ' ? ' is not present ; Function checks whether the absolute difference between hour and minute value is within array of L , R   ; Checks if the difference is outside the give range ; Displays time in proper 24 - hour untillmat ; Function find the desired value of time whose difference lies in the range array of L , R   ; Decrease hour value from 23 to 0 ; Check if the hour value is valid if not valid then no need to change minute value , since time will still remain in valid , to check hour value flag is set to 1. ; Decrease minute value from 59 to 0 ; Check if the minute value is valid , if not valid then skip the current iteration , to check ' minute ' value flag is set to 0. ; Driver code ; Input time ; Difference range
",1
97,"declare isValid with chars a1, a2, str, v1, v2 as arguments, returning boolean
if flag is 0, v1 assign to str array of 4  
set v2 to str array of 3  
else v1 assign to str array of 1 
set v2 to str array of 0  
if v1 is not a1 and v1 is not '?' return false
if v2 is not a2 and v2 is not '?' return false
return true
declare boolean inRange (int hh,int mm,int L,int R) and a assign to abs (hh - mm )
if a is less than L a, return false
return true
print displayTime ( hh, mm ) if hh is greater than 10 print hh print "" : ""
else if hh is less than 10 print ""0"" print hh print "" : ""
if mm is greater than 10, print mm
else if mm is less than 10 print ""0"" print mm print newline
void maximumTimeWithDifferenceInRange ( string str, integer L, integer R), integers i, j
create integers h1, h2, m1, m2
untill i assign to 23 to 0 inclusive, set h1 to i modulo 10
set h2 to i / 10
if! isValid ( h1 + '0', h2 + '0', str, 1 ) )
untill j assign to 59 to 0 inclusive, set m1 to j modulo 10
set m2 to j / 10
if! isValid ( m1 + '0', m2 + '0', str, 0 ) ), continue
if displayTime ( i, j, L, R ) is true
return
if displayTime ( i, j, L, R ) is true
else print "" - 1""
declare integer main ( ), string timeValue assign to ""?? :?? ""
let L, R be integers with L assign to 20 and R assign to 39
call maximumTimeWithDifferenceInRange ( timeValue, L, R )
return 0
","Count of subarrays of size K which is a permutation of numbers from 1 to K 
 C ++ program to implement the above approach ; Save index of numbers of the array ; Update min and max index with the current index and check if it 's a valid permutation ; Driver code
",0
98,"check assign to boolean function with string arguments s and n, stack assign to char > st
untill i assign to 0 to n exclusive, if st is empty and top ( ) is s array of i  , pop ( )
else push s array of i  
if st. empty ( ) is true, return true
else return false
declare integer main ( ), string str assign to "" aanncddc ""
create integer n with n assign to length of str
if check ( str, n ) is true, print Yes
else print No
return 0
","Check if a string can be split into even length palindromic substrings 
 C ++ program untill the above approach ; Function to check string str can be split a string into even length palindromic substrings ; Initialize a stack ; Iterate the string ; If the i - th character is same as that at the top of the stack then pop the top element ; Else push the current charactor into the stack ; If the stack is empty , then even palindromic substrings are possible ; Else not - possible ; Driver Code ; Given string ; Function Call
",1
99,"check assign to boolean function with string arguments s and n, stack assign to char > st
untill i assign to 0 to n exclusive, if st is empty and top ( ) is s array of i  , pop ( )
else push s array of i  
if st. empty ( ) is true, return true
else return false
declare integer main ( ), string str assign to "" aanncddc ""
create integer n with n assign to length of str
if check ( str, n ) is true, print Yes
else print No
return 0
","Count the number of primes in the prefix sum array of the given array 
 C ++ implementation of the approach ; Function to return the count of primes in the given array ; Find maximum value in the array ; USE SIEVE TO FIND ALL PRIME NUMBERS LESS THAN OR EQUAL TO max_val Create a boolean array "" prime array of 0 . . n   "" . A value in prime array of i   will finally be false if i is Not a prime , else true . ; Remaining part of SIEVE ; If prime array of p   is not changed , then it is a prime ; Update all multiples of p ; Find all primes in arr array of   ; Function to generate the prefix array ; Fill the prefix array ; Driver code ; Prefix array of arr array of   ; Count of primes in the prefix array
",0
100,"declare findNumOfValidWords with vector  string > & w, vector  string > & p, unordered_map with int, int > m
create vector res with int value greater than res
untill string & s : w, val assign to 0
untill char c : s val assign to val 
 ( 1  ( c -'a') )
increment m array of val 
untill string & s : p, val assign to integer with val assign to 0
untill char c : s val assign to val 
 ( 1  ( c -'a') )
temp assign to integer with temp assign to val
create integer first with first assign to s array of 0   -'a'
create integer count with count assign to 0
untill temp is not 0 then increment count by m array of temp 
temp assign to ( temp - 1 ) & val
push_back is a new function
print it and res
declare integer main ( ), vector, string > arr1
arr1 assign to  "" aaa "", "" asas "", "" able "", "" ability "", "" actt "", "" actor "", "" access ""
create vector  string > arr2
arr2 assign to  "" aboveyz "", "" abrodyz "", "" absolute "", "" absoryz "", "" actresz "", "" gaswxyz ""
call findNumOfValidWords ( arr1, arr2 )
return 0
","Number of strings in two array satisfy the given conditions 
 C ++ program untill the above approach ; To store the frequency of string after bitmasking ; To store result untill each string in arr2 array of   ; Traverse the arr1 array of   and bitmask each string in it ; Bitmasking untill each string s ; Update the frequency of string with it 's bitmasking value ; Traverse the arr2 array of   ; Bitmasking untill each string s ; Check if temp is present in an unordered_map or not ; Check untill next set bit ; Push the count untill current string in resultant array ; Print the count untill each string ; Driver Code ; Function call
",1
101,"declare findNumOfValidWords with vector  string > & w, vector  string > & p, unordered_map with int, int > m
create vector res with int value greater than res
untill string & s : w, val assign to 0
untill char c : s val assign to val 
 ( 1  ( c -'a') )
increment m array of val 
untill string & s : p, val assign to integer with val assign to 0
untill char c : s val assign to val 
 ( 1  ( c -'a') )
temp assign to integer with temp assign to val
create integer first with first assign to s array of 0   -'a'
create integer count with count assign to 0
untill temp is not 0 then increment count by m array of temp 
temp assign to ( temp - 1 ) & val
push_back is a new function
print it and res
declare integer main ( ), vector, string > arr1
arr1 assign to  "" aaa "", "" asas "", "" able "", "" ability "", "" actt "", "" actor "", "" access ""
create vector  string > arr2
arr2 assign to  "" aboveyz "", "" abrodyz "", "" absolute "", "" absoryz "", "" actresz "", "" gaswxyz ""
call findNumOfValidWords ( arr1, arr2 )
return 0
","Sum of first n term of Series 3 , 5 , 9 , 17 , 33. ... 
 C ++ program to find sum of first n terms ; Sn assign to n * ( 4 * n * n + 6 * n - 1 ) / 3 ; Driver code ; number of terms to be included in sum ; find the Sn
",0
102,"untill i assign to 0 to length of s, if s array of i   is '0', untill s array of i   is '0', s array of i   is '1'
increment i
break
declare integer main ( ) and string s assign to ""100010001""
flip s
print s
return 0
","Maximize the decimal equivalent by flipping only a contiguous set of 0 s 
 C ++ implementation to Maximize the value of the decimal equivalent given in the binary untillm ; Function to print the binary number ; Check if the current number is 0 ; Find the continuous 0 s ; Replace initially occurring 0 with 1 ; Break out of loop if 1 occurs ; Driver code
",1
103,"untill i assign to 0 to length of s, if s array of i   is '0', untill s array of i   is '0', s array of i   is '1'
increment i
break
declare integer main ( ) and string s assign to ""100010001""
flip s
print s
return 0
","Insert node into the middle of the linked list 
 C ++ implementation to insert node at the middle of the linked list ; structure of a node ; function to create and return a node ; function to insert node at the middle of the linked list ; if list is empty ; get a new node ; calculate length of the linked list , i . e , the number of nodes ; ' count ' the number of nodes after which the new node is to be inserted ; ' ptr ' points to the node after which the new node is to be inserted ; insert the ' newNode ' and adjust the required links ; function to display the linked list ; Driver program to test above ; Creating the list 1 -> 2 -> 4 -> 5
",0
104,"print getOrgString ( string s ) print s array of 0  
create integer i with i assign to 1
untill i is less than length ( ), print "" "" and ( char ) tolower ( s array of i   )
else print s array of i 
increment i
create integer main ( ), s with s assign to "" ILoveGeeksForGeeks ""
getOrgString is a new function
return 0
","Sentence Case of a given Camel cased string 
 C ++ implementation of the approach ; Function to return the original string after converting it back from camelCase ; Print the first character as it is ; Traverse the rest of the characters one by one ; If current character is uppercase print space followed by the current character in lowercase ; Else print the current character ; Driver code
",1
105,"print getOrgString ( string s ) print s array of 0  
create integer i with i assign to 1
untill i is less than length ( ), print "" "" and ( char ) tolower ( s array of i   )
else print s array of i 
increment i
create integer main ( ), s with s assign to "" ILoveGeeksForGeeks ""
getOrgString is a new function
return 0
","Perfect cube greater than a given number 
 C ++ implementation of above approach ; Function to find the next perfect cube ; Driver Code
",0
106,"declare integer variable countChar with string str, x as arguments, changing count to 0 and n to 10
untill i assign to 0 to size of str, increment count by 1 if str array of i   is x
repetitions assign to integer with repetitions assign to n / str. size ( )
set count to count * repetitions
untill i assign to 0 to n % str size ( ), increment i ) if str array of i   is equal to x, increment count
return count
declare integer main ( ), string str assign to "" abcac ""
print countChar ( str,'a')
return 0
","Count occurrences of a character in a repeated string 
 CPP program to find the occurrences of character x in the infinite repeated string upto length n ; Function to count the character ' a ' ; atleast k repetition are required ; if n is not the multiple of the string size check untill the remaining repeating character . ; Driver code
",1
107,"declare integer variable countChar with string str, x as arguments, changing count to 0 and n to 10
untill i assign to 0 to size of str, increment count by 1 if str array of i   is x
repetitions assign to integer with repetitions assign to n / str. size ( )
set count to count * repetitions
untill i assign to 0 to n % str size ( ), increment i ) if str array of i   is equal to x, increment count
return count
declare integer main ( ), string str assign to "" abcac ""
print countChar ( str,'a')
return 0
","Find the two numbers with odd occurrences in an unsorted array 
 C ++ Program to find the two odd occurring elements ; Prints two numbers that occur odd number of times . The function assumes that the array size is at least 2 and there are exactly two numbers occurring odd number of times . ; Create map and calculate frequency of array of * elements using array . ; Traverse through the map and check if its second element that is the frequency is odd or not . Then this is the odd occurring element . Its is clearly mentioned in problem that there are only two odd occurring elements so this will print those two elements . ; Driver code
",0
108,"declare countFreq with integer arr array of  , integer n, integer limit as arguments, returning vector, with integer count assign to count + 1, 0
untill i assign to 0 to n exclusive, increment count array of arr array of i     by 1
untill i assign to 0 to limit inclusive, print i, "" "", count array of i   and a new line
declare integer main ( ) and integer array arr with arr assign to  5, 5, 6, 6, 5, 6, 1, 2, 3, 10, 10  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create integer limit with limit assign to 10
countFreq assign to arr, n, limit
return 0
","Frequency Measuring Techniques untill Competitive Programming 
 C ++ program to count frequencies of array items having small values . ; Create an array to store counts . The size of array is limit + 1 and all values are initially 0 ; Traverse through array elements and count frequencies ( assuming that elements are limited by limit ) ; Driver Code
",1
109,"declare countFreq with integer arr array of  , integer n, integer limit as arguments, returning vector, with integer count assign to count + 1, 0
untill i assign to 0 to n exclusive, increment count array of arr array of i     by 1
untill i assign to 0 to limit inclusive, print i, "" "", count array of i   and a new line
declare integer main ( ) and integer array arr with arr assign to  5, 5, 6, 6, 5, 6, 1, 2, 3, 10, 10  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create integer limit with limit assign to 10
countFreq assign to arr, n, limit
return 0
","Sort a Rotated Sorted Array 
 C ++ implementation untill restoring original sort in rotated sorted array ; Function to restore the Original Sort ; In reverse ( ) , the first parameter is iterator to beginning element and second parameter is iterator to last element plus one . ; Function to print the Array ; Driver function
",0
110,"declare check with string s, integer m, l assign to length of s
c1 assign to integer with c1 assign to 0
create integer c2 with c2 assign to 0
untill i assign to 0 to l exclusive, if s array of i   is '0', set c2 to 0
increment c1
else c1 assign to 0
increment c2
if c1 is m c2 is m, return true
return false
declare integer main ( ), string s assign to ""001001""
create integer m with m assign to 2
if check ( s, m ) is true, print YES
else print NO
return 0
","Check if a string has m consecutive 1 ' s â– or â– 0' s 
 Program to check if the binary string contains m consecutive 1 ' s â– or â– 0' s ; Function that checks if the binary string contains m consecutive 1 ' s â– or â– 0' s ; length of binary string ; counts zeros ; counts 1 's ; count consecutive 0 's ; count consecutive 1 's ; Drivers Code ; function call
",1
111,"declare check with string s, integer m, l assign to length of s
c1 assign to integer with c1 assign to 0
create integer c2 with c2 assign to 0
untill i assign to 0 to l exclusive, if s array of i   is '0', set c2 to 0
increment c1
else c1 assign to 0
increment c2
if c1 is m c2 is m, return true
return false
declare integer main ( ), string s assign to ""001001""
create integer m with m assign to 2
if check ( s, m ) is true, print YES
else print NO
return 0
","Maximum determinant of a matrix with every values either 0 or n 
 C ++ program to find maximum possible determinant of 0 / n matrix . ; Function untill maximum determinant ; Function to print resulatant matrix ; three position where 0 appears ; position where n appears ; Driver code
",0
112,"declare productAtKthLevel with string tree, integer k as arguments, set level to -1
create integer n with n assign to length of tree
untill i assign to 0 to n exclusive, increment i if tree array of i   is equal to ('' ) level ; else if tree array of i   is equal to') ', level is equal to level --
else if level is k, product is equal to ( tree array of i   - '0' )
return product
declare integer main ( ) and string tree assign to "" ( 0(5(6 ( ) ( ) ) ) ) ) ) ( 7(1 ( ) ) ) ( 3 ( ) ) ) ) ) ) ) ""
create integer k with k assign to 2
print productAtKthLevel ( tree, k )
return 0
","Product of nodes at k 
 C ++ implementation to find product of digits of elements at k - th level ; Function to find product of digits of elements at k - th level ; int product assign to 1 ; Initialize result ; increasing level number ; decreasing level number ; check if current level is the desired level or not ; required product ; Driver program
",1
113,"declare productAtKthLevel with string tree, integer k as arguments, set level to -1
create integer n with n assign to length of tree
untill i assign to 0 to n exclusive, increment i if tree array of i   is equal to ('' ) level ; else if tree array of i   is equal to') ', level is equal to level --
else if level is k, product is equal to ( tree array of i   - '0' )
return product
declare integer main ( ) and string tree assign to "" ( 0(5(6 ( ) ( ) ) ) ) ) ) ( 7(1 ( ) ) ) ( 3 ( ) ) ) ) ) ) ) ""
create integer k with k assign to 2
print productAtKthLevel ( tree, k )
return 0
","Area of a Circular Sector 
 C ++ program to find Area of a Sector ; Calculating area of the sector ; Driver code
",0
114,"declare findDuplciates with string a array of  , integer n, integer m, and isPresent array of n   array of m   as arguments, returning boolean
set all contents of isPresent to 0
untill i assign to 0 to n exclusive, set k to 0 and k  n exclusive, incrementing k, if a array of i   array of j   is a array of k   array of j   and i is not k, set isPresent array of i   array of j   to true
set isPresent array of k   array of j   to true
untill k assign to 0 to m exclusive, if a array of i   array of j   assign to a array of i   array of k   and jnot equal to k, set isPresent array of i   array of j   to true
set isPresent array of i   array of k   to true
if i assign to 0, i  n, i ++, printf ( "" % c "", a array of i   array of j   ) is true
declare integer main ( ), integers n assign to 2 and m assign to 5
a assign to string array of size, xz assign to string with a assign to  "" zx "", "" xz ""
call findDuplciates ( a, n, m )
return 0
","Removing row or column wise duplicates from matrix of characters 
 CPP code to untillm string after removing duplicates from rows and columns . ; Function to check duplicates in row and column ; Create an array isPresent and initialize all entries of it as false . The value of isPresent array of i   array of j   is going to be true if s array of i   array of j   is present in its row or column . ; Checking every row untill duplicates of a array of i   array of j   ; Checking every column untill duplicate characters ; If the character is unique in its row and column ; Driver code ; character array ; Calling function
",1
115,"declare findDuplciates with string a array of  , integer n, integer m, and isPresent array of n   array of m   as arguments, returning boolean
set all contents of isPresent to 0
untill i assign to 0 to n exclusive, set k to 0 and k  n exclusive, incrementing k, if a array of i   array of j   is a array of k   array of j   and i is not k, set isPresent array of i   array of j   to true
set isPresent array of k   array of j   to true
untill k assign to 0 to m exclusive, if a array of i   array of j   assign to a array of i   array of k   and jnot equal to k, set isPresent array of i   array of j   to true
set isPresent array of i   array of k   to true
if i assign to 0, i  n, i ++, printf ( "" % c "", a array of i   array of j   ) is true
declare integer main ( ), integers n assign to 2 and m assign to 5
a assign to string array of size, xz assign to string with a assign to  "" zx "", "" xz ""
call findDuplciates ( a, n, m )
return 0
","Invert the Kth most significant bit of N 
 C ++ implementation of the approach ; Function to convert decimal number n to its binary representation stored as an array arr array of   ; Function to convert the number represented as a binary array arr array of   into its decimal equivalent ; Function to return the updated integer after flipping the kth bit ; Number of bits in n ; Find the binary representation of n ; The number of bits in n are less than k ; Flip the kth bit ; Return the decimal equivalent of the number ; Driver code
",0
116,"create boolean isValidISBN ( string & isbn )  integer n assign to isbn. length ( )
if n is not 10 return false
create integer sum with sum assign to 0
untill i assign to 0 to 9 exclusive, digit assign to isbn array of i   - '0'
if 0 is greater than digit 9  digit, return false
increment sum by (digit * ( 10 - i ) ) )
let last be a character with last assign to isbn array of 9 
if last is not 'X' and ( last  '0' last is greater than '9' ) return false
increment sum by 10 if last is'X' else 10 if last - '0'
return sum % 11 assign to 0
declare integer main ( ) and string isbn assign to ""007462542X ""
if isValidISBN ( isbn ) ), print Valid
else print Invalid
return 0
","Program to check untill ISBN 
 CPP program to check if a given ISBN is valid or not ; length must be 10 ; Computing weighted sum of first 9 digits ; Checking last digit . ; If last digit is ' X ' , add 10 to sum , else add its value . ; Return true if weighted sum of digits is divisible by 11. ; Driver code
",1
117,"create boolean isValidISBN ( string & isbn )  integer n assign to isbn. length ( )
if n is not 10 return false
create integer sum with sum assign to 0
untill i assign to 0 to 9 exclusive, digit assign to isbn array of i   - '0'
if 0 is greater than digit 9  digit, return false
increment sum by (digit * ( 10 - i ) ) )
let last be a character with last assign to isbn array of 9 
if last is not 'X' and ( last  '0' last is greater than '9' ) return false
increment sum by 10 if last is'X' else 10 if last - '0'
return sum % 11 assign to 0
declare integer main ( ) and string isbn assign to ""007462542X ""
if isValidISBN ( isbn ) ), print Valid
else print Invalid
return 0
","Largest Square in a Binary Matrix with at most K 1 s untill multiple Queries 
 C ++ implementation to find the largest square in the matrix such that it contains atmost K 1 's ; Function to find the largest square in the matrix such that it contains atmost K 1 's ; Precomputing the countDP prefix sum of the matrix ; Loop to solve Queries ; Calculating the maximum possible distance of the centre from edge ; Calculating the number of 1 s in the submatrix ; Driver Code
",0
118,"declare isVowel with character c as argument, returning c assign to'a'c assign to'A'c assign to'A'c assign to'E'c assign to'I'c assign to'o'c assign to'O'c assign to'u'c assign to'U')
j assign to integer with j assign to 0
declare string vowel
untill i assign to 0 to'0' if str array of i   is not'0', vowel array of j ++   assign to str array of i  
untill i assign to 0 to'0' if str array of i  not equal to'0', str array of i   assign to vowel array of -- j  
return str
declare integer main ( ) and string str assign to "" hello world ""
print reverseVowel ( str)
return 0
","Reverse vowels in a given string 
 C ++ program to reverse order of vowels ; utility function to check untill vowel ; Function to reverse order of vowels ; Storing the vowels separately ; Placing the vowels in the reverse order in the string ; Driver function
",1
119,"declare isVowel with character c as argument, returning c assign to'a'c assign to'A'c assign to'A'c assign to'E'c assign to'I'c assign to'o'c assign to'O'c assign to'u'c assign to'U')
j assign to integer with j assign to 0
declare string vowel
untill i assign to 0 to'0' if str array of i   is not'0', vowel array of j ++   assign to str array of i  
untill i assign to 0 to'0' if str array of i  not equal to'0', str array of i   assign to vowel array of -- j  
return str
declare integer main ( ) and string str assign to "" hello world ""
print reverseVowel ( str)
return 0
","Given an array A array of   and a number x , check untill pair in A array of   with sum as x 
 Set 2 
 C ++ program untill the above approach ; Function to check if the array has 2 elements whose sum is equal to the given value ; Sort the array in increasing order ; Traverse the array , nums array of   ; Store the required number to be found ; Peruntillm binary search ; Store the mid value ; If nums array of mid   is greater than x , then update high to mid - 1 ; If nums array of mid   is less than x , then update low to mid + 1 ; Otherwise ; If mid is equal i , check mid - 1 and mid + 1 ; Otherwise , print the pair and return ; If no such pair is found , then print - 1 ; Driver Code ; Function Call
",0
120,"firstLetterWord assign to string str, result assign to string with result assign to "" ""
v assign to bool with v assign to true
untill i assign to 0 to length of str ( ), if str array of i   is'', v assign to true
else if str array of i   is not'' and v is true, push_back ( str array of i   )
set v to false
return result
declare integer main ( ) and string str assign to geeks untill geeks
print firstLetterWord ( str)
return 0
","String containing first letter of every word in a given string with spaces 
 C ++ program to find the string which contain the first character of each word of another string . ; Function to find string which has first character of each word . ; Traverse the string . ; If it is space , set v as true . ; Else check if v is true or not . If true , copy character in output string and set v as false . ; Driver cpde
",1
121,"firstLetterWord assign to string str, result assign to string with result assign to "" ""
v assign to bool with v assign to true
untill i assign to 0 to length of str ( ), if str array of i   is'', v assign to true
else if str array of i   is not'' and v is true, push_back ( str array of i   )
set v to false
return result
declare integer main ( ) and string str assign to geeks untill geeks
print firstLetterWord ( str)
return 0
","Sort the given matrix 
 C ++ implementation to sort the given matrix ; function to sort the given matrix ; temporary matrix of size n to the power 2 ; copy the elements of matrix one by one into temp array of   ; sort temp array of   ; copy the elements of temp array of   one by one in mat array of   array of   ; function to print the given matrix ; Driver program to test above
",0
122,"declare void dfs ( integers i, j, vector  vector  grid > > > & grid, vector  vector  bool > > > & vis, integer z, integer z_count )  integer n assign to grid. size ( ), m assign to grid array of 0  . size ( ) )
set vis array of i   array of j   to 1
if grid array of i   array of j   is 0, increment z
if grid array of i   array of j   is 2, increment ans by 1 if z is z_count
vis array of i   array of j   assign to 0
return
if i >assign to 1 and vis array of i - 1  array of j   and grid array of i - 1   array of j  not equal to -1 ), dfs ( i - 1, j, grid, vis, ans, z, z_count )
if i is less than n - 1 and vis array of i + 1   array of j   and grid array of i + 1   array of j   is not -1, let dfs ( i + 1, j, grid, vis, ans, z, z_count )
if j >assign to 1 and vis array of i   array of j - 1   and grid array of i   array of j - 1  not equal to -1 ), dfs ( i, j - 1, grid, vis, ans, z, z_count )
if j  m - 1 and vis array of i   array of j + 1   and grid array of i   array of j + 1  not equal to -1, dfs ( i, j + 1, grid, vis, ans, z, z_count )
vis array of i   array of j   assign to 0
create uniquePaths ( vector  vector  int > > & grid ), n assign to grid. size ( ), m assign to grid array of 0  . size ( ) )
ans assign to integer with ans assign to 0
create vector  vector  bool > vis ( n, vector  bool > ( m, 0 ) ) )
create integers x, y
untill i assign to 0 to n exclusive, increment i by 1 if grid array of i   array of j   is 0, increment z_count
else if grid array of i   array of j   is 1, x assign to i, y assign to j
x, y, grid, vis, ans, 0 and z_count assign to dfs
return ans
declare integer main ( ), vector, vector, vector  grid   1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
print uniquePaths ( grid)
return 0
","Unique paths covering every non 
 C ++ implementation of the approach ; Function untill dfs . i , j equal to > Current cell indexes vis equal to > To mark visited cells ans equal to > Result z equal to > Current count 0 s visited z_count equal to > Total 0 s present ; Mark the block as visited ; update the count ; If end block reached ; If path covered all the non - obstacle blocks ; Up ; Down ; Left ; Right ; Unmark the block ( unvisited ) ; Function to return the count of the unique paths ; int z_count assign to 0 ; Total 0 s present ; Count non - obstacle blocks ; Starting position ; Driver code
",1
123,"declare void dfs ( integers i, j, vector  vector  grid > > > & grid, vector  vector  bool > > > & vis, integer z, integer z_count )  integer n assign to grid. size ( ), m assign to grid array of 0  . size ( ) )
set vis array of i   array of j   to 1
if grid array of i   array of j   is 0, increment z
if grid array of i   array of j   is 2, increment ans by 1 if z is z_count
vis array of i   array of j   assign to 0
return
if i >assign to 1 and vis array of i - 1  array of j   and grid array of i - 1   array of j  not equal to -1 ), dfs ( i - 1, j, grid, vis, ans, z, z_count )
if i is less than n - 1 and vis array of i + 1   array of j   and grid array of i + 1   array of j   is not -1, let dfs ( i + 1, j, grid, vis, ans, z, z_count )
if j >assign to 1 and vis array of i   array of j - 1   and grid array of i   array of j - 1  not equal to -1 ), dfs ( i, j - 1, grid, vis, ans, z, z_count )
if j  m - 1 and vis array of i   array of j + 1   and grid array of i   array of j + 1  not equal to -1, dfs ( i, j + 1, grid, vis, ans, z, z_count )
vis array of i   array of j   assign to 0
create uniquePaths ( vector  vector  int > > & grid ), n assign to grid. size ( ), m assign to grid array of 0  . size ( ) )
ans assign to integer with ans assign to 0
create vector  vector  bool > vis ( n, vector  bool > ( m, 0 ) ) )
create integers x, y
untill i assign to 0 to n exclusive, increment i by 1 if grid array of i   array of j   is 0, increment z_count
else if grid array of i   array of j   is 1, x assign to i, y assign to j
x, y, grid, vis, ans, 0 and z_count assign to dfs
return ans
declare integer main ( ), vector, vector, vector  grid   1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
print uniquePaths ( grid)
return 0
","Minimum given operations required to convert a given binary string to all 1 's 
 C ++ implementation of the approach ; Function to return the number of operations required ; ctr will store the number of consecutive ones at the end of the given binary string ; Loop to find number of 1 s at the end of the string ; If the current character is 1 ; If we encounter the first 0 from the LSB position then we 'll break the loop ; Number of operations required is ( l - ctr ) ; Function to remove leading zeroes from the string ; Loop until s array of i   becomes not equal to 1 ; If we reach the end of the string , it means that string contains only 0 's ; Return the string without leading zeros ; Driver code ; Removing the leading zeroes
",0
124,"declare integer numPairs ( integer a array of  , integer n )  integers ans, i, index
set ans to 0
untill i assign to 0 to n exclusive, set a array of i   to abs ( a array of i   )
sort a by n
untill i assign to 0 to n exclusive, index assign to upper_bound ( a, a + n, 2 * a array of i   ) - a )
increment ans by index - i - 1
return ans
declare integer main ( ), integer array a with size   assign to  3, 6
create integer n with n assign to sizeof ( a ) / sizeof ( a array of 0   )
print numPairs ( a, n )
return 0
","Count of unordered pairs ( x , y ) of Array which satisfy given equation 
 C ++ Program to find the number of unordered pairs ( x , y ) which satisfy the given equation untill the array ; Return the number of unordered pairs satisfying the conditions ; ans stores the number of unordered pairs ; Making each value of array to positive ; Sort the array ; For each index calculating the right boundary untill the unordered pairs ; Return the final result ; Driver code
",1
125,"declare integer numPairs ( integer a array of  , integer n )  integers ans, i, index
set ans to 0
untill i assign to 0 to n exclusive, set a array of i   to abs ( a array of i   )
sort a by n
untill i assign to 0 to n exclusive, index assign to upper_bound ( a, a + n, 2 * a array of i   ) - a )
increment ans by index - i - 1
return ans
declare integer main ( ), integer array a with size   assign to  3, 6
create integer n with n assign to sizeof ( a ) / sizeof ( a array of 0   )
print numPairs ( a, n )
return 0
","Highest power of 2 less than or equal to given number 
 C ++ program to find highest power of 2 smaller than or equal to n . ; Driver code
",0
126,"declare areaOfSquare with integer S as argument, returning integer, set area to S * S
return area
declare integer main ( ) and integer S assign to 5
print areaOfSquare ( S)
return 0
","Area of a Square 
 Using Side , Diagonal and Perimeter 
 C ++ program untill the above approach ; Function to find the area of a square ; Use above untillmula ; Driver Code ; Given Side of square ; Function call
",1
127,"declare areaOfSquare with integer S as argument, returning integer, set area to S * S
return area
declare integer main ( ) and integer S assign to 5
print areaOfSquare ( S)
return 0
","Program to find whether a no is power of two 
  ; Function to check if x is power of 2 ; Driver code
",0
128,"declare maxPointOfIntersection with integers x, y, k assign to y * ( y - 1 ) / 2 as arguments, returning integer
k assign to k + x * ( 2 * y + x - 1)
return k
declare integer main ( ) and integer x assign to 3
create integer y with y assign to 4
print maxPointOfIntersection ( x, y ) )
","Maximum points of intersections possible among X circles and Y straight lines 
 C ++ program to implement the above approach ; Driver code ; Number of circles ; Number of straight lines ; Function Call
",1
129,"declare maxPointOfIntersection with integers x, y, k assign to y * ( y - 1 ) / 2 as arguments, returning integer
k assign to k + x * ( 2 * y + x - 1)
return k
declare integer main ( ) and integer x assign to 3
create integer y with y assign to 4
print maxPointOfIntersection ( x, y ) )
","Search an Element in Doubly Circular Linked List 
 C ++ program to illustrate inserting a Node in a Cicular Doubly Linked list in begging , end and middle ; Structure of a Node ; Function to insert a node at the end ; If the list is empty , create a single node circular and doubly list ; Find last node ; Create Node dynamically ; Start is going to be next of new_node ; Make new node previous of start ; Make last preivous of new node ; Make new node next of old last ; Function to display the circular doubly linked list ; Function to search the particular element from the list ; Declare the temp variable ; Declare other control variable untill the searching ; If start is NULL return - 1 ; Move the temp pointer until , temp -> next doesn 't move  start address (Circular Fashion) ; Increment count untill location ; If it is found raise the flag and break the loop ; Increment temp pointer ; Check whether last element in the list content the value if contain , raise a flag and increment count ; If flag is true , then element found , else not ; Driver code ; Start with the empty list ; Insert 4. So linked list becomes 4 -> NULL ; Insert 5. So linked list becomes 4 -> 5 ; Insert 7. So linked list becomes 4 -> 5 -> 7 ; Insert 8. So linked list becomes 4 -> 5 -> 7 -> 8 ; Insert 6. So linked list becomes 4 -> 5 -> 7 -> 8 -> 6
",0
130,"declare Icosihenagonal_num as integer, returning 19 * n * n - 17 * n / 2
declare integer main ( ) and integer n assign to 3
print Icosihenagonal_num ( n )
set n to 10
print Icosihenagonal_num ( n )
return 0
","Icosihenagonal Number 
 C ++ program to find nth Icosihenagonal number ; Function to find Icosihenagonal number ; Formula to calculate nth Icosihenagonal number ; Driver Code
",1
131,"declare Icosihenagonal_num as integer, returning 19 * n * n - 17 * n / 2
declare integer main ( ) and integer n assign to 3
print Icosihenagonal_num ( n )
set n to 10
print Icosihenagonal_num ( n )
return 0
","Subtract two numbers without using arithmetic operators 
 C ++ program to Subtract two numbers without using arithmetic operators ; Iterate till there is no carry ; borrow contains common set bits of y and unset bits of x ; Subtraction of bits of x and y where at least one of the bits is not set ; Borrow is shifted by one so that subtracting it from x gives the required sum ; Driver Code
",0
132,"pair  double, double > find_Centroid ( vector  pair  double, double > > > & v ) pair  double, double > ans assign to  0, 0
create integer n with n assign to size of v
signArea assign to double with signArea assign to 0
untill i assign to 0 to size of v exclusive, double x0 assign to v array of i . first, y0 assign to v array of i  . second
x1 assign to double with x1 assign to v array of ( i + 1 ) % n  . first, y1 assign to v array of ( i + 1 ) % n  . second
declare double A assign to ( x0 * y1 ) - ( x1 * y0 ) )
add A to signedArea
increment ans by ( x0 + x1 ) * A
increment ans by ( y0 + y1 ) * A
signedArea * 0.5
set ans. first to ( ans. first ) / ( 6 * signedArea )
ans. second assign to ( ans. second ) / ( 6 * signedArea )
return ans
declare integer main, vector, pair, double, double > > vp assign to   1, 2 , 3, -4 , 6, -7
pair  double, double > ans assign to find_Centroid ( vp )
print setprecision ( 12), ans. first, "" "", ans. second and''
return 0
","Find the centroid of a non 
 C ++ program to implement the above approach ; For all vertices ; Calculate value of A using shoelace untillmula ; Calculating coordinates of centroid of polygon ; Driver code ; Coordinate of the vertices
",1
133,"pair  double, double > find_Centroid ( vector  pair  double, double > > > & v ) pair  double, double > ans assign to  0, 0
create integer n with n assign to size of v
signArea assign to double with signArea assign to 0
untill i assign to 0 to size of v exclusive, double x0 assign to v array of i . first, y0 assign to v array of i  . second
x1 assign to double with x1 assign to v array of ( i + 1 ) % n  . first, y1 assign to v array of ( i + 1 ) % n  . second
declare double A assign to ( x0 * y1 ) - ( x1 * y0 ) )
add A to signedArea
increment ans by ( x0 + x1 ) * A
increment ans by ( y0 + y1 ) * A
signedArea * 0.5
set ans. first to ( ans. first ) / ( 6 * signedArea )
ans. second assign to ( ans. second ) / ( 6 * signedArea )
return ans
declare integer main, vector, pair, double, double > > vp assign to   1, 2 , 3, -4 , 6, -7
pair  double, double > ans assign to find_Centroid ( vp )
print setprecision ( 12), ans. first, "" "", ans. second and''
return 0
","Form minimum number from given sequence 
 C ++ program to print minimum number that can be untillmed from a given sequence of Is and Ds ; Function to decode the given sequence to construct minimum number without repeated digits ; result store output string ; create an empty stack of integers ; run n + 1 times where n is length of input sequence ; push number i + 1 into the stack ; if all characters of the input sequence are processed or current character is ' I ' ( increasing ) ; run till stack is empty ; remove top element from the stack and add it to solution ; main function
",0
134,"declare integer main ( )  integer d assign to 10
a assign to double
set a to ( double ) ( 360 - ( 6 * d ) ) / 4
print a, "", "" a + d, "", "" a + ( 2 * d ), "", "", a + ( 3 * d ), newline
return 0
","Program to find the angles of a quadrilateral 
 C ++ implementation of the approach ; Driver code ; according to untillmula derived above ; print all the angles
",1
135,"declare integer main ( )  integer d assign to 10
a assign to double
set a to ( double ) ( 360 - ( 6 * d ) ) / 4
print a, "", "" a + d, "", "" a + ( 2 * d ), "", "", a + ( 3 * d ), newline
return 0
","Icosihenagonal Number 
 C ++ program to find nth Icosihenagonal number ; Function to find Icosihenagonal number ; Formula to calculate nth Icosihenagonal number ; Driver Code
",0
136,"declare void distance (float a1, b1, c1, d1, a2, b2, c2, d2 ) as floats x1, y1, z1, d
if a1 / a2 assign to b1 / b2 and b1 / b2 assign to c1 / c2, x1 assign to y1 assign to 0
set z1 to - d1 / c1
d assign to fabs ( ( c2 * z1 + d2 ) ) / ( sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ) )
print "" Perpendicular distance is "" print d print newline
else print "" Planes are not parallel ""
return
declare integer main ( ) and float a1 assign to 1
b1 assign to float with b1 assign to 2
c1 assign to float with c1 assign to -1
d1 assign to float with d1 assign to 1
a2 assign to float with a2 assign to 3
b2 assign to float with b2 assign to 6
c2 assign to float with c2 assign to -3
d2 assign to -4
distance ( a1, b1, c1, d1, a2, b2, c2, d2 )
return 0
","Distance between two parallel Planes in 3 
 C ++ program to find the Distance between two parallel Planes in 3 D . ; Function to find distance ; Driver Code
",1
137,"declare void distance (float a1, b1, c1, d1, a2, b2, c2, d2 ) as floats x1, y1, z1, d
if a1 / a2 assign to b1 / b2 and b1 / b2 assign to c1 / c2, x1 assign to y1 assign to 0
set z1 to - d1 / c1
d assign to fabs ( ( c2 * z1 + d2 ) ) / ( sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ) )
print "" Perpendicular distance is "" print d print newline
else print "" Planes are not parallel ""
return
declare integer main ( ) and float a1 assign to 1
b1 assign to float with b1 assign to 2
c1 assign to float with c1 assign to -1
d1 assign to float with d1 assign to 1
a2 assign to float with a2 assign to 3
b2 assign to float with b2 assign to 6
c2 assign to float with c2 assign to -3
d2 assign to -4
distance ( a1, b1, c1, d1, a2, b2, c2, d2 )
return 0
","Check if two strings are same ignoring their cases 
  ; Function to compare two strings ignoring their cases ; Convert to lowercase using transuntillm ( ) function and :: tolower in STL ; Comparing both using inbuilt function ; if strings are equal , return true otherwise false ; Function to print the same or not same if strings are equal or not equal ; Driver Code
",0
138,"return 1 if n is 0
return n * factorial ( n - 1 )
numOfNecklace is a new long long variable with long long value ans assign to factorial ( N ) / factorial ( N / 2 ) * factorial ( N / 2)
set ans to ans * factorial ( N / 2 - 1)
set ans to ans * factorial ( N / 2 - 1)
divide ans by 2
return ans
declare integer main ( ) and integer N assign to 4
print numOfNecklace ( N ) print newline
return 0
","Count of ways to untillm 2 necklace from N beads containing N / 2 beads each 
 C ++ program untill the above approach ; Function to calculate factorial ; Function to count number of ways to make 2 necklace having exactly N / 2 beads if each bead is considered different ; Number of ways to choose N / 2 beads from N beads ; Number of ways to permute N / 2 beads ; Divide ans by 2 to remove repetitions ; Return ans ; Driver Code ; Given Input ; Function Call
",1
139,"return 1 if n is 0
return n * factorial ( n - 1 )
numOfNecklace is a new long long variable with long long value ans assign to factorial ( N ) / factorial ( N / 2 ) * factorial ( N / 2)
set ans to ans * factorial ( N / 2 - 1)
set ans to ans * factorial ( N / 2 - 1)
divide ans by 2
return ans
declare integer main ( ) and integer N assign to 4
print numOfNecklace ( N ) print newline
return 0
","Count pairs ( i , j ) from given array such that i K * arr array of j   
 C ++ program untill the above approach ; Function to find the count required pairs ; Stores count of pairs ; Traverse the array ; Check if the condition is satisfied or not ; Driver Code ; Function Call
",0
140,"create string isDivisibleByDivisor ( int S, int D)  S %assign to D
set int to int > hashMap
insert S into hashMap
untill i assign to 0 to D inclusive, increment S by S modulo D
S assign to S modulo D
if hashMap. find ( S )not equal to hashMap. end ( ) )  if S is 0, return Yes
return "" No ""
else hashMap. insert ( S )
return "" Yes ""
declare integer main ( ), integers S assign to 3 and D assign to 6
print isDivisibleByDivisor ( S, D )
return 0
","Check if a number S can be made divisible by D by repeatedly adding the remainder to S 
 C ++ program untill the above approach ; Function to check if S is divisible by D untill changing S to ( S + S % D ) ; V ( 0 ) assign to S % D ; Stores the encountered values ; V ( i ) assign to ( V ( i - 1 ) + V ( i - 1 ) % D ) % D ; Check if the value has already been encountered ; Edge Case ; Otherwise , insert it into the hashmap ; Driver Code
",1
141,"create string isDivisibleByDivisor ( int S, int D)  S %assign to D
set int to int > hashMap
insert S into hashMap
untill i assign to 0 to D inclusive, increment S by S modulo D
S assign to S modulo D
if hashMap. find ( S )not equal to hashMap. end ( ) )  if S is 0, return Yes
return "" No ""
else hashMap. insert ( S )
return "" Yes ""
declare integer main ( ), integers S assign to 3 and D assign to 6
print isDivisibleByDivisor ( S, D )
return 0
","Count Negative Numbers in a Column 
 C ++ implementation of More efficient method to count number of negative numbers in row - column sorted matrix M array of n   array of m   ; Recursive binary search to get last negative value in a row between a start and an end ; Base case ; Get the mid untill binary search ; If current element is negative ; If it is the rightmost negative element in the current row ; Check in the right half of the array ; Check in the left half of the array ; Function to return the count of negative numbers in the given matrix ; Initialize result ; To store the index of the rightmost negative element in the row under consideration ; Iterate over all rows of the matrix ; If the first element of the current row is positive then there will be no negatives in the matrix below or after it ; Run binary search only until the index of last negative Integer in the above row ; Driver code
",0
142,"minimumSteps assign to integer with minimumSteps assign to x, y assign to integer, cnt assign to 0
untill x is not 0 and y is not 0, increment cnt by x / y
x assign to x modulo y
else cnt assign to cnt + y / x
y assign to y modulo x
print cnt
if x is greater than 1 y is greater than 1, set cnt to -1
print cnt
declare integer main ( ), integers x assign to 3 and y assign to 1
minimumSteps ( x, y )
return 0
","Minimum number of given moves required to reach ( 1 , 1 ) from ( X , Y ) 
 C ++ program untill the above approach ; Function to count the number of steps required to convert ( x , y ) to ( 1 , 1 ) ; Store the required result ; Iterate untill both x and y are not equal to 0 ; If x is greater than y ; Update count and value of x ; Otherwise ; Update count and value of y ; If both x and y > 1 ; Print the result ; Driver Code ; Given X and Y
",1
143,"minimumSteps assign to integer with minimumSteps assign to x, y assign to integer, cnt assign to 0
untill x is not 0 and y is not 0, increment cnt by x / y
x assign to x modulo y
else cnt assign to cnt + y / x
y assign to y modulo x
print cnt
if x is greater than 1 y is greater than 1, set cnt to -1
print cnt
declare integer main ( ), integers x assign to 3 and y assign to 1
minimumSteps ( x, y )
return 0
","Remove all occurrences of a character in a string 
 Recursive approach 
 C ++ program untill the above approach ; Function to remove all occurrences of a character in the string ; Base Case ; Check the first character of the given string ; Pass the rest of the string to recursion Function call ; Add the first character of str and string from recursion ; Driver Code ; Given String ; Given character ; Function Call
",0
144,"check assign to boolean function A assign to array of integers A assign to array of integers N assign to array of integers with value of S
create integer B_end with B_end assign to 0
untill i assign to 0 to N exclusive, if S. empty ( ) is true, top assign to S. top ( )
untill top is B_end + 1, set B_end to B_end + 1
pop S
if empty is true, break loop
set top to S. top ( )
if S. empty ( ) ) push A array of i  
else set top to S. top ( )
if A array of i   is less than top, push A array of i  
else return false
else push A array of i  
return true
declare integer main ( ), integer A assign to  4, 1, 2, 3  ; declare integer array A assign to  4, 1, 2, 3
create integer N with N assign to sizeof ( A) / sizeof ( A array of 0   )
print YES and NO
return 0
","Check if an array is stack sortable 
 C ++ implementation of above approach . ; Function to check if A array of   is Stack Sortable or Not . ; Stack S ; Pointer to the end value of array B . ; Traversing each element of A array of   from starting Checking if there is a valid operation that can be peruntillmed . ; If the stack is not empty ; Top of the Stack . ; If the top of the stack is Equal to B_end + 1 , we will pop it And increment B_end by 1. ; if current top is equal to B_end + 1 , we will increment B_end to B_end + 1 ; Pop the top element . ; If the stack is empty We cannot further perfom this operation . Thereuntille break ; Current Top ; If stack is empty Push the Current element ; If the Current element of the array A array of   if smaller than the top of the stack We can push it in the Stack . ; Else We cannot sort the array Using any valid operations . ; Not Stack Sortable ; If the stack is empty push the current element in the stack . ; Stack Sortable ; Driver 's Code
",1
145,"check assign to boolean function A assign to array of integers A assign to array of integers N assign to array of integers with value of S
create integer B_end with B_end assign to 0
untill i assign to 0 to N exclusive, if S. empty ( ) is true, top assign to S. top ( )
untill top is B_end + 1, set B_end to B_end + 1
pop S
if empty is true, break loop
set top to S. top ( )
if S. empty ( ) ) push A array of i  
else set top to S. top ( )
if A array of i   is less than top, push A array of i  
else return false
else push A array of i  
return true
declare integer main ( ), integer A assign to  4, 1, 2, 3  ; declare integer array A assign to  4, 1, 2, 3
create integer N with N assign to sizeof ( A) / sizeof ( A array of 0   )
print YES and NO
return 0
","Program to find the angles of a quadrilateral 
 C ++ implementation of the approach ; Driver code ; according to untillmula derived above ; print all the angles
",0
146,"declare integer countMinReversals ( string expr )  integer len assign to length of expr
if len modulo 2 return -1
create stack  char > s
untill i assign to 0 to len exclusive, if expr array of i   is''and s. top ( ) is' ', pop s
else push expr array of i  
else push expr array of i  )
red_len assign to size of s
create integer n with n assign to 0
untill s is not empty and top ( ) is'')  pop ( )
increment n
return ( red_len / 2 + n % 2)
declare integer main ( ), string expr assign to ""      ""
print countMinReversals ( expr)
return 0
","Minimum number of bracket reversals needed to make an expression balanced 
 C ++ program to find minimum number of reversals required to balance an expression ; Returns count of minimum reversals untill making expr balanced . Returns - 1 if expr cannot be balanced . ; length of expression must be even to make it balanced by using reversals . ; After this loop , stack contains unbalanced part of expression , i . e . , expression of the untillm "" } } . . } { { . . { "" ; Length of the reduced expression red_len assign to ( m + n ) ; count opening brackets at the end of stack ; return ceil ( m / 2 ) + ceil ( n / 2 ) which is actually equal to ( m + n ) / 2 + n % 2 when m + n is even . ; Driver program to test above function
",1
147,"declare integer countMinReversals ( string expr )  integer len assign to length of expr
if len modulo 2 return -1
create stack  char > s
untill i assign to 0 to len exclusive, if expr array of i   is''and s. top ( ) is' ', pop s
else push expr array of i  
else push expr array of i  )
red_len assign to size of s
create integer n with n assign to 0
untill s is not empty and top ( ) is'')  pop ( )
increment n
return ( red_len / 2 + n % 2)
declare integer main ( ), string expr assign to ""      ""
print countMinReversals ( expr)
return 0
","Count numbers in range such that digits in it and it 's product with q are unequal 
 C ++ program untill above approach ; Function to check if all of the digits in a number and it 's product with q are unequal or not ; convert first number into string ; Insert elements from 1 st number to hash ; Calculate corresponding product ; Convert the product to string ; Using the hash check if any digit of product matches with the digits of input number ; If yes , return false ; Return true ; Function to count numbers in the range array of l , r   such that all of the digits of the number and it 's product with q are unequal ; check untill every number between l and r ; Driver Code ; Function Call
",0
148,"declare integer countMinReversals ( string expr )  integer len assign to length of expr
if len modulo 2 is not 0, return -1
declare integers left_brace assign to 0 and right_brace assign to 0
create integer ans
untill i assign to 0 to len exclusive, increment left_brace by one if expr array of i   is' '
else if left_brace is 0, increment right_brace
else
set ans to ceil ( left_brace / 2 ) + ceil ( right_brace / 2 )
return ans
declare integer main ( ), string expr assign to ""      ""
print countMinReversals ( expr)
return 0
","Minimum number of bracket reversals needed to make an expression balanced 
 C ++ program to find minimum number of reversals required to balance an expression ; Returns count of minimum reversals untill making expr balanced . Returns - 1 if expr cannot be balanced . ; Expressions of odd lengths cannot be balanced ; If we find a left bracket then we simply increment the left bracket ; Else if left bracket is 0 then we find unbalanced right bracket and increment right bracket or if the expression is balanced then we decrement left ; Driver program to test above function
",1
149,"declare integer countMinReversals ( string expr )  integer len assign to length of expr
if len modulo 2 is not 0, return -1
declare integers left_brace assign to 0 and right_brace assign to 0
create integer ans
untill i assign to 0 to len exclusive, increment left_brace by one if expr array of i   is' '
else if left_brace is 0, increment right_brace
else
set ans to ceil ( left_brace / 2 ) + ceil ( right_brace / 2 )
return ans
declare integer main ( ), string expr assign to ""      ""
print countMinReversals ( expr)
return 0
","Magic Square 
 Even Order 
 C ++ Program to print Magic square of Doubly even order ; Function untill calculating Magic square ; filling matrix with its count value starting from 1 ; ; change value of Array elements at fix location as per rule ( n * n + 1 ) - arr array of i   array of j   Top Left corner of Matrix ( order ( n / 4 ) * ( n / 4 ) ) ; Top Right corner of Matrix ( order ( n / 4 ) * ( n / 4 ) ) ; Bottom Left corner of Matrix ( order ( n / 4 ) * ( n / 4 ) ) ; Bottom Right corner of Matrix ( order ( n / 4 ) * ( n / 4 ) ) ; Centre of Matrix ( order ( n / 2 ) * ( n / 2 ) ) ; Printing the magic - square ; driver program ; Function call
",0
150,"create void PrintMinNumberForPattern ( string arr), curr_max assign to 0
let last_entry be a integer with last_entry assign to 0
create integer j
untill i assign to 0 to length of arr exclusive, noOfNextD assign to 0
switch ( arr array of i   )  case'I' : j assign to i + 1
untill arr array ofj  is'D' and j  length of arr ), increment noOfNextD
increment j
if i is 0, set curr_max to noOfNextD + 2
print "" "" and a new line
print "" "" print curr_max
last_entry assign to curr_max
else set curr_max to curr_max + noOfNextD + 1
last_entry assign to curr_max
print "" "" and last_entry
untill k assign to 0 to noOfNextD exclusive, print "" "" print -- last_entry
increment i
break
if i is 0, set j to i + 1
untill arr array ofj  is'D' and j  length of arr ), increment noOfNextD
increment j
set curr_max to noOfNextD + 2
print "" "", curr_max, "" "" and curr_max - 1
last_entry assign to curr_max - 1
else print "" "" print last_entry - 1
last_entry assign to last_entry --
break
print newline
print int main and printMinNumberForPattern ( "" IDID "" )
printMinNumberForPattern ( "" I "" )
printMinNumberForPattern ( "" DD "" )
printMinNumberForPattern ( "" II "" )
printMinNumberForPattern ( "" DIDI "" )
printMinNumberForPattern is a newline
printMinNumberForPattern is a newline called DDIDDIID
return 0
","Form minimum number from given sequence 
 C ++ program to print minimum number that can be untillmed from a given sequence of Is and Ds ; Prints the minimum number that can be untillmed from input sequence of I ' s â– and â– D ' s ; Initialize current_max ( to make sure that we don 't use repeated character ; Initialize last_entry ( Keeps track untill last printed digit ) ; Iterate over input array ; Initialize ' noOfNextD ' to get count of next D 's available ; If letter is ' I ' Calculate number of next consecutive D 's  available ; If ' I ' is first letter , print incremented sequence from 1 ; Set max digit reached ; If not first letter Get next digit to print ; Print digit untill I ; For all next consecutive ' D ' print decremented sequence ; If letter is ' D ' ; If ' D ' is first letter in sequence Find number of Next D 's available ; Calculate first digit to print based on number of consecutive D 's ; Print twice untill the first time ; Store last entry ; If current ' D ' is not first letter Decrement last_entry ; Driver program to test above
",1
151,"create void PrintMinNumberForPattern ( string arr), curr_max assign to 0
let last_entry be a integer with last_entry assign to 0
create integer j
untill i assign to 0 to length of arr exclusive, noOfNextD assign to 0
switch ( arr array of i   )  case'I' : j assign to i + 1
untill arr array ofj  is'D' and j  length of arr ), increment noOfNextD
increment j
if i is 0, set curr_max to noOfNextD + 2
print "" "" and a new line
print "" "" print curr_max
last_entry assign to curr_max
else set curr_max to curr_max + noOfNextD + 1
last_entry assign to curr_max
print "" "" and last_entry
untill k assign to 0 to noOfNextD exclusive, print "" "" print -- last_entry
increment i
break
if i is 0, set j to i + 1
untill arr array ofj  is'D' and j  length of arr ), increment noOfNextD
increment j
set curr_max to noOfNextD + 2
print "" "", curr_max, "" "" and curr_max - 1
last_entry assign to curr_max - 1
else print "" "" print last_entry - 1
last_entry assign to last_entry --
break
print newline
print int main and printMinNumberForPattern ( "" IDID "" )
printMinNumberForPattern ( "" I "" )
printMinNumberForPattern ( "" DD "" )
printMinNumberForPattern ( "" II "" )
printMinNumberForPattern ( "" DIDI "" )
printMinNumberForPattern is a newline
printMinNumberForPattern is a newline called DDIDDIID
return 0
","Length of diagonals of a Rhombus using length of Side and vertex Angle 
 C ++ program to implement the above approach ; Function to calculate the length of diagonals of a rhombus using length of sides and vertex angle ; Driver Code
",0
152,"declare void function printLeast with string arr as argument, set min_avail to 1 and pos_of_I to 0
create vector v with int > v
if arr array of 0   is'I', push_back v.
push_back v. 2
min_avail assign to 3
set pos_of_I to 1
else v. push_back ( 2 )
push_back v. 1
min_avail assign to 3
set pos_of_I to 0
untill i assign to 1 to length of arr, if arr array of i   is'I', push_back v ( min_avail )
increment min_avail
set pos_of_I to i + 1
else v. push_back ( v array of i   )
untill j assign to pos_of_I to i inclusive, increment v array ofj  
increment min_avail
print v array of i   and "" ""
print newline
declare integer main ( ) and printLeast ( "" IDID "" )
printLeast is a new line
printLeast is a new line
printLeast is a new line
printLeast is a new line
printLeast is a new line
printLeast is a new line called DDIDDIID
return 0
","Form minimum number from given sequence 
 C ++ program to print minimum number that can be untillmed from a given sequence of Is and Ds ; min_avail represents the minimum number which is still available untill inserting in the output vector . pos_of_I keeps track of the most recent index where ' I ' was encountered w . r . t the output vector ; vector to store the output ; cover the base cases ; Traverse rest of the input ; print the number ; Driver program to check the above function
",1
153,"declare void function printLeast with string arr as argument, set min_avail to 1 and pos_of_I to 0
create vector v with int > v
if arr array of 0   is'I', push_back v.
push_back v. 2
min_avail assign to 3
set pos_of_I to 1
else v. push_back ( 2 )
push_back v. 1
min_avail assign to 3
set pos_of_I to 0
untill i assign to 1 to length of arr, if arr array of i   is'I', push_back v ( min_avail )
increment min_avail
set pos_of_I to i + 1
else v. push_back ( v array of i   )
untill j assign to pos_of_I to i inclusive, increment v array ofj  
increment min_avail
print v array of i   and "" ""
print newline
declare integer main ( ) and printLeast ( "" IDID "" )
printLeast is a new line
printLeast is a new line
printLeast is a new line
printLeast is a new line
printLeast is a new line
printLeast is a new line called DDIDDIID
return 0
","Check if any K ranges overlap at any point 
 C ++ implementation of the approach ; Comparator to sort the vector of pairs ; Function that returns true if any k segments overlap at any point ; Starting points are marked by - 1 and ending points by + 1 ; Sort the vector by first element ; Stack to store the overlaps ; Get the current element ; If it is the starting point ; Push it in the stack ; It is the ending point ; Pop an element from stack ; If more than k ranges overlap ; Driver code
",0
154,"printMinNumberForPattern is a void function with string seq as argument, returning string
create stack  integer > stk
untill i assign to 0 to length of seq, increment i, push ( i + 1 )
if i is length of seq ( ) seq array of i   is'I' ) untill stk is not empty ( ) ), increment result by to_string ( stk. top ( ) ) )
increment result by "" ""
pop assign to stk. pop assign to pop
print result
print int main and printMinNumberForPattern ( "" IDID "" )
printMinNumberForPattern ( "" I "" )
printMinNumberForPattern ( "" DD "" )
printMinNumberForPattern ( "" II "" )
printMinNumberForPattern ( "" DIDI "" )
printMinNumberForPattern is a newline
printMinNumberForPattern is a newline called DDIDDIID
return 0
","Form minimum number from given sequence 
 C ++ program to print minimum number that can be untillmed from a given sequence of Is and Ds ; Function to decode the given sequence to construct minimum number without repeated digits ; result store output string ; create an empty stack of integers ; run n + 1 times where n is length of input sequence ; push number i + 1 into the stack ; if all characters of the input sequence are processed or current character is ' I ' ( increasing ) ; run till stack is empty ; remove top element from the stack and add it to solution ; main function
",1
155,"printMinNumberForPattern is a void function with string seq as argument, returning string
create stack  integer > stk
untill i assign to 0 to length of seq, increment i, push ( i + 1 )
if i is length of seq ( ) seq array of i   is'I' ) untill stk is not empty ( ) ), increment result by to_string ( stk. top ( ) ) )
increment result by "" ""
pop assign to stk. pop assign to pop
print result
print int main and printMinNumberForPattern ( "" IDID "" )
printMinNumberForPattern ( "" I "" )
printMinNumberForPattern ( "" DD "" )
printMinNumberForPattern ( "" II "" )
printMinNumberForPattern ( "" DIDI "" )
printMinNumberForPattern is a newline
printMinNumberForPattern is a newline called DDIDDIID
return 0
","Print reverse of a string using recursion 
 C ++ program to reverse a string using recursion ; Function to print reverse of the passed string ; Driver program to test above function
",0
156,"declare getMinNumberForPattern with string seq as argument, n assign to length of seq
if n >assign to 9 return "" - 1""
result assign to string with result assign to n + 1 and''
count assign to integer with count assign to 1
untill i assign to 0 to n inclusive, increment j by 1, set result array ofj + 1   to '0' + count ++
if j >assign to 0 and seq array ofj  assign to'I', break
return result
declare integer main ( ) and string inputs array of   assign to IDID "", "" I "", "" DD "", "" II "", "" DIDI "", "" IIDDD "", "" DDIDDIID "", "" DDIDDIID ""  ;
untill string input : inputs, print getMinNumberForPattern ( input) and "" STRNEWLINE ""
return 0
","Form minimum number from given sequence 
 C ++ program of above approach ; Returns minimum number made from given sequence without repeating digits ; The loop runs untill each input character as well as one additional time untill assigning rank to remaining characters ; Driver Code
",1
157,"declare getMinNumberForPattern with string seq as argument, n assign to length of seq
if n >assign to 9 return "" - 1""
result assign to string with result assign to n + 1 and''
count assign to integer with count assign to 1
untill i assign to 0 to n inclusive, increment j by 1, set result array ofj + 1   to '0' + count ++
if j >assign to 0 and seq array ofj  assign to'I', break
return result
declare integer main ( ) and string inputs array of   assign to IDID "", "" I "", "" DD "", "" II "", "" DIDI "", "" IIDDD "", "" DDIDDIID "", "" DDIDDIID ""  ;
untill string input : inputs, print getMinNumberForPattern ( input) and "" STRNEWLINE ""
return 0
","Count of integers that divide all the elements of the given array 
 C ++ implementation of the approach ; Function to return the count of the required integers ; To store the gcd of the array elements ; To store the count of factors of the found gcd ; If g is a perfect square ; Factors appear in pairs ; Driver code
",0
158,"declare integer isPrime with integer n, c assign to 0
untill i assign to 1 to n / 2 exclusive, increment c by 1 if n modulo i is 0
if c is 1 return 1
else return 0
declare findMinNum with arr array of  , n as arguments, returning integers first assign to 0, last assign to 0, num, rev, i
create integer hash with hash assign to 0 and a new array of integers with 10 elements
untill i assign to 0 to n exclusive, increment hash array of arr array of i     by 1
print Minimum number :
untill i assign to 0 to 9 inclusive, print i
print a new line
untill i assign to 0 to 9 inclusive, if hash array of i   is not 0, set first to i
break loop
untill i assign to 9 to 0 inclusive, if hash array of i   is not 0, set last to i
break loop
num assign to first * 10 + last
rev assign to last * 10 + first
print Prime combinations
if isPrime (num ) and isPrime ( rev ) ), print num, "" "" and rev
else if isPrime (num ) is true, print num
else if isPrime ( rev ) print rev
else print "" No combinations exist ""
declare integer main ( ), integer arr array of   assign to  1, 2, 4, 7, 8  ;
call findMinNum with arguments arr, 5
return 0
","Check if the first and last digit of the smallest number untillms a prime 
 C ++ implementation of above approach ; function to check prime ; Function to generate smallest possible number with given digits ; Declare a hash array of size 10 and initialize all the elements to zero ; store the number of occurrences of the digits in the given array into the hash table ; Traverse the hash in ascending order to print the required number ; Print the number of times a digits occurs ; extracting the first digit ; extracting the last digit ; printing the prime combinations ; Driver code
",1
159,"declare integer isPrime with integer n, c assign to 0
untill i assign to 1 to n / 2 exclusive, increment c by 1 if n modulo i is 0
if c is 1 return 1
else return 0
declare findMinNum with arr array of  , n as arguments, returning integers first assign to 0, last assign to 0, num, rev, i
create integer hash with hash assign to 0 and a new array of integers with 10 elements
untill i assign to 0 to n exclusive, increment hash array of arr array of i     by 1
print Minimum number :
untill i assign to 0 to 9 inclusive, print i
print a new line
untill i assign to 0 to 9 inclusive, if hash array of i   is not 0, set first to i
break loop
untill i assign to 9 to 0 inclusive, if hash array of i   is not 0, set last to i
break loop
num assign to first * 10 + last
rev assign to last * 10 + first
print Prime combinations
if isPrime (num ) and isPrime ( rev ) ), print num, "" "" and rev
else if isPrime (num ) is true, print num
else if isPrime ( rev ) print rev
else print "" No combinations exist ""
declare integer main ( ), integer arr array of   assign to  1, 2, 4, 7, 8  ;
call findMinNum with arguments arr, 5
return 0
","Check whether two strings can be made equal by reversing substring of equal length from both strings 
 C ++ program untill the above approach ; function to count inversion count of the string ; untill storing frequency ; Add all the characters which are less than the ith character beuntille i . ; adding the count to inversion count ; updating the character in the frequency array ; function to check whether any of the string have a repeated character ; function to check whether the string S1 and S2 can be made equal by reversing sub strings of same size in both strings ; frequency array to check whether both string have same character or not ; adding the frequency ; ; if the character is not in S1 ; decrementing the frequency ; If both string doesnot have same characters or not ; finding inversion count of both strings ; If inversion count is same , or have same parity or if any of the string have a repeated character then the answer is Yes else No ; driver code
",0
160,"gcd assign to integer if a is equal to 0, return b
return gcd ( b modulo a, a )
boolean coprime (int a,int b), return (gcd ( a, b ) assign to 1 )
declare possibleTripletInRange with integer L, R as arguments, set flag to false
create integers possibleA, possibleB, possibleC
untill a assign to L to R inclusive, set flag to true
set possibleA to a
set possibleB to b
set possibleC to c
break loop
print "" ( ""  possibleA  "", ""  possibleB  "", ""  possibleC  "" ) "" and "" is one such possible triplet between ""  L  "" and "" and "" R  "" STRNEWLINE ""
else print No Such Triplet between ""  L  "" and ""  R  "" STRNEWLINE ""
declare integer main ( ), integers L, R
set L to 2
R assign to 10
call possibleTripletInRange ( L, R )
set L to 23
R assign to 46
call possibleTripletInRange ( L, R )
return 0
","Finding a Non Transitive Co 
 C ++ program to find possible non transitive triplets btw L and R ; Function to return gcd of a and b ; function to check untill gcd ; a and b are coprime if their gcd is 1. ; Checks if any possible triplet ( a , b , c ) satisfying the condition that ( a , b ) is coprime , ( b , c ) is coprime but ( a , c ) isnt ; Generate and check untill all possible triplets between L and R ; if we find any such triplets set flag to true ; flag assign to True indicates that a pair exists between L and R ; Driver code ; finding possible Triplet between 2 and 10 ; finding possible Triplet between 23 and 46
",1
161,"gcd assign to integer if a is equal to 0, return b
return gcd ( b modulo a, a )
boolean coprime (int a,int b), return (gcd ( a, b ) assign to 1 )
declare possibleTripletInRange with integer L, R as arguments, set flag to false
create integers possibleA, possibleB, possibleC
untill a assign to L to R inclusive, set flag to true
set possibleA to a
set possibleB to b
set possibleC to c
break loop
print "" ( ""  possibleA  "", ""  possibleB  "", ""  possibleC  "" ) "" and "" is one such possible triplet between ""  L  "" and "" and "" R  "" STRNEWLINE ""
else print No Such Triplet between ""  L  "" and ""  R  "" STRNEWLINE ""
declare integer main ( ), integers L, R
set L to 2
R assign to 10
call possibleTripletInRange ( L, R )
set L to 23
R assign to 46
call possibleTripletInRange ( L, R )
return 0
","Sum of bitwise AND of all submatrices 
 C ++ program to find sum of Bit - wise AND of all submatrices ; Function to find prefix - count untill each row from right to left ; Function to find the number of submatrices with all 1 s ; Array to store required prefix count of 1 s from right to left untill boolean array ; Variable to store the final answer ; For each index of a column , determine the number of sub - matrices starting from that index and has all 1 s ; Stack to store elements and the count of the numbers they popped First part of pair is value of inserted element Second part is count of the number of elements pushed beuntille with a greater value ; variable to store the number of submatrices with all 1 s ; Function to find the sum of Bitwise - AND of all submatrices ; matrix to store the status of ith bit of each element of matrix arr ; Driver Code
",0
162,"declare possibleToReach with integers a, b as arguments, returning integer c assign to cbrt ( a * b )
create integer re1 with re1 assign to a / c
create integer re2 with re2 assign to b / c
if ( re1 * re1 * re2 assign to a ) and ( re2 * re2 * re1 assign to b ) return true
else return false
declare integer main ( ), integers A assign to 60, B assign to 450
if possibleToReach ( A, B ) ) print yes
else print no
return 0
","Reach A and B by multiplying them with K and K to the power 2 at every step 
 CPP program to determine if A and B can be reached starting from 1 , 1 following the given steps . ; function to check is it is possible to reach A and B starting from 1 and 1 ; find the cuberoot of the number ; divide the number by cuberoot ; if it is a perfect cuberoot and divides a and b ; Driver code
",1
163,"declare possibleToReach with integers a, b as arguments, returning integer c assign to cbrt ( a * b )
create integer re1 with re1 assign to a / c
create integer re2 with re2 assign to b / c
if ( re1 * re1 * re2 assign to a ) and ( re2 * re2 * re1 assign to b ) return true
else return false
declare integer main ( ), integers A assign to 60, B assign to 450
if possibleToReach ( A, B ) ) print yes
else print no
return 0
","Sqrt ( or Square Root ) Decomposition 
 Set 2 ( LCA of Tree in O ( sqrt ( height ) ) time ) 
 C ++ program to find LCA using Sqrt decomposition ; block size assign to sqrt ( height ) ; stores depth untill each node ; stores first parent untill each node ; stores first ancestor in previous block ; precalculating the required parameters associated with every node ; marking depth of cur node ; marking parent of cur node ; making jump_parent of cur node ; if it is first node of the block then its jump_parent is its cur parent ; if it is not the first node of this block then its jump_parent is jump_parent of its parent ; propogating the marking down the subtree ; using sqrt decomposition trick ; maintaining depth array of v   > depth array of u   ; climb to its jump parent ; u and v have same jump_parent ; precalclating 1 ) depth . 2 ) parent . 3 ) jump_parent untill each node ; Driver function to call the above functions ; adding edges to the tree ; here we are directly taking height assign to 4 according to the given tree but we can pre - calculate height assign to max depth in one more dfs
",0
164,"if length of n is less than or equal to 2 return false
untill i assign to 2 to length of n exclusive, if n array of i - 2   is not n array of i   false
return true
declare integer main ( ) and string n assign to ""1212121""
if isUndulating ( n ) ), print Yes
else print No
","Undulating numbers 
 C ++ program to check whether a number is undulating or not ; Considering the definition with restriction that there should be at least 3 digits ; Check if all alternate digits are same or not . ; Driver code
",1
165,"if length of n is less than or equal to 2 return false
untill i assign to 2 to length of n exclusive, if n array of i - 2   is not n array of i   false
return true
declare integer main ( ) and string n assign to ""1212121""
if isUndulating ( n ) ), print Yes
else print No
","Count the number of ways to construct the target string 
 C ++ Program to Count the number of ways to construct the target string ; base case ; If current subproblem has been solved , use the value ; current character ; search through all the indiced at which the current character occurs . For each index greater than prev , take the index and move to the next position , and add to the answer . ; Store and return the solution untill this subproblem ; preprocess the strings by storing untill each character of every string , the index of their occurrence we will use a common list untill all because of only the index matter in the string from which the character was picked ; we are storing j + 1 because the initial picked index in the recursive step will ne 0. This is just untill ease of implementation ; initialise dp table . - 1 represents that the subproblem hasn 't been solved ; Driver Code
",0
166,"declare Series with integer n as argument, returning integer i
sums assign to integer with sums assign to 0
untill i assign to 1 to n inclusive, add ( i * i ) to sums
return sums
declare integer main ( ) and integer n assign to 3
res assign to integer with res assign to Series ( n )
print res
","Program to find the sum of a Series ( 1 * 1 ) + ( 2 * 2 ) + ( 3 * 3 ) + ( 4 * 4 ) + ( 5 * 5 ) + ... + ( n * n ) 
 CPP program to calculate the following series ; Function to calculate the following series ; Driver Code
",1
167,"declare Series with integer n as argument, returning integer i
sums assign to integer with sums assign to 0
untill i assign to 1 to n inclusive, add ( i * i ) to sums
return sums
declare integer main ( ) and integer n assign to 3
res assign to integer with res assign to Series ( n )
print res
","Program to find transpose of a matrix 
  ; This function stores transpose of A array of   array of   in B array of   array of   ; Driver code
",0
168,"declare countLastDigitK with long longs low, high, K, mlow assign to 10 * ceil ( low / 10.0) as arguments, returning integer
create long long mhigh with mhigh assign to 10 * floor ( high / 10.0 )
count assign to integer with count assign to ( mhigh - mlow ) / 10
if high modulo 10 >assign to K, increment count
if low modulo 10 assign to K and low modulo 10, increment count
return count
declare integer variables main and low assign to 3 and high assign to 35 and k assign to 3
print countLastDigitK ( low, high, k)
return 0
","Count numbers with unit digit k in given range 
 Efficient CPP program to count numbers with last digit as k in given range . ; Returns count of numbers with k as last digit . ; Driver Code
",1
169,"declare countLastDigitK with long longs low, high, K, mlow assign to 10 * ceil ( low / 10.0) as arguments, returning integer
create long long mhigh with mhigh assign to 10 * floor ( high / 10.0 )
count assign to integer with count assign to ( mhigh - mlow ) / 10
if high modulo 10 >assign to K, increment count
if low modulo 10 assign to K and low modulo 10, increment count
return count
declare integer variables main and low assign to 3 and high assign to 35 and k assign to 3
print countLastDigitK ( low, high, k)
return 0
","Rearrange a given linked list in 
 C ++ code to rearrange linked list in place ; function untill rearranging a linked list with high and low value . ; Base case . ; two pointer variable . ; swap function untill swapping data . ; swap function untill swapping data . ; function to insert a node in the linked list at the beginning . ; function to display node of linked list . ; driver code ; let create a linked list . 9 -> 6 -> 8 -> 3 -> 7
",0
170,"declare integer sum ( integer L, integer R)  integer p assign to R / 6
q assign to integer with q assign to ( L - 1 ) / 6
create integer sumR with sumR assign to 3 * ( p * ( p + 1 ) )
create integer sumL with sumL assign to ( q * ( q + 1 ) ) * 3
return sumR - sumL
declare integer main ( ), L assign to 1 and R assign to 20
print sum ( L, R )
return 0
","Sum of all numbers divisible by 6 in a given range 
 CPP program to find sum of numbers divisible by 6 in a given range . ; function to calculate the sum of all numbers divisible by 6 in range L - R . . ; no of multiples of 6 upto r ; no of multiples of 6 upto l - 1 ; summation of all multiples of 6 upto r ; summation of all multiples of 6 upto l - 1 ; returns the answer ; driver program to test the above function
",1
171,"declare integer sum ( integer L, integer R)  integer p assign to R / 6
q assign to integer with q assign to ( L - 1 ) / 6
create integer sumR with sumR assign to 3 * ( p * ( p + 1 ) )
create integer sumL with sumL assign to ( q * ( q + 1 ) ) * 3
return sumR - sumL
declare integer main ( ), L assign to 1 and R assign to 20
print sum ( L, R )
return 0
","Count set bits in an integer 
 C ++ program to count set bits by pre - storing count set bits in nibbles . ; Recursively get nibble of a given number and map them in the array ; Find last nibble ; Use pre - stored values to find count in last nibble plus recursively add remaining nibbles . ; Driver code
",0
172,"create string prevNum ( string str )  integer len assign to str. length ( )
index assign to integer with index assign to -1
untill i assign to len - 2 to 0 inclusive, if str array of i   > str array of i + 1  , index assign to i
break loop
smallGreatDgt assign to -1
untill i assign to len - 1 to index inclusive, i -- ) if str array of i   str array of index , if smallGreatDgt is -1, smallGreatDgt assign to i
else if str array of i  >assign to str array of smallGreatDgt  , smallGreatDgt assign to i
if index is -1, return "" - 1""
if smallGreatDgt is not -1, swap str array of index  and str array of smallGreatDgt 
return str
return "" - 1""
declare integer main ( ), string str assign to ""34125""
print prevNum ( str)
return 0
","Largest smaller number possible using only one swap operation 
 C ++ program to find the largest smaller number by swapping one digit . ; Returns largest possible number with one swap such that the number is smaller than str . It is assumed that there are leading 0 s . ; Traverse from right until we find a digit which is greater than its next digit . For example , in 34125 , our index is 4. ; We can also use binary search here as digits after index are sorted in increasing order . Find the biggest digit in the right of arr array of index   which is smaller than arr array of index   ; If index is - 1 i . e . digits are in increasing order . ; Swap both values ; Drivers code
",1
173,"create string prevNum ( string str )  integer len assign to str. length ( )
index assign to integer with index assign to -1
untill i assign to len - 2 to 0 inclusive, if str array of i   > str array of i + 1  , index assign to i
break loop
smallGreatDgt assign to -1
untill i assign to len - 1 to index inclusive, i -- ) if str array of i   str array of index , if smallGreatDgt is -1, smallGreatDgt assign to i
else if str array of i  >assign to str array of smallGreatDgt  , smallGreatDgt assign to i
if index is -1, return "" - 1""
if smallGreatDgt is not -1, swap str array of index  and str array of smallGreatDgt 
return str
return "" - 1""
declare integer main ( ), string str assign to ""34125""
print prevNum ( str)
return 0
","Smallest number greater than or equal to N having sum of digits not exceeding S 
 C ++ program untill the above approach ; Function to calculate sum digits of n ; Function to find the smallest possible integer satisfying the given condition ; If the sum of digits is already smaller than S ; Initialize variables ; Finding last kth digit ; Add remaining to make digit 0 ; If sum of digits does not exceed S ; Update k ; Driver Code ; Given N and S ; Function call
",0
174,"untill i assign to 1 to n exclusive, result assign to result * x + poly array of i  
return result
declare findSign with integers poly, n, x, result assign to horner ( poly, n, x )
if result is greater than 0, return 1
else if result is less than 0, return -1
return 0
declare integer main ( ), integer poly assign to  2, -6, 2, -1
create integer x with x assign to 3
create integer n with n assign to sizeof ( poly ) / sizeof ( poly array of 0   )
print Sign of polynomial is "" print findSign ( poly, n, x)
return 0
","Sgn value of a polynomial 
 CPP program to find sign value of a polynomial ; returns value of poly array of 0   x ( n - 1 ) + poly array of 1   x ( n - 2 ) + . . + poly array of n - 1   ; Evaluate value of polynomial using Horner 's method ; Returns sign value of polynomial ; Driver program to test above function . ; Let us evaluate value of 2 x3 - 6 x2 + 2 x - 1 untill x assign to 3
",1
175,"untill i assign to 1 to n exclusive, result assign to result * x + poly array of i  
return result
declare findSign with integers poly, n, x, result assign to horner ( poly, n, x )
if result is greater than 0, return 1
else if result is less than 0, return -1
return 0
declare integer main ( ), integer poly assign to  2, -6, 2, -1
create integer x with x assign to 3
create integer n with n assign to sizeof ( poly ) / sizeof ( poly array of 0   )
print Sign of polynomial is "" print findSign ( poly, n, x)
return 0
","Count Negative Numbers in a Column 
 CPP implementation of Efficient method to count of negative numbers in M array of n   array of m   ; Function to count negative number ; initialize result ; Start with top right corner ; Follow the path shown using arrows above ; j is the index of the last negative number in this row . So there must be ( j + 1 ) ; negative numbers in this row . ; move to the left and see if we can find a negative number there ; Driver program to test above functions
",0
176,"create boolean isPrime array of MAX 
declare sieveOfEratostheneses with void, memset ( isPrime, true, sizeof ( isPrime ) ) as arguments
set isPrime array of 1  to false
untill i assign to 2 to MAX exclusive, increment j by i, set isPrime array of j   to false
create int findPrime (int n ) and num assign to n + 1
untill num is true, return num from function
set num to num + 1
return 0
minNumber assign to integer ( arr assign to array of integers of length   and n) and sieveOfEratostheneses assign to array of integers of length )
create integer sum with sum assign to 0
untill i assign to 0 to n exclusive, add arr array of i   to sum
if isPrime array of sum  is true, return 0
num assign to integer with num assign to findPrime ( sum)
return num - sum
declare integer main ( ), integer arr array of   assign to  2, 4, 6, 8, 12  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print minNumber ( arr, n )
return 0
","Insert minimum number in array so that sum of array becomes prime 
 C ++ program to find minimum number to insert in array so their sum is prime ; Array to store primes ; function to calculate primes using sieve of eratosthenes ; Find prime number greater than a number ; To return prime number greater than n ; check if num is prime ; increment num ; To find number to be added so sum of array is prime ; call sieveOfEratostheneses to calculate primes ; To find sum of array elements ; To find prime number greater then sum ; Return difference of sum and num ; Driver Code
",1
177,"create boolean isPrime array of MAX 
declare sieveOfEratostheneses with void, memset ( isPrime, true, sizeof ( isPrime ) ) as arguments
set isPrime array of 1  to false
untill i assign to 2 to MAX exclusive, increment j by i, set isPrime array of j   to false
create int findPrime (int n ) and num assign to n + 1
untill num is true, return num from function
set num to num + 1
return 0
minNumber assign to integer ( arr assign to array of integers of length   and n) and sieveOfEratostheneses assign to array of integers of length )
create integer sum with sum assign to 0
untill i assign to 0 to n exclusive, add arr array of i   to sum
if isPrime array of sum  is true, return 0
num assign to integer with num assign to findPrime ( sum)
return num - sum
declare integer main ( ), integer arr array of   assign to  2, 4, 6, 8, 12  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print minNumber ( arr, n )
return 0
","Count of permutations such that sum of K numbers from given range is even 
 C ++ program untill the above approach ; Function to return the number of all permutations such that sum of K numbers in range is even ; Find total count of even and odd number in given range ; Iterate loop k times and update even_sum & odd_sum using previous values ; Update the prev_even and odd_sum ; Even sum ; Odd sum ; Return even_sum ; Driver Code ; Given ranges ; Length of permutation ; Function call
",0
178,"let result, temp be long integers with result assign to 0 and temp assign to 0
untill i assign to 0 to n exclusive, temp assign to 0
untill j assign to i to n exclusive, increment temp by arr array ofj 
increment result by temp
return result
declare integer main ( ), integer arr array of   assign to  1, 2, 3  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print Sum of SubArray : "", SubArraySum ( arr, n) and newline
return 0
","Sum of all Subarrays 
 Set 1 
 Simple C ++ program to compute sum of subarray elements ; Computes sum all sub - array ; Pick starting point ; Pick ending point ; sum subarray between current starting and ending points ; driver program to test above function
",1
179,"let result, temp be long integers with result assign to 0 and temp assign to 0
untill i assign to 0 to n exclusive, temp assign to 0
untill j assign to i to n exclusive, increment temp by arr array ofj 
increment result by temp
return result
declare integer main ( ), integer arr array of   assign to  1, 2, 3  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print Sum of SubArray : "", SubArraySum ( arr, n) and newline
return 0
","Program to check if input is an integer or a string 
 CPP program to check if a given string is a valid integer ; Returns true if s is a number else false ; Driver code ; Saving the input in a string ; Function returns 1 if all elements are in range '0-9' ; Function returns 0 if the input is not an integer
",0
180,"declare highestPowerof2 with integer n, p assign to ( integer ) log2 (n ) as arguments
return ( int ) pow ( 2, p )
declare integer main ( ) and integer n assign to 10
print highestPowerof2 (n )
return 0
","Highest power of 2 less than or equal to given number 
 C ++ program to find highest power of 2 smaller than or equal to n . ; Driver code
",1
181,"declare highestPowerof2 with integer n, p assign to ( integer ) log2 (n ) as arguments
return ( int ) pow ( 2, p )
declare integer main ( ) and integer n assign to 10
print highestPowerof2 (n )
return 0
","Convert X into Y by repeatedly multiplying X with 2 or appending 1 at the end 
 C ++ program untill the above approach ; Function to check if X can be converted to Y by multiplying X by 2 or appending 1 at the end ; Iterate until Y is at least X ; If Y is even ; If the last digit of Y is 1 ; Otherwise ; Check if X is equal to Y ; Driver Code
",0
182,"create constant integer MAX_CHAR with MAX_CHAR assign to 26
create struct Key with value freq
create character ch
declare boolean operator ( const Key & k ) const  return freq  k. freq
print
declare rearrangeString with string str as argument, returning integer n assign to length of str
count assign to integer with count assign to 0  0
untill i assign to 0 to n exclusive, increment count array of str array of i   -'a'   
create priority_queue  Key > pq
untill c assign to'a ', c assign to'z ', val assign to c -'a ', val assign to int with val assign to c -'a '
if count array of val  is true, push Key  count array of val , c  )
set   str to "" ""
prev assign to Key, -1, #, 0
untill pq is not empty ( ) Key k is equal to pq. top ( )
pop assign to pq. pop assign to pop
set str to str + k. ch
if prev is greater than 0 push ( prev )
decrement k. freq
set prev to k
if n is not str. length ( ), print Not valid String
else print str
declare integer main ( ), string str assign to "" bbbaa ""
rearrangeString ( str )
return 0
","Rearrange characters in a string such that no two adjacent are same 
 C ++ program to rearrange characters in a string so that no two adjacent characters are same . ; store frequency of character ; function untill priority_queue to store Key according to freq ; Function to rearrange character of a string so that no char repeat twice ; Store frequencies of all characters in string ; Insert all characters with their frequencies into a priority_queue ; ' str ' that will store resultant value ; work as the previous visited element initial previous element be . ( ' # ' and it ' s â– frequency â– ' - 1 ' ) ; traverse queue ; pop top element from queue and add it to string . ; IF frequency of previous character is less than zero that means it is useless , we need not to push it ; make current character as the previous ' char ' decrease frequency by ' one ' ; If length of the resultant string and original string is not same then string is not valid ; valid string ; Driver program to test above function
",1
183,"create constant integer MAX_CHAR with MAX_CHAR assign to 26
create struct Key with value freq
create character ch
declare boolean operator ( const Key & k ) const  return freq  k. freq
print
declare rearrangeString with string str as argument, returning integer n assign to length of str
count assign to integer with count assign to 0  0
untill i assign to 0 to n exclusive, increment count array of str array of i   -'a'   
create priority_queue  Key > pq
untill c assign to'a ', c assign to'z ', val assign to c -'a ', val assign to int with val assign to c -'a '
if count array of val  is true, push Key  count array of val , c  )
set   str to "" ""
prev assign to Key, -1, #, 0
untill pq is not empty ( ) Key k is equal to pq. top ( )
pop assign to pq. pop assign to pop
set str to str + k. ch
if prev is greater than 0 push ( prev )
decrement k. freq
set prev to k
if n is not str. length ( ), print Not valid String
else print str
declare integer main ( ), string str assign to "" bbbaa ""
rearrangeString ( str )
return 0
","Lexicographically smallest array after at 
 C ++ program to find lexicographically minimum value after k swaps . ; Modifies arr array of 0. . n - 1   to lexicographically smallest with k swaps . ; Set the position where we want to put the smallest integer ; If we exceed the Max swaps then terminate the loop ; Find the minimum value from i + 1 to max k or n ; Swap the elements from Minimum position we found till now to the i index ; Set the final value after swapping pos - i elements ; Driver code ; Function calling ; Print the final Array
",0
184,"aModM assign to unsigned integer with s, mod assign to unsigned integer with number assign to 0
untill i assign to 0 to length of s exclusive, set number to number * 10 + ( s array of i   - '0' ) )
set number to number modulo mod
return number
declare unsigned integer ApowBmodM ( string & a, unsigned integer b, unsigned integer m ) and unsigned integer ans assign to aModM ( a, m )
create unsigned integer mul with mul assign to ans
untill i assign to 1 to b exclusive, set ans to ( ans * mul ) modulo m
return ans
declare integer main ( ) and string a assign to ""987584345091051645734583954832576""
create unsigned integers b assign to 3 and m assign to 11
print ApowBmodM ( a, b, m )
return 0
","Find ( a to the power b ) % m where ' a ' is very large 
 C ++ program to find ( a to the power b ) mod m untill a large ' a ' ; utility function to calculate a % m ; ( s array of i   - '0' ) gives the digit value and untillm the number ; Returns find ( a to the power b ) % m ; Find a % m ; now multiply ans by b - 1 times and take mod with m ; Driver program to run the case
",1
185,"aModM assign to unsigned integer with s, mod assign to unsigned integer with number assign to 0
untill i assign to 0 to length of s exclusive, set number to number * 10 + ( s array of i   - '0' ) )
set number to number modulo mod
return number
declare unsigned integer ApowBmodM ( string & a, unsigned integer b, unsigned integer m ) and unsigned integer ans assign to aModM ( a, m )
create unsigned integer mul with mul assign to ans
untill i assign to 1 to b exclusive, set ans to ( ans * mul ) modulo m
return ans
declare integer main ( ) and string a assign to ""987584345091051645734583954832576""
create unsigned integers b assign to 3 and m assign to 11
print ApowBmodM ( a, b, m )
return 0
","Count of even and odd set bit with array element after XOR with K 
 C ++ program to count the set bits after taking XOR with a number K ; Function to store EVEN and odd variable ; Store the count of even and odd set bit ; Count the set bit using in built function ; Count of set - bit of K ; If y is odd then , count of even and odd set bit will be interchanged ; Else it will remain same as the original array ; Driver 's Code ; Function call to count even and odd
",0
186,"create struct Data x, y
print a newline
untill i assign to 0 to n exclusive, double term assign to f array of i  . y
untill j assign to 0 to n exclusive, term assign to term * ( xi - f array of j  . x ) / double ( f array of i  . x - f array of j  . x ) )
increment result by term
return result
declare integer main ( ) and Data f assign to  0, 2 , 1, 3 , 2, 12 , 5, 147
print Value of f ( 3 ) is : "" and interpolate ( f, 3, 5 )
return 0
","Lagrange 's Interpolation 
 C ++ program untill implementation of Lagrange 's Interpolation ; To represent a data point corresponding to x and y assign to f ( x ) ; function to interpolate the given data points using Lagrange 's untillmula xi corresponds to the new data point whose value is to be obtained n represents the number of known data points ; double result assign to 0 ; Initialize result ; Compute individual terms of above untillmula ; Add current term to result ; driver function to check the program ; creating an array of 4 known data points ; Using the interpolate function to obtain a data point corresponding to x assign to 3
",1
187,"create struct Data x, y
print a newline
untill i assign to 0 to n exclusive, double term assign to f array of i  . y
untill j assign to 0 to n exclusive, term assign to term * ( xi - f array of j  . x ) / double ( f array of i  . x - f array of j  . x ) )
increment result by term
return result
declare integer main ( ) and Data f assign to  0, 2 , 1, 3 , 2, 12 , 5, 147
print Value of f ( 3 ) is : "" and interpolate ( f, 3, 5 )
return 0
","Maximum difference between a pair of adjacent elements by excluding every element once 
 C ++ program untill the above approach ; Function to calculate maximum difference between adjacent elements excluding every array element once ; Traverse the array ; Stores the maximum diff ; Check untill maximum adjacent element ; Exclude current element ; Update maximum difference ; Update previous value ; Append the result into a vector ; Print the result ; Driver Code
",0
188,"declare SieveOfSundaram as integer (n )  integer nNew assign to (n - 1 ) / 2
marked assign to boolean array of size nNew + 1
set all contents of marked to false
untill i assign to 1 to nNew inclusive marked array of i + j + 2 * i * j   assign to true
if n is greater than 2 print 2 print "" ""
untill i assign to 1 to nNew inclusive, print 2 * i + 1 and "" ""
declare integer main (void ) and integer n assign to 20
call SieveOfSundaram ( n )
return 0
","Sieve of Sundaram to print all primes smaller than n 
 C ++ program to print primes smaller than n using Sieve of Sundaram . ; Prints all prime numbers smaller ; In general Sieve of Sundaram , produces primes smaller than ( 2 * x + 2 ) untill a number given number x . Since we want primes smaller than n , we reduce n to half ; This array is used to separate numbers of the untillm i + j + 2 ij from others where 1 <assign to i <assign to j ; Initialize all elements as not marked ; Main logic of Sundaram . Mark all numbers of the untillm i + j + 2 ij as true where 1 <assign to i <assign to j ; Since 2 is a prime number ; Print other primes . Remaining primes are of the untillm 2 * i + 1 such that marked array of i   is false . ; Driver program to test above
",1
189,"declare SieveOfSundaram as integer (n )  integer nNew assign to (n - 1 ) / 2
marked assign to boolean array of size nNew + 1
set all contents of marked to false
untill i assign to 1 to nNew inclusive marked array of i + j + 2 * i * j   assign to true
if n is greater than 2 print 2 print "" ""
untill i assign to 1 to nNew inclusive, print 2 * i + 1 and "" ""
declare integer main (void ) and integer n assign to 20
call SieveOfSundaram ( n )
return 0
","Percentage increase in volume of the sphere if radius is increased by a given percentage 
 C ++ program to find percentage increase in the volume of the sphere if radius is increased by a given percentage ; Driver code
",0
190,"declare constructArray with integers A, N, K, B, with B assign to integer array
totalXOR assign to integer with totalXOR assign to A array of 0    K
untill i assign to 0 to N exclusive, B array of i   assign to totalXOR  A array of i  
untill i assign to 0 to N exclusive, print B array of i  and "" ""
declare integer main ( ), integer array A ( ) assign to  13, 14, 10, 6 , K assign to 2
create integer N with N assign to sizeof ( A) / sizeof ( A array of 0   )
create constructArray ( A, N, K )
return 0
","Construct original array starting with K from an array of XOR of all elements except elements at same index 
 C ++ program untill the above approach ; Function to construct an array with each element equal to XOR of all array elements except the element at the same index ; Original array ; Stores Bitwise XOR of array ; Calculate XOR of all array elements ; Print the original array B array of   ; Driver Code ; Function Call
",1
191,"declare constructArray with integers A, N, K, B, with B assign to integer array
totalXOR assign to integer with totalXOR assign to A array of 0    K
untill i assign to 0 to N exclusive, B array of i   assign to totalXOR  A array of i  
untill i assign to 0 to N exclusive, print B array of i  and "" ""
declare integer main ( ), integer array A ( ) assign to  13, 14, 10, 6 , K assign to 2
create integer N with N assign to sizeof ( A) / sizeof ( A array of 0   )
create constructArray ( A, N, K )
return 0
","Count of ways to untillm 2 necklace from N beads containing N / 2 beads each 
 C ++ program untill the above approach ; Function to calculate factorial ; Function to count number of ways to make 2 necklace having exactly N / 2 beads if each bead is considered different ; Number of ways to choose N / 2 beads from N beads ; Number of ways to permute N / 2 beads ; Divide ans by 2 to remove repetitions ; Return ans ; Driver Code ; Given Input ; Function Call
",0
192,"declare extraElement with integers A array of  , B array of  , n, ans assign to 0
untill i assign to 0 to n exclusive, ans assign to A array of i  
untill i assign to 0 to n + 1 exclusive, ans assign to B array of i  
return ans
declare integer main ( ), integer A assign to  10, 15, 5  ; declare integer array A size  
declare integer array B assign to  10, 100, 15, 5
n assign to sizeof ( A ) / sizeof ( int )
print extraElement ( A, B, n )
return 0
","Find extra element in the second array 
 C ++ implementation of the approach ; Function to return the extra element in B array of   ; To store the result ; Find the XOR of all the element of array A array of   and array B array of   ; Driver code
",1
193,"declare extraElement with integers A array of  , B array of  , n, ans assign to 0
untill i assign to 0 to n exclusive, ans assign to A array of i  
untill i assign to 0 to n + 1 exclusive, ans assign to B array of i  
return ans
declare integer main ( ), integer A assign to  10, 15, 5  ; declare integer array A size  
declare integer array B assign to  10, 100, 15, 5
n assign to sizeof ( A ) / sizeof ( int )
print extraElement ( A, B, n )
return 0
","Count set bits in an integer 
 C ++ implementation of the approach ; Lookup table ; Function to initialise the lookup table ; To initially generate the table algorithmically ; Function to return the count of set bits in n ; Driver code ; Initialise the lookup table
",0
194,"declare integer hammingDistance with integers n1, n2 and x assign to n1 and n2
setBits assign to integer with setBits assign to 0
untill x > 0, setBits assign to setBits + x & 1
x is equal to x >> 1
return setBits
declare integer main ( ), integers n1, n2 assign to 14
print hammingDistance ( 9, 14 ) print newline
return 0
","Hamming distance between two Integers 
 C ++ implementation of above approach ; Function to calculate hamming distance ; Driver code
",1
195,"declare integer hammingDistance with integers n1, n2 and x assign to n1 and n2
setBits assign to integer with setBits assign to 0
untill x > 0, setBits assign to setBits + x & 1
x is equal to x >> 1
return setBits
declare integer main ( ), integers n1, n2 assign to 14
print hammingDistance ( 9, 14 ) print newline
return 0
","Tcefrep Numbers 
 C ++ implementation to check if N is a Tcefrep number ; Iterative function to reverse digits of num ; Function to calculate sum of all proper divisors num -- > given natural number ; Final result of summation of divisors ; find all divisors which divides ' num ' ; if ' i ' is divisor of ' num ' ; if both divisors are same then add it only once else add both ; Add 1 to the result as 1 is also a divisor ; Driver Code ; Given Number N ; Function Call
",0
196,"printSubsets is a void function with int arguments n and n, if i is a void, printSubsets and a new line
declare integer main ( ) and integer n assign to 9
printSubsets ( n )
return 0
","Print bitwise AND set of a number N 
 CPP program to print all bitwise subsets of N ( Naive approach ) ; function to find bitwise subsets Naive approach ; Driver Code
",1
197,"printSubsets is a void function with int arguments n and n, if i is a void, printSubsets and a new line
declare integer main ( ) and integer n assign to 9
printSubsets ( n )
return 0
","Longest subsequence from an array of pairs having first element increasing and second element decreasing . 
 C ++ program untill the above approach ; Recursive function to find the length of the longest subsequence of pairs whose first element is increasing and second is decreasing ; Base case ; Not include the current pair in the longest subsequence ; Including the current pair in the longest subsequence ; Driver Code ; Given Input ; Function Call
",0
198,"declare setBitNumber with integer n, k assign to ( integer ) ( log2 (n ) ) as arguments
return 1  k
declare integer main ( ) and integer n assign to 273
print setBitNumber ( n )
return 0
","Find most significant set bit of a number 
 CPP program to find MSB number untill given n . ; To find the position of the most significant set bit ; To return the the value of the number with set bit at k - th position ; Driver code
",1
199,"declare setBitNumber with integer n, k assign to ( integer ) ( log2 (n ) ) as arguments
return 1  k
declare integer main ( ) and integer n assign to 273
print setBitNumber ( n )
return 0
","Sum of absolute differences of indices of occurrences of each array element 
 C ++ program untill the above approach ; Function to find sum of differences of indices of occurrences of each unique array element ; Stores indices of each array element ; Store the indices ; Stores the sums ; Traverse the array ; Find sum untill each element ; Iterate over the Map ; Calculate sum of occurrences of arr array of i   ; Store sum untill current element ; Print answer untill each element ; Driver Code ; Given array ; Given size ; Function call
",0
200,"subset assign to integer with res assign to 0
sort ( ar, ar + n )
untill i assign to 0 to n exclusive, count assign to int with count assign to 1
untill i  n - 1 to n - 1 exclusive, increment count by 1
else break
res assign to max ( res, count )
return res
declare integer main ( ), integer arr assign to  5, 6, 9, 3, 4, 3, 4  ; declare integer array arr assign to  5, 6, 9, 3, 4, 3, 4  ; declare integer arr assign to  5, 6, 9, 3, 4  ; declare integer arr assign to
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print subset ( arr, n )
return 0
","Minimum number of subsets with distinct elements 
 A sorting based solution to find the minimum number of subsets of a set such that every subset contains distinct elements . ; Function to count subsets such that all subsets have distinct elements . ; Take input and initialize res assign to 0 ; Sort the array ; Traverse the input array and find maximum frequency ; For each number find its repetition / frequency ; Update res ; Driver code
",1
201,"subset assign to integer with res assign to 0
sort ( ar, ar + n )
untill i assign to 0 to n exclusive, count assign to int with count assign to 1
untill i  n - 1 to n - 1 exclusive, increment count by 1
else break
res assign to max ( res, count )
return res
declare integer main ( ), integer arr assign to  5, 6, 9, 3, 4, 3, 4  ; declare integer array arr assign to  5, 6, 9, 3, 4, 3, 4  ; declare integer arr assign to  5, 6, 9, 3, 4  ; declare integer arr assign to
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print subset ( arr, n )
return 0
","Sum of all proper divisors of a natural number 
 C ++ program to find sum of all divisors of a natural number ; Function to calculate sum of all proper divisors num -- > given natural number ; Final result of summation of divisors ; there will be no proper divisor ; find all divisors which divides ' num ' ; if ' i ' is divisor of ' num ' ; if both divisors are same then add it only once else add both ; Add 1 to the result as 1 is also a divisor ; Driver program to run the case
",0
202,"subset assign to int with subset assign to arr array of  , int n, desdered_map assign to int, int > mp
untill i assign to 0 to n exclusive, increment mp array of arr array of i   by 1
create integer res with res assign to 0
untill x assign to mp, res assign to max ( res, x. second )
return res
declare integer main ( ), integer arr assign to  5, 6, 9, 3, 4, 3, 4  ; declare integer array arr assign to  5, 6, 9, 3, 4, 3, 4  ; declare integer arr assign to  5, 6, 9, 3, 4  ; declare integer arr assign to
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print subset ( arr, n )
return 0
","Minimum number of subsets with distinct elements 
 A hashing based solution to find the minimum number of subsets of a set such that every subset contains distinct elements . ; Function to count subsets such that all subsets have distinct elements . ; Traverse the input array and store frequencies of elements ; Find the maximum value in map . ; Driver code
",1
203,"subset assign to int with subset assign to arr array of  , int n, desdered_map assign to int, int > mp
untill i assign to 0 to n exclusive, increment mp array of arr array of i   by 1
create integer res with res assign to 0
untill x assign to mp, res assign to max ( res, x. second )
return res
declare integer main ( ), integer arr assign to  5, 6, 9, 3, 4, 3, 4  ; declare integer array arr assign to  5, 6, 9, 3, 4, 3, 4  ; declare integer arr assign to  5, 6, 9, 3, 4  ; declare integer arr assign to
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print subset ( arr, n )
return 0
","Find a number K such that exactly K array elements are greater than or equal to K 
 C ++ program untill the above approach ; Function to find K untill which there are exactly K array elements greater than or equal to K ; Finding the largest array element ; Possible values of K ; Traverse the array ; If current array element is greater than or equal to i ; If i array elements are greater than or equal to i ; Otherwise ; Driver Code
",0
204,"create vector psquare with int value greater than psquare
untill i assign to 1 to i * i assign to N, push_back ( i * i )
return 1 if target is 0
if index is less than 0 target is less than 0, return 0
create integer inc with inc assign to countWays ( index, target - psquare array of index )
declare integer exc assign to countWays ( index - 1, target )
return inc + exc
declare integer main ( ) and integer N assign to 9
calcPsquare assign to calcPsquare assign to N
print countWays ( size of psquare - 1, N )
return 0
","Count ways to represent a number as sum of perfect squares 
 C ++ program untill the above approach ; Store perfect squares less than or equal to N ; Utility function to calculate perfect squares less than or equal to N ; Function to find the number of ways to represent a number as sum of perfect squares ; Handle the base cases ; Include the i - th index element ; Exclude the i - th index element ; Return the result ; Driver Code ; Given Input ; Precalculate perfect squares <assign to N ; Function Call
",1
205,"create vector psquare with int value greater than psquare
untill i assign to 1 to i * i assign to N, push_back ( i * i )
return 1 if target is 0
if index is less than 0 target is less than 0, return 0
create integer inc with inc assign to countWays ( index, target - psquare array of index )
declare integer exc assign to countWays ( index - 1, target )
return inc + exc
declare integer main ( ) and integer N assign to 9
calcPsquare assign to calcPsquare assign to N
print countWays ( size of psquare - 1, N )
return 0
","Maximum of smallest possible area that can get with exactly k cut of given rectangular 
 C ++ code untill Maximum of smallest possible area that can get with exactly k cut of given rectangular ; Utility Function ; untill the 1 st case ; untill the second case ; print final result ; driver code
",0
206,"create class TreeNode  public : integer data, size
create TreeNode * left
create TreeNode * right
print a newline
TreeNode * newNode ( integer data)  TreeNode * Node assign to new TreeNode ( )
Node -> data assign to data
set Node -> left to NULL
set Node -> right to NULL
return Node
pair  integer, integer > sumofsubtree ( TreeNode * root ), pair  integer, integer > p assign to make_pair ( 1, 0 )
if root -> left, pair  integers, integer > ptemp assign to sumofsubtree ( root -> left )
increment p. second by ptemp. first + ptemp. second
increment p by ptemp.first
if root -> right, pair  integers, integers > ptemp assign to sumofsubtree ( root -> right )
increment p. second by ptemp. first + ptemp. second
increment p by ptemp.first
set root -> size to p. first
return p
sum assign to integer with sum assign to 0
if root -> data is target, set sum to distancesum
if root -> left, set tempsum to distancesum - root -> left -> size + ( n - root -> left -> size )
distance ( root -> left, target, tempsum, n )
if root -> right, set tempsum to distancesum - root -> right -> size + ( n - root -> right -> size )
distance assign to root -> right, target, tempsum, n
declare integer main ( ), TreeNode * root assign to newNode ( 0 ) )
set root -> left to newNode ( 2 )
set root -> right to newNode ( 3 )
root -> left -> left assign to newNode ( 4 )
root -> left -> right assign to newNode ( 5 )
root -> right -> left assign to newNode ( 6 )
set root -> right -> right to newNode ( 7 )
root -> left -> left -> left assign to newNode ( 8 )
root -> left -> left -> right assign to newNode ( 9 )
create integer target with target assign to 3
create pair  int, integer > p assign to sumofsubtree ( root )
totalnodes assign to integer with totalnodes assign to p. first
distance ( root, target, p. second, totalnodes )
print sum
return 0
","Sum of distances of all nodes from a given node 
 C ++ program untill the above approach ; Structure of a binary tree node ; Function that allocates a new node with the given data and NULL to its left and right pointers ; Return newly created node ; Function to count the number of nodes in the left and right subtrees ; Initialize a pair that stores the pair { number of nodes , depth } ; Finding the number of nodes in the left subtree ; Find the number of nodes in the right subtree ; Filling up size field ; Stores the sum of distances of all nodes from the given node ; Function to find the total distance ; If target node matches with the current node ; If root -> left is not null ; Update sum ; Recur untill the left subtree ; If root -> right is not null ; Apply the untillmula given in the approach ; Recur untill the right subtree ; Driver Code ; Input tree ; Total number of nodes ; Print the sum of distances
",1
207,"create class TreeNode  public : integer data, size
create TreeNode * left
create TreeNode * right
print a newline
TreeNode * newNode ( integer data)  TreeNode * Node assign to new TreeNode ( )
Node -> data assign to data
set Node -> left to NULL
set Node -> right to NULL
return Node
pair  integer, integer > sumofsubtree ( TreeNode * root ), pair  integer, integer > p assign to make_pair ( 1, 0 )
if root -> left, pair  integers, integer > ptemp assign to sumofsubtree ( root -> left )
increment p. second by ptemp. first + ptemp. second
increment p by ptemp.first
if root -> right, pair  integers, integers > ptemp assign to sumofsubtree ( root -> right )
increment p. second by ptemp. first + ptemp. second
increment p by ptemp.first
set root -> size to p. first
return p
sum assign to integer with sum assign to 0
if root -> data is target, set sum to distancesum
if root -> left, set tempsum to distancesum - root -> left -> size + ( n - root -> left -> size )
distance ( root -> left, target, tempsum, n )
if root -> right, set tempsum to distancesum - root -> right -> size + ( n - root -> right -> size )
distance assign to root -> right, target, tempsum, n
declare integer main ( ), TreeNode * root assign to newNode ( 0 ) )
set root -> left to newNode ( 2 )
set root -> right to newNode ( 3 )
root -> left -> left assign to newNode ( 4 )
root -> left -> right assign to newNode ( 5 )
root -> right -> left assign to newNode ( 6 )
set root -> right -> right to newNode ( 7 )
root -> left -> left -> left assign to newNode ( 8 )
root -> left -> left -> right assign to newNode ( 9 )
create integer target with target assign to 3
create pair  int, integer > p assign to sumofsubtree ( root )
totalnodes assign to integer with totalnodes assign to p. first
distance ( root, target, p. second, totalnodes )
print sum
return 0
","Move all zeroes to end of array 
 Set 
 C ++ implementation to move all zeroes at the end of array ; function to move all zeroes at the end of array ; Count of non - zero elements ; Traverse the array . If arr array of i   is non - zero , then swap the element at index ' count ' with the element at index ' i ' ; function to print the array elements ; Driver program to test above
",0
208,"declare rearrangeArray with integers A array of  , B array of  , N, K as arguments, sorting ( B, B + N, greater  integer > ( ) )
create boolean flag with flag assign to true
untill i assign to 0 to N exclusive, if A array of i   + B array of i   > K, set flag to false
break loop
print - 1
else print B array of i   and "" ""
declare integer main ( ) and integer array A with size   assign to  1, 2, 3, 4, 2  ;
create integer B with B assign to  1, 2, 3, 1, 1  ;
create integer N with N assign to sizeof ( A) / sizeof ( A array of 0   )
create integer K with K assign to 5
create rearrangeArray ( A, B, N, K )
return 0
","Rearrange array such that sum of same indexed elements is atmost K 
 C ++ program untill the above approach ; Function to rearrange array such that sum of similar indexed elements does not exceed K ; Sort the array B array of   in descending order ; If condition fails ; Print the array ; Driver Code ; Given arrays
",1
209,"declare rearrangeArray with integers A array of  , B array of  , N, K as arguments, sorting ( B, B + N, greater  integer > ( ) )
create boolean flag with flag assign to true
untill i assign to 0 to N exclusive, if A array of i   + B array of i   > K, set flag to false
break loop
print - 1
else print B array of i   and "" ""
declare integer main ( ) and integer array A with size   assign to  1, 2, 3, 4, 2  ;
create integer B with B assign to  1, 2, 3, 1, 1  ;
create integer N with N assign to sizeof ( A) / sizeof ( A array of 0   )
create integer K with K assign to 5
create rearrangeArray ( A, B, N, K )
return 0
","Number of paths with exactly k coins 
 A Naive Recursive C ++ program to count paths with exactly ' k ' coins ; Recursive function to count paths with sum k from ( 0 , 0 ) to ( m , n ) ; Base cases ; ( m , n ) can be reached either through ( m - 1 , n ) or through ( m , n - 1 ) ; A wrapper over pathCountRec ( ) ; Driver program
",0
210,"declare countRows with int mat array of M  array of N  as arguments, returning integer, set count to 0
totalSum assign to integer with totalSum assign to 0
untill i assign to 0 to N exclusive, increment totalSum by mat array of i   array of j  
untill i assign to 0 to N exclusive, currSum assign to 0
untill j assign to 0 to M exclusive, increment currSum by mat array of i   array of j  
if currSum is greater than totalSum - currSum, increment count
print count
declare integer main ( ) and mat mat ( N   array of M   assign to  2, -1, 5 , -3, 0, -2 , 5, 1, 2
countRows is a new line
","Count rows with sum exceeding sum of the remaining Matrix 
 C ++ program to implement the above approach ; Function to count the number of rows whose sum exceeds the sum of elements of the remaining matrix ; To store the result ; Stores the total sum of the matrix elements ; Calculate the total sum ; Traverse to check untill each row ; Stores the sum of elements of the current row ; Calculate the sum of elements of the current row ; If sum of current row exceeds the sum of rest of the matrix ; Increase count ; Print the result ; Driver Code ; Given matrix ; Function Call
",1
211,"declare countRows with int mat array of M  array of N  as arguments, returning integer, set count to 0
totalSum assign to integer with totalSum assign to 0
untill i assign to 0 to N exclusive, increment totalSum by mat array of i   array of j  
untill i assign to 0 to N exclusive, currSum assign to 0
untill j assign to 0 to M exclusive, increment currSum by mat array of i   array of j  
if currSum is greater than totalSum - currSum, increment count
print count
declare integer main ( ) and mat mat ( N   array of M   assign to  2, -1, 5 , -3, 0, -2 , 5, 1, 2
countRows is a new line
","Maximum number of 2 x2 squares that can be fit inside a right isosceles triangle 
 C ++ program to count number of 2 x 2 squares in a right isosceles triangle ; removing the extra part we would always need ; Since each square has base of length of 2 ; Driver code
",0
212,"declare areElementsContiguous with integer arr array of  , integer n, max assign to * max_element ( arr, arr + n ) as arguments, returning boolean
min assign to integer with min assign to min_element ( arr, arr + n )
create integer m with m assign to max - min + 1
if m is greater than n, return false
visited assign to bool array of size m
set all contents of visited to false
untill i assign to 0 to n exclusive visited array of arr array of i   - min   assign to true
return false if visited array of i   is false
return true
declare integer main ( ) and integer arr array of   assign to  5, 2, 3, 6, 4, 4, 6, 6  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
if elementsContiguous ( arr, n ) is true, print Yes
else print No
return 0
","Check if array contains contiguous integers with duplicates allowed 
 C ++ implementation to check whether the array contains a set of contiguous integers ; function to check whether the array contains a set of contiguous integers ; Find maximum and minimum elements . ; There should be at least m elements in array to make them contiguous . ; Create a visited array and initialize false . ; Mark elements as true . ; If any element is not marked , all elements are not contiguous . ; Driver program
",1
213,"declare areElementsContiguous with integer arr array of  , integer n, max assign to * max_element ( arr, arr + n ) as arguments, returning boolean
min assign to integer with min assign to min_element ( arr, arr + n )
create integer m with m assign to max - min + 1
if m is greater than n, return false
visited assign to bool array of size m
set all contents of visited to false
untill i assign to 0 to n exclusive visited array of arr array of i   - min   assign to true
return false if visited array of i   is false
return true
declare integer main ( ) and integer arr array of   assign to  5, 2, 3, 6, 4, 4, 6, 6  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
if elementsContiguous ( arr, n ) is true, print Yes
else print No
return 0
","Difference between Insertion sort and Selection sort 
 C ++ program untill implementation of selection sort ; Function to implement the selection sort ; One by one move boundary of unsorted subarray ; Find the minimum element in unsorted array ; Swap the found minimum element with the first element ; Function to print an array ; Driver Code ; Function Call ; Print the array
",0
214,"declare areElementsContiguous with integer arr array of  , integer n as arguments, returning boolean, with int argument arr and int argument n, and int argument us
untill i assign to 0 to n exclusive, insert arr array of i   into us
count assign to integer with count assign to 1
curr_ele assign to integer with curr_ele assign to arr array of 0   - 1
untill find ( curr_ele ) is not us. end ( ) ) increment count
decrement curr_ele
set curr_ele to arr array of 0   + 1
untill find ( curr_ele ) is not us. end ( ) ) increment count
increment curr_ele
return ( count assign to ( integer ) ( us size ( ) ) )
declare integer main ( ) and integer arr array of   assign to  5, 2, 3, 6, 4, 4, 6, 6  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
if elementsContiguous ( arr, n ) is true, print Yes
else print No
return 0
","Check if array contains contiguous integers with duplicates allowed 
 C ++ implementation to check whether the array contains a set of contiguous integers ; Function to check whether the array contains a set of contiguous integers ; Storing elements of ' arr array of   ' in a hash table ' us ' ; as arr array of 0   is present in ' us ' ; starting with previous smaller element of arr array of 0   ; if ' curr _ ele ' is present in ' us ' ; increment count ; update 'curr_ele"" ; starting with next greater element of arr array of 0   ; if ' curr _ ele ' is present in ' us ' ; increment count ; update 'curr_ele"" ; returns true if array contains a set of contiguous integers else returns false ; Driver program to test above
",1
215,"declare areElementsContiguous with integer arr array of  , integer n as arguments, returning boolean, with int argument arr and int argument n, and int argument us
untill i assign to 0 to n exclusive, insert arr array of i   into us
count assign to integer with count assign to 1
curr_ele assign to integer with curr_ele assign to arr array of 0   - 1
untill find ( curr_ele ) is not us. end ( ) ) increment count
decrement curr_ele
set curr_ele to arr array of 0   + 1
untill find ( curr_ele ) is not us. end ( ) ) increment count
increment curr_ele
return ( count assign to ( integer ) ( us size ( ) ) )
declare integer main ( ) and integer arr array of   assign to  5, 2, 3, 6, 4, 4, 6, 6  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
if elementsContiguous ( arr, n ) is true, print Yes
else print No
return 0
","Print N lines of 4 numbers such that every pair among 4 numbers has a GCD K 
 C ++ implementation of the above approach ; Function to print N lines ; Iterate N times to print N lines ; Driver Code
",0
216,"declare longest with integers a array of  , n, k as arguments, updating_map, integers, integers > freq
create integers start, end, now, l with start assign to 0, end assign to 0, now assign to 0 and l assign to 0
untill i assign to 0 to n exclusive, increment freq array of a array of i     by 1
if freq array of a array of i   is 1 increment now
untill now > k, decrement freq array of a array of l  
if freq array of a array of l    is 0, then do now --
increment l
if i - l + 1 >assign to end - start + 1, end assign to i, start assign to l
untill i assign to start to end inclusive, print a array of i  and "" ""
declare integer main ( ) and integer array a with size   assign to 6, 5, 1, 2, 3, 2, 1, 4, 5
create integer n with n assign to sizeof ( a ) / sizeof ( a array of 0   )
create integer k with k assign to 3
a, n, k assign to longest
return 0
","Longest subarray not having more than K distinct elements 
 CPP program to find longest subarray with k or less distinct elements . ; function to print the longest sub - array ; mark the element visited ; if its visited first time , then increase the counter of distinct elements by 1 ; When the counter of distinct elements increases from k , then reduce it to k ; from the left , reduce the number of time of visit ; if the reduced visited time element is not present in further segment then decrease the count of distinct elements ; increase the subsegment mark ; check length of longest sub - segment when greater then previous best then change it ; print the longest sub - segment ; driver program to test the above function
",1
217,"declare longest with integers a array of  , n, k as arguments, updating_map, integers, integers > freq
create integers start, end, now, l with start assign to 0, end assign to 0, now assign to 0 and l assign to 0
untill i assign to 0 to n exclusive, increment freq array of a array of i     by 1
if freq array of a array of i   is 1 increment now
untill now > k, decrement freq array of a array of l  
if freq array of a array of l    is 0, then do now --
increment l
if i - l + 1 >assign to end - start + 1, end assign to i, start assign to l
untill i assign to start to end inclusive, print a array of i  and "" ""
declare integer main ( ) and integer array a with size   assign to 6, 5, 1, 2, 3, 2, 1, 4, 5
create integer n with n assign to sizeof ( a ) / sizeof ( a array of 0   )
create integer k with k assign to 3
a, n, k assign to longest
return 0
","Find largest d in array such that a + b + c assign to d 
 CPP Program to find the largest d such that d assign to a + b + c ; function to find largest d ; sort the array in ascending order ; iterating from backwards to find the required largest d ; since all four a , b , c , d should be distinct ; if the current combination of j , k , l in the set is equal to S array of i   return this value as this would be the largest d since we are iterating in descending order ; Driver Code
",0
218,"sortby is a boolean function with arguments int and int > & a, int > & b and int > & b, return a. first and b. first
return ( a. second  b. second )
kOverlap is a boolean function with vector  pair  int, int > > pairs, int k, vector  pair  int, int > > vec
untill i assign to 0 to size of pairs, increment i, push_back (  pairs array of i  . first, -1  )
push_back (  pairs array of i  . second, +1  )
sort vec. begin ( ), vec. end ( ) )
create stack  pair  integer, integer > > st
untill i assign to 0 to size of vec exclusive, pair  int, int > cur assign to vec array of i  
if cur. second is -1, push cur in st
else st. pop
if size of st is greater than or equal to k, return true
return false
declare integer variables main, vector, pair, integers with value of integers > > pairs
push_back ( make_pair ( 1, 3 ) ) )
push_back ( make_pair ( 2, 4 ) ) )
push_back ( make_pair ( 3, 5 ) ) )
push_back ( make_pair ( 7, 10 ) ) )
create integers n, k with n assign to size ( ) and k assign to 3
if kOverlap ( pairs, k ) is true, print Yes
else print No
return 0
","Check if any K ranges overlap at any point 
 C ++ implementation of the approach ; Comparator to sort the vector of pairs ; Function that returns true if any k segments overlap at any point ; Starting points are marked by - 1 and ending points by + 1 ; Sort the vector by first element ; Stack to store the overlaps ; Get the current element ; If it is the starting point ; Push it in the stack ; It is the ending point ; Pop an element from stack ; If more than k ranges overlap ; Driver code
",1
219,"sortby is a boolean function with arguments int and int > & a, int > & b and int > & b, return a. first and b. first
return ( a. second  b. second )
kOverlap is a boolean function with vector  pair  int, int > > pairs, int k, vector  pair  int, int > > vec
untill i assign to 0 to size of pairs, increment i, push_back (  pairs array of i  . first, -1  )
push_back (  pairs array of i  . second, +1  )
sort vec. begin ( ), vec. end ( ) )
create stack  pair  integer, integer > > st
untill i assign to 0 to size of vec exclusive, pair  int, int > cur assign to vec array of i  
if cur. second is -1, push cur in st
else st. pop
if size of st is greater than or equal to k, return true
return false
declare integer variables main, vector, pair, integers with value of integers > > pairs
push_back ( make_pair ( 1, 3 ) ) )
push_back ( make_pair ( 2, 4 ) ) )
push_back ( make_pair ( 3, 5 ) ) )
push_back ( make_pair ( 7, 10 ) ) )
create integers n, k with n assign to size ( ) and k assign to 3
if kOverlap ( pairs, k ) is true, print Yes
else print No
return 0
","Check whether the given number is Euclid Number or not 
 CPP program to check Euclid Number ; Function to generate prime numbers ; Create a boolean array "" prime array of 0 . . n   "" and initialize all entries it as true . A value in prime array of i   will finally be false if i is Not a prime , else true . ; If prime array of p   is not changed , then it is a prime ; Update all multiples of p ; store all prime numbers to vector ' arr ' ; Function to check the number untill Euclid Number ; Multiply next prime number and check if product + 1 assign to n holds or not ; Driver code ; Get the prime numbers ; Get n ; Check if n is Euclid Number ; Get n ; Check if n is Euclid Number
",0
220,"ptr assign to integer array of size 501
declare findSmallestRange with integer arr array of   array of N  , integer n, k, integers i, minval, maxval, minrange, minel, maxel, flag, minind
untill i assign to 0 to k inclusive, set ptr array of i   to 0
minrange assign to INT_MAX
untill 1 is true, set minind to -1
minval assign to INT_MAX
set maxval to INT_MIN
set flag to 0
untill i assign to 0 to k exclusive, if ptr array of i   is n, set flag to 1
break loop
if ptr array of i    n and arr array of i   array of ptr array of i      minval, set minind to i
minval assign to arr array of i   array of ptr array of i    
if ptr array of i   n and arr array of i   array of ptr array of i     > maxval, set maxval to arr array of i   array of ptr array of i    
if flag is true, break loop
increment ptr array of minind 
if maxval - minval is less than minrange, set minel to minval
set maxel to maxval
minrange assign to maxel - minel
printf is a new line with a new line called STRNEWLINE with a new line called minel and a new line called maxel
declare integer main ( ) and integer array arr with size N assign to  4, 7, 9, 12, 15 , 0, 8, 10, 14, 20 , 6, 12, 16, 30, 50                 0, 8, 10, 10, 14,
create integer k with k assign to sizeof ( arr ) / sizeof ( arr array of 0   )
call findSmallestRange ( arr, N, k )
return 0
","Find smallest range containing elements from k lists 
 C ++ program to finds out smallest range that includes elements from each of the given sorted lists . ; array untill storing the current index of list i ; This function takes an k sorted lists in the untillm of 2D array as an argument . It finds out smallest range that includes elements from each of the k lists . ; initializing to 0 index ; ; untill maintaining the index of list containing the minimum element ; iterating over all the list ; if every element of list array of i   is traversed then break the loop ; find minimum value among all the list elements pointing by the ptr array of   array ; update the index of the list ; find maximum value among all the list elements pointing by the ptr array of   array ; if any list exhaust we will not get any better answer , so break the untill loop ; updating the minrange ; Driver program to test above function
",1
221,"ptr assign to integer array of size 501
declare findSmallestRange with integer arr array of   array of N  , integer n, k, integers i, minval, maxval, minrange, minel, maxel, flag, minind
untill i assign to 0 to k inclusive, set ptr array of i   to 0
minrange assign to INT_MAX
untill 1 is true, set minind to -1
minval assign to INT_MAX
set maxval to INT_MIN
set flag to 0
untill i assign to 0 to k exclusive, if ptr array of i   is n, set flag to 1
break loop
if ptr array of i    n and arr array of i   array of ptr array of i      minval, set minind to i
minval assign to arr array of i   array of ptr array of i    
if ptr array of i   n and arr array of i   array of ptr array of i     > maxval, set maxval to arr array of i   array of ptr array of i    
if flag is true, break loop
increment ptr array of minind 
if maxval - minval is less than minrange, set minel to minval
set maxel to maxval
minrange assign to maxel - minel
printf is a new line with a new line called STRNEWLINE with a new line called minel and a new line called maxel
declare integer main ( ) and integer array arr with size N assign to  4, 7, 9, 12, 15 , 0, 8, 10, 14, 20 , 6, 12, 16, 30, 50                 0, 8, 10, 10, 14,
create integer k with k assign to sizeof ( arr ) / sizeof ( arr array of 0   )
call findSmallestRange ( arr, N, k )
return 0
","Remove an element to maximize the GCD of the given array 
 C ++ implementation of the above approach ; Function to return the maximized gcd after removing a single element from the given array ; Prefix and Suffix arrays ; Single state dynamic programming relation untill storing gcd of first i elements from the left in Prefix array of i   ; Initializing Suffix array ; Single state dynamic programming relation untill storing gcd of all the elements having greater than or equal to i in Suffix array of i   ; If first or last element of the array has to be removed ; If any other element is replaced ; Return the maximized gcd ; Driver code
",0
222,"declare findLargestd with integers S array of  , n, found assign to false
sort S, S + n
untill i assign to n - 1 to 0 inclusive, continue
untill k assign to j + 1 to n exclusive, if i is k, continue
untill l assign to k + 1 to n exclusive, if i is l, continue
if S array of i   is S array ofj   + S array of k   + S array of l  , found assign to true
return S array of i  
if found is false, return INT_MIN
declare integer main ( ), integer S assign to  2, 3, 5, 7, 12  ;
create integer n with n assign to sizeof ( S ) / sizeof ( S array of 0   )
create integer ans with ans assign to findLargestd ( S, n )
if ans is INT_MIN print No Solution
else print Largest d so that a + b + "" c assign to d is "", ans
return 0
","Find largest d in array such that a + b + c assign to d 
 CPP Program to find the largest d such that d assign to a + b + c ; function to find largest d ; sort the array in ascending order ; iterating from backwards to find the required largest d ; since all four a , b , c , d should be distinct ; if the current combination of j , k , l in the set is equal to S array of i   return this value as this would be the largest d since we are iterating in descending order ; Driver Code
",1
223,"declare findLargestd with integers S array of  , n, found assign to false
sort S, S + n
untill i assign to n - 1 to 0 inclusive, continue
untill k assign to j + 1 to n exclusive, if i is k, continue
untill l assign to k + 1 to n exclusive, if i is l, continue
if S array of i   is S array ofj   + S array of k   + S array of l  , found assign to true
return S array of i  
if found is false, return INT_MIN
declare integer main ( ), integer S assign to  2, 3, 5, 7, 12  ;
create integer n with n assign to sizeof ( S ) / sizeof ( S array of 0   )
create integer ans with ans assign to findLargestd ( S, n )
if ans is INT_MIN print No Solution
else print Largest d so that a + b + "" c assign to d is "", ans
return 0
","Check if a line at 45 degree can divide the plane into two equal weight parts 
  ; Checking if a plane can be divide by a line at 45 degrees such that weight sum is equal ; Rotating each point by 45 degrees and calculating prefix sum . Also , finding maximum and minimum x coordinates ; storing weight sum upto x - y point ; Finding prefix sum ; Line passes through i , so it neither falls left nor right . ; Driven Program
",0
224,"declare findFourElements with integer arr array of  , integer n as arguments, pair  integers, integers > > mp
untill i assign to 0 to n - 1 exclusive, increment i by 1, mp array of arr array ofi  + arr array ofj    assign to  i, j  i
d assign to integer with d assign to INT_MIN
untill i assign to 0 to n - 1 exclusive, abs_diff assign to abs ( arr array of i   - arr array of j   )
if mp. find ( abs_diff )not equal to mp. end ( ) pair  int, int > p assign to mp array of abs_diff  
if p. first is not i and p. first is not j and p. second is not i and p. second is not j, set d to max ( d, max ( arr array of i  , arr array of j   ) )
return d
declare integer main ( ), integer arr array of   assign to  2, 3, 5, 7, 12  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create integer res with res assign to findFourElements ( arr, n )
if res is INT_MIN print No Solution
else print res
return 0
","Find largest d in array such that a + b + c assign to d 
 A hashing based CPP program to find largest d such that a + b + c assign to d . ; The function finds four elements with given sum X ; Store sums ( a + b ) of all pairs ( a , b ) in a hash table ; Traverse through all pairs and find ( d - c ) is present in hash table ; If d - c is present in hash table , ; Making sure that all elements are distinct array elements and an element is not considered more than once . ; Driver program to test above function
",1
225,"declare findFourElements with integer arr array of  , integer n as arguments, pair  integers, integers > > mp
untill i assign to 0 to n - 1 exclusive, increment i by 1, mp array of arr array ofi  + arr array ofj    assign to  i, j  i
d assign to integer with d assign to INT_MIN
untill i assign to 0 to n - 1 exclusive, abs_diff assign to abs ( arr array of i   - arr array of j   )
if mp. find ( abs_diff )not equal to mp. end ( ) pair  int, int > p assign to mp array of abs_diff  
if p. first is not i and p. first is not j and p. second is not i and p. second is not j, set d to max ( d, max ( arr array of i  , arr array of j   ) )
return d
declare integer main ( ), integer arr array of   assign to  2, 3, 5, 7, 12  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create integer res with res assign to findFourElements ( arr, n )
if res is INT_MIN print No Solution
else print res
return 0
","Largest smaller number possible using only one swap operation 
 C ++ program to find the largest smaller number by swapping one digit . ; Returns largest possible number with one swap such that the number is smaller than str . It is assumed that there are leading 0 s . ; Traverse from right until we find a digit which is greater than its next digit . For example , in 34125 , our index is 4. ; We can also use binary search here as digits after index are sorted in increasing order . Find the biggest digit in the right of arr array of index   which is smaller than arr array of index   ; If index is - 1 i . e . digits are in increasing order . ; Swap both values ; Drivers code
",0
226,"CountMaximum assign to integer with arr array of  , n, k assign to integer, sort ( arr, arr + n )
declare integers sum assign to 0 and count assign to 0
untill i assign to 0 to n exclusive, add arr array of i   to sum
if sum is greater than k, break loop
increment count
return count
declare integer main ( ), integer arr assign to  30, 30, 10, 10, 10  ; declare integer array arr size   assign to  30, 30, 30, 10, 10  ; declare integer arr assign to  30, 30, 10, 10  ; declare integer arr assign to  30, 30, 10, 10  ; declare integer arr assign to  30, 30, 10
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create integer k with k assign to 50
print CountMaximum ( arr, n, k )
return 0
","Maximize count of elements that can be selected having minimum difference between their sum and K 
 C ++ implementation of the above approach ; Function to count maximum number of elements that can be selected ; Sort the array ; Traverse the array ; Add current element to the sum ; IF sum exceeds k ; Increment count ; Return the count ; Driver Code ; Function call
",1
227,"CountMaximum assign to integer with arr array of  , n, k assign to integer, sort ( arr, arr + n )
declare integers sum assign to 0 and count assign to 0
untill i assign to 0 to n exclusive, add arr array of i   to sum
if sum is greater than k, break loop
increment count
return count
declare integer main ( ), integer arr assign to  30, 30, 10, 10, 10  ; declare integer array arr size   assign to  30, 30, 30, 10, 10  ; declare integer arr assign to  30, 30, 10, 10  ; declare integer arr assign to  30, 30, 10, 10  ; declare integer arr assign to  30, 30, 10
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create integer k with k assign to 50
print CountMaximum ( arr, n, k )
return 0
","Lagrange 's Interpolation 
 C ++ program untill implementation of Lagrange 's Interpolation ; To represent a data point corresponding to x and y assign to f ( x ) ; function to interpolate the given data points using Lagrange 's untillmula xi corresponds to the new data point whose value is to be obtained n represents the number of known data points ; double result assign to 0 ; Initialize result ; Compute individual terms of above untillmula ; Add current term to result ; driver function to check the program ; creating an array of 4 known data points ; Using the interpolate function to obtain a data point corresponding to x assign to 3
",0
228,"declare leftRotatebyOne with integers arr array of  , n, temp assign to arr array of 0  , i
untill i assign to 0 to n - 1 exclusive, arr array of i   assign to arr array of i + 1  
set arr array of n - 1   to temp
untill i assign to 0 to d exclusive, leftRotatebyOne ( arr, n)
printArray is a void function with int arguments arr array of   and n, print ( int i assign to 0 ; i  n ; i ++ ) print arr array of i   print "" ""
declare integer main ( ) and integer arr array of   assign to  1, 2, 3, 4, 5, 6, 7
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
leftRotate ( arr, 2, n )
printArray ( arr, n )
return 0
","Program untill array rotation 
 C ++ program to rotate an array by d elements ; Function to left Rotate arr array of   of size n by 1 ; Function to left rotate arr array of   of size n by d ; utility function to print an array ; Driver program to test above functions
",1
229,"declare leftRotatebyOne with integers arr array of  , n, temp assign to arr array of 0  , i
untill i assign to 0 to n - 1 exclusive, arr array of i   assign to arr array of i + 1  
set arr array of n - 1   to temp
untill i assign to 0 to d exclusive, leftRotatebyOne ( arr, n)
printArray is a void function with int arguments arr array of   and n, print ( int i assign to 0 ; i  n ; i ++ ) print arr array of i   print "" ""
declare integer main ( ) and integer arr array of   assign to  1, 2, 3, 4, 5, 6, 7
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
leftRotate ( arr, 2, n )
printArray ( arr, n )
return 0
","Fibonacci Cube Graph 
 CPP code to find vertices in a fibonacci cube graph of order n ; function to find fibonacci number ; function untill finding number of vertices in fibonacci cube graph ; return fibonacci number untill f ( n + 2 ) ; driver program
",0
230,"declare partSort with integer arr array of  , N, a, b, l assign to min ( a, b ) as arguments, returning void
create integer r with r assign to max ( a, b )
create integer temp array of r - l + 1  
create integer j with j assign to 0
untill i assign to l to r inclusive, temp array ofj   assign to arr array of i  
increment j
sort temp, temp + r - l + 1
set j to 0
untill i assign to l to r inclusive, arr array of i   assign to temp array of j  
increment j
untill i assign to 0 to N exclusive, print arr array of i  and "" ""
declare integer main ( ), integer arr assign to  7, 8, 4, 5, 2  ;
a assign to integer with a assign to 1
b assign to integer with b assign to 4
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
partSort is a new function
return 0
","Sort the array in a given index range 
 C ++ program to sort the array in a given index range ; Function to sort the elements of the array from index a to index b ; Variables to store start and end of the index range ; Temporary array ; Sort the temporary array ; Modifying original array with temporary array elements ; Print the modified array ; Driver code ; length of the array
",1
231,"declare partSort with integer arr array of  , N, a, b, l assign to min ( a, b ) as arguments, returning void
create integer r with r assign to max ( a, b )
create integer temp array of r - l + 1  
create integer j with j assign to 0
untill i assign to l to r inclusive, temp array ofj   assign to arr array of i  
increment j
sort temp, temp + r - l + 1
set j to 0
untill i assign to l to r inclusive, arr array of i   assign to temp array of j  
increment j
untill i assign to 0 to N exclusive, print arr array of i  and "" ""
declare integer main ( ), integer arr assign to  7, 8, 4, 5, 2  ;
a assign to integer with a assign to 1
b assign to integer with b assign to 4
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
partSort is a new function
return 0
","Minimum operations to make sum of neighbouring elements <assign to X 
 C ++ implementation of the approach ; Function to return the minimum number of operations required ; To store total operations required ; First make all elements equal to x which are currenctly greater ; Left scan the array ; Update the current element such that neighbouring sum is < x ; Driver code
",0
232,"sortByRow is a void function with int arguments mat array of   array of MAX_SIZE   and n, boolean descending, if descending is true, sort ( mat array of i  , mat array of i   + n, greater  int > ( ) ) )
else sort mat array of i  , mat array of i   + n
untill i assign to 0 to n exclusive, swap mat array of i   array of j   and mat array of j   array of i   )
sortMatRowAndColWise is a void function with mat, MAX_SIZE elements and sortByRow elements with mat, n, true elements
transpose mat, n
sortByRow ( mat, n, false )
transpose mat, n
printMat is a void function with int arguments mat array of   array of MAX_SIZE   and n, and untill i assign to 0 to n exclusive, print mat array of i   array of j   and "" ""
print newline
declare integer main ( ) and integer n assign to 3
create integer mat with mat assign to n, MAX_SIZE assign to  3, 2, 1 , 9, 8, 7 , 6, 5, 4
print Original Matrix : STRNEWLINE
printMat is a new line
sortMatRowAndColWise ( mat, n )
print Matrix After Sorting :
printMat is a new line
return 0
","Sorting rows of matrix in descending order followed by columns in ascending order 
 C ++ implementation to sort the rows of matrix in descending order followed by sorting the columns in ascending order ; function to sort each row of the matrix according to the order specified by descending . ; function to find transpose of the matrix ; swapping element at index ( i , j ) by element at index ( j , i ) ; function to sort the matrix row - wise and column - wise ; sort rows of mat array of   array of   in descending order ; get transpose of mat array of   array of   ; again sort rows of mat array of   array of   in ascending order . ; again get transpose of mat array of   array of   ; function to print the matrix ; Driver code
",1
233,"sortByRow is a void function with int arguments mat array of   array of MAX_SIZE   and n, boolean descending, if descending is true, sort ( mat array of i  , mat array of i   + n, greater  int > ( ) ) )
else sort mat array of i  , mat array of i   + n
untill i assign to 0 to n exclusive, swap mat array of i   array of j   and mat array of j   array of i   )
sortMatRowAndColWise is a void function with mat, MAX_SIZE elements and sortByRow elements with mat, n, true elements
transpose mat, n
sortByRow ( mat, n, false )
transpose mat, n
printMat is a void function with int arguments mat array of   array of MAX_SIZE   and n, and untill i assign to 0 to n exclusive, print mat array of i   array of j   and "" ""
print newline
declare integer main ( ) and integer n assign to 3
create integer mat with mat assign to n, MAX_SIZE assign to  3, 2, 1 , 9, 8, 7 , 6, 5, 4
print Original Matrix : STRNEWLINE
printMat is a new line
sortMatRowAndColWise ( mat, n )
print Matrix After Sorting :
printMat is a new line
return 0
","Closest sum partition ( into two subsets ) of numbers from 1 to n 
 C ++ implementation of the approach ; Function to return the minimum required absolute difference ; Driver code
",0
234,"declare pushZerosToEnd with integer arr array of  , integer n, set count to 0
untill i assign to 0 to n exclusive, if arr array of i   is not 0, increment count by 1
untill count  n, arr array of count ++   assign to 0
declare integer main ( ) and integer array arr with arr assign to  1, 9, 8, 4, 0, 0, 2, 7, 0, 6, 0, 9
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
pushZerosToEnd ( arr, n )
print Array after pushing all zeros to end of array : STRNEWLINE
untill i assign to 0 to n exclusive, print arr array of i   and "" ""
return 0
","Move all zeroes to end of array 
 A C ++ program to move all zeroes at the end of array ; Function which pushes all zeros to end of an array . ; Count of non - zero elements ; Traverse the array . If element encountered is non - zero , then replace the element at index ' count ' with this element ; here count is ; incremented Now all non - zero elements have been shifted to front and ' count ' is set as index of first 0. Make all elements 0 from count to end . ; Driver program to test above function
",1
235,"declare pushZerosToEnd with integer arr array of  , integer n, set count to 0
untill i assign to 0 to n exclusive, if arr array of i   is not 0, increment count by 1
untill count  n, arr array of count ++   assign to 0
declare integer main ( ) and integer array arr with arr assign to  1, 9, 8, 4, 0, 0, 2, 7, 0, 6, 0, 9
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
pushZerosToEnd ( arr, n )
print Array after pushing all zeros to end of array : STRNEWLINE
untill i assign to 0 to n exclusive, print arr array of i   and "" ""
return 0
","Count triples with Bitwise AND equal to Zero 
 C ++ program untill the above approach ; Function to find the number of triplets whose Bitwise AND is 0. ; Stores the count of triplets having bitwise AND equal to 0 ; Stores frequencies of all possible A array of i   & A array of j   ; Traverse the array ; Update frequency of Bitwise AND of all array elements with a ; Traverse the array ; Iterate the map ; If bitwise AND of triplet is zero , increment cnt ; Return the number of triplets whose Bitwise AND is 0. ; Driver Code ; Input Array ; Function Call
",0
236,"declare moveZerosToEnd with integer arr array of  , integer n, set count to 0
untill i assign to 0 to n exclusive swap ( arr array of i  not equal to 0 ) if arr array of count ++  , arr array of i   )
printArray is a void function with int arguments arr array of   and n, print ( int i assign to 0 ; i  n ; i ++ ) print arr array of i   print "" ""
declare integer main with 0 and integer array arr with size   assign to 0, 1, 9, 8, 4, 0, 0, 2, 7, 0, 6, 0, 9
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print Original array :
printArray ( arr, n )
call moveZerosToEnd ( arr, n)
print "" Modified array : "" printArray ( arr, n )
return 0
","Move all zeroes to end of array 
 Set 
 C ++ implementation to move all zeroes at the end of array ; function to move all zeroes at the end of array ; Count of non - zero elements ; Traverse the array . If arr array of i   is non - zero , then swap the element at index ' count ' with the element at index ' i ' ; function to print the array elements ; Driver program to test above
",1
237,"declare moveZerosToEnd with integer arr array of  , integer n, set count to 0
untill i assign to 0 to n exclusive swap ( arr array of i  not equal to 0 ) if arr array of count ++  , arr array of i   )
printArray is a void function with int arguments arr array of   and n, print ( int i assign to 0 ; i  n ; i ++ ) print arr array of i   print "" ""
declare integer main with 0 and integer array arr with size   assign to 0, 1, 9, 8, 4, 0, 0, 2, 7, 0, 6, 0, 9
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print Original array :
printArray ( arr, n )
call moveZerosToEnd ( arr, n)
print "" Modified array : "" printArray ( arr, n )
return 0
","Count ways of choosing a pair with maximum difference 
 CPP Code to find no . of Ways of choosing a pair with maximum difference ; To find minimum and maximum of the array ; to find the count of minimum and maximum elements ; Count variables ; condition untill all elements equal ; Driver code
",0
238,"declare pushZerosToEnd with integer arr array of  , integer n, set count to 0
untill i assign to 0 to n exclusive, if arr array of i   is not 0, increment count by 1
untill count  n, arr array of count ++   assign to 0
if n is 1 return void modifyAndRearrangeArr
untill i assign to 0 to n - 1 exclusive, if arr array of i   is not 0 and arr array of i   is arr array of i + 1   ), arr array of i   assign to 2 * arr array of i  
arr array of i + 1   assign to 0
increment i
print pushZerosToEnd ( arr, n)
printArray is a void function with int arguments arr array of   and n, print ( int i assign to 0 ; i  n ; i ++ ) print arr array of i   print "" ""
declare integer main ( ) and integer array arr with size   assign to 0, 2, 2, 2, 0, 6, 6, 0, 0, 8
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print Original array :
printArray ( arr, n )
modifyAndRearrangeArr ( arr, n )
print "" Modified array : "" printArray ( arr, n )
return 0
","Double the first element and move zero to end 
 C ++ implementation to rearrange the array elements after modification ; function which pushes all zeros to end of an array . ; Count of non - zero elements ; Traverse the array . If element encountered is non - zero , then replace the element at index ' count ' with this element ; here count is incremented ; Now all non - zero elements have been shifted to front and ' count ' is set as index of first 0. Make all elements 0 from count to end . ; function to rearrange the array elements after modification ; if ' arr array of   ' contains a single element only ; traverse the array ; if true , peruntillm the required modification ; double current index value ; put 0 in the next index ; increment by 1 so as to move two indexes ahead during loop iteration ; push all the zeros at the end of ' arr array of   ' ; function to print the array elements ; Driver program to test above
",1
239,"declare pushZerosToEnd with integer arr array of  , integer n, set count to 0
untill i assign to 0 to n exclusive, if arr array of i   is not 0, increment count by 1
untill count  n, arr array of count ++   assign to 0
if n is 1 return void modifyAndRearrangeArr
untill i assign to 0 to n - 1 exclusive, if arr array of i   is not 0 and arr array of i   is arr array of i + 1   ), arr array of i   assign to 2 * arr array of i  
arr array of i + 1   assign to 0
increment i
print pushZerosToEnd ( arr, n)
printArray is a void function with int arguments arr array of   and n, print ( int i assign to 0 ; i  n ; i ++ ) print arr array of i   print "" ""
declare integer main ( ) and integer array arr with size   assign to 0, 2, 2, 2, 0, 6, 6, 0, 0, 8
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print Original array :
printArray ( arr, n )
modifyAndRearrangeArr ( arr, n )
print "" Modified array : "" printArray ( arr, n )
return 0
","Find largest d in array such that a + b + c assign to d 
 A hashing based CPP program to find largest d such that a + b + c assign to d . ; The function finds four elements with given sum X ; Store sums ( a + b ) of all pairs ( a , b ) in a hash table ; Traverse through all pairs and find ( d - c ) is present in hash table ; If d - c is present in hash table , ; Making sure that all elements are distinct array elements and an element is not considered more than once . ; Driver program to test above function
",0
240,"printArray is a void function with int arguments arr array of   and n, and untill i assign to 0 to n exclusive printf ( "" % d "", arr array of i   )
printf is a new line
create void RearrangePosNeg ( int arr array of  , int n ), int key, j
untill i assign to 1 to n exclusive, set key to arr array of i  
if key is greater than 0, continue
set j to i - 1
untill j >assign to 0 and arr array ofj   > 0, arr array of j + 1   assign to arr array ofj  
set j to j - 1
arr array of j + 1   assign to key
declare integer main with a value assign to -12, 11, -13, -5, 6, -7, 5, -3, -6
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
call RearrangePosNeg ( arr, n )
printArray ( arr, n )
return 0
","Rearrange positive and negative numbers with constant extra space 
 C ++ program to Rearrange positive and negative numbers in a array ; A utility function to print an array of size n ; Function to Rearrange positive and negative numbers in a array ; if current element is positive do nothing ; if current element is negative , shift positive elements of arr array of 0. . i - 1   , to one position to their right ; Put negative element at its right position ; Driver program to test above functions
",1
241,"printArray is a void function with int arguments arr array of   and n, and untill i assign to 0 to n exclusive printf ( "" % d "", arr array of i   )
printf is a new line
create void RearrangePosNeg ( int arr array of  , int n ), int key, j
untill i assign to 1 to n exclusive, set key to arr array of i  
if key is greater than 0, continue
set j to i - 1
untill j >assign to 0 and arr array ofj   > 0, arr array of j + 1   assign to arr array ofj  
set j to j - 1
arr array of j + 1   assign to key
declare integer main with a value assign to -12, 11, -13, -5, 6, -7, 5, -3, -6
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
call RearrangePosNeg ( arr, n )
printArray ( arr, n )
return 0
","Find nth number that contains the digit k or divisible by k . 
 C ++ program to find nth number that contains the digit k or divisible by k . ; Function untill checking if digit k is in n or not ; finding remainder ; if digit found ; Function untill finding nth number ; since k is the first which satisfy the criteria , so consider it in count making count assign to 1 and starting from i assign to k + 1 ; checking that the number contain k digit or divisible by k ; Driver code
",0
242,"printArray is a void function with int arguments A and size that returns 0 and i is less than size printArray, print A and "" ""
print newline
void reverse ( int arr array of  , int l, int r ) if l is less than r, swap ( arr array of l  , arr array of r   )
reverse ( arr, l, -- r)
merge assign to integer with arr assign to l, m, r assign to integer, i assign to l
create integer j with j assign to m + 1
untill i assign to m and arr array of i    0, increment i
untill j assign to r and arr array of j    0, increment j
reverse ( arr, i, m )
reverse ( arr, m + 1, j - 1)
reverse ( arr, i, j - 1 )
if l is less than r, set m to l + ( r - l ) / 2
call RearrangePosNeg ( arr, l, m )
call RearrangePosNeg ( arr, m + 1, r )
merge arr, l, m, r
declare integer main with a value assign to -12, 11, -13, -5, 6, -7, 5, -3, -6
create integer arr_size with arr_size assign to sizeof ( arr) / sizeof ( arr array of 0   )
call RearrangePosNeg ( arr, 0, arr_size - 1 )
printArray ( arr, arr_size )
return 0
","Rearrange positive and negative numbers with constant extra space 
 C ++ program to Rearrange positive and negative numbers in a array ; Function to print an array ; Function to reverse an array . An array can be reversed in O ( n ) time and O ( 1 ) space . ; Merges two subarrays of arr array of   . First subarray is arr array of l . . m   Second subarray is arr array of m + 1. . r   ; Initial index of 1 st subarray ; Initial index of IInd ; arr array of i . . m   is positive ; arr array of j . . r   is positive reverse positive part of left sub - array ( arr array of i . . m   ) ; reverse negative part of right sub - array ( arr array of m + 1. . j - 1   ) ; reverse arr array of i . . j - 1   ; Function to Rearrange positive and negative numbers in a array ; Same as ( l + r ) / 2 , but avoids overflow untill large l and h ; Sort first and second halves ; Driver code
",1
243,"printArray is a void function with int arguments A and size that returns 0 and i is less than size printArray, print A and "" ""
print newline
void reverse ( int arr array of  , int l, int r ) if l is less than r, swap ( arr array of l  , arr array of r   )
reverse ( arr, l, -- r)
merge assign to integer with arr assign to l, m, r assign to integer, i assign to l
create integer j with j assign to m + 1
untill i assign to m and arr array of i    0, increment i
untill j assign to r and arr array of j    0, increment j
reverse ( arr, i, m )
reverse ( arr, m + 1, j - 1)
reverse ( arr, i, j - 1 )
if l is less than r, set m to l + ( r - l ) / 2
call RearrangePosNeg ( arr, l, m )
call RearrangePosNeg ( arr, m + 1, r )
merge arr, l, m, r
declare integer main with a value assign to -12, 11, -13, -5, 6, -7, 5, -3, -6
create integer arr_size with arr_size assign to sizeof ( arr) / sizeof ( arr array of 0   )
call RearrangePosNeg ( arr, 0, arr_size - 1 )
printArray ( arr, arr_size )
return 0
","Print all numbers in given range having digits in strictly increasing order 
 C ++ program untill the above approach ; Function to print all numbers in the range array of L , R   having digits in strictly increasing order ; Iterate over the range ; Iterate over the digits ; Check if the current digit is >assign to the previous digit ; If the digits are in ascending order ; Driver Code ; Given range L and R ; Function Call
",0
244,"in the function RearrangePosNeg that takes arr array of   and n and returns integer i assign to 0
create integer j with j assign to n - 1
untill true, increment i untill arr array of i   is less than 0 and i is less than n
untill arr array ofj  > 0 and j >assign to 0, decrement j
if i is less than j, temp assign to arr array of i  
arr array of i   assign to arr array of j  
set arr array ofj   to temp
else break
declare integer main with a value assign to -12, 11, -13, -5, 6, -7, 5, -3, -6
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
call RearrangePosNeg ( arr, n )
untill i assign to 0 to n exclusive, print arr array of i   and "" ""
return 0
","Rearrange positive and negative numbers with constant extra space 
 C ++ implementation of the above approach ; Loop until arr array of i   < 0 and still inside the array ; Loop until arr array of j   > 0 and still inside the array ; if i is less than j ; Driver Code
",1
245,"in the function RearrangePosNeg that takes arr array of   and n and returns integer i assign to 0
create integer j with j assign to n - 1
untill true, increment i untill arr array of i   is less than 0 and i is less than n
untill arr array ofj  > 0 and j >assign to 0, decrement j
if i is less than j, temp assign to arr array of i  
arr array of i   assign to arr array of j  
set arr array ofj   to temp
else break
declare integer main with a value assign to -12, 11, -13, -5, 6, -7, 5, -3, -6
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
call RearrangePosNeg ( arr, n )
untill i assign to 0 to n exclusive, print arr array of i   and "" ""
return 0
","Bubble Sort 
 Optimized implementation of Bubble sort ; An optimized version of Bubble Sort ; swap arr array of j   and arr array of j + 1   ; IF no two elements were swapped by inner loop , then break ; Function to print an array ; Driver program to test above functions
",0
246,"if N modulo 2 is 1, print A
else print B
declare integer main ( ), integer arr assign to  24, 45, 45, 24  ; declare integer array arr size   assign to  24, 45, 45, 24
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
winner of arr, N
","Find the player to be able to replace the last element that can be replaced by its divisors 
 C ++ program untill the above approach ; Function to find the winner of the game played based on given conditions ; A wins if size of array is odd ; Otherwise , B wins ; Driver Code ; Input array ; Size of the array
",1
247,"if N modulo 2 is 1, print A
else print B
declare integer main ( ), integer arr assign to  24, 45, 45, 24  ; declare integer array arr size   assign to  24, 45, 45, 24
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
winner of arr, N
","Minimize K to let Person A consume at least ceil ( N / ( M + 1 ) ) candies based on given rules 
 C ++ program untill the above approach ; Function to check if the value of mid gives at least ( N / ( M + 1 ) ) candies or not ; Candies taken by 1 st person is minimum of K and candies left ; Traverse the given array ; Amount consumed by person j ; Update the count of candies ; Check if person 1 gets the good share of candies ; Function to find minimum value of K such that the first person gets at least ( N / ( M + 1 ) ) candies ; Find the minimum required value of candies untill the first person ; Iterate until low is less than or equal to mid ; Find the value of mid ; Check untill mid , whether it can be the possible value of K or not ; Update the value of hi ; Otherwise , update the value of lo ; Print the resultant minimum value of K ; Driver Code
",0
248,"create constant integer sz with sz assign to 20
create constant integer sqr with sqr assign to int ( sqrt ( sz ) ) + 1
untill i assign to N - 1 to sqrt ( N ), j assign to sqrt ( N ), dp array of i   array of j   assign to arr array of i   + dp array of i + j   array of j  , dp array of sz   array of sqr   ), dp array of i   array of j   assign to arr array of i   + dp
else dp array of i   array of j   assign to arr array of i  
in function querySum taking ints arr array of  , N, Q array of   array of 2  , M and returning int dp array of sz   array of sqr 
precomputeExpressionForAllVal ( arr, N, dp )
untill i assign to 0 to M exclusive, x assign to Q array of i   array of 0  
create integer y with y assign to Q array of i  array of 1  
if y assign to sqrt ( N ) print dp array ofx   array ofy   print "" ""
continue
sum assign to integer with sum assign to 0
untill x  N, increment sum by arr array of x  
increase x by y
print sum
declare integer main ( ), integer arr assign to  1, 2, 7, 5, 4  ;
create integer Q with Q array of   array of 2   assign to   2, 1 , 3, 2
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create integer M with M assign to sizeof ( Q) / sizeof ( Q array of 0   )
querySum ( arr, N, Q, M )
return 0
","Queries to calculate sum of array elements present at every Yth index starting from the index X 
 C ++ program untill the above approach ; Function to sum of arr array of x   + arr array of x + y   + arr array of x + 2 * y   + ... untill all possible values of X and Y , where Y is less than or equal to sqrt ( N ) . ; Iterate over all possible values of X ; Precompute untill all possible values of an expression such that y <assign to sqrt ( N ) ; If i + j less than N ; Update dp array of i   array of j   ; Update dp array of i   array of j   ; Function to Find the sum of arr array of x   + arr array of x + y   + arr array of x + 2 * y   + ... untill all queries ; dp array of x   array of y   : Stores sum of arr array of x   + arr array of x + y   + arr array of x + 2 * y   + ... ; Traverse the query array , Q array of   array of   ; If y is less than or equal to sqrt ( N ) ; Stores the sum of arr array of x   + arr array of x + y   + arr array of x + 2 * y   + ... ; Traverse the array , arr array of   ; Update sum ; Update x ; Driver Code
",1
249,"create constant integer sz with sz assign to 20
create constant integer sqr with sqr assign to int ( sqrt ( sz ) ) + 1
untill i assign to N - 1 to sqrt ( N ), j assign to sqrt ( N ), dp array of i   array of j   assign to arr array of i   + dp array of i + j   array of j  , dp array of sz   array of sqr   ), dp array of i   array of j   assign to arr array of i   + dp
else dp array of i   array of j   assign to arr array of i  
in function querySum taking ints arr array of  , N, Q array of   array of 2  , M and returning int dp array of sz   array of sqr 
precomputeExpressionForAllVal ( arr, N, dp )
untill i assign to 0 to M exclusive, x assign to Q array of i   array of 0  
create integer y with y assign to Q array of i  array of 1  
if y assign to sqrt ( N ) print dp array ofx   array ofy   print "" ""
continue
sum assign to integer with sum assign to 0
untill x  N, increment sum by arr array of x  
increase x by y
print sum
declare integer main ( ), integer arr assign to  1, 2, 7, 5, 4  ;
create integer Q with Q array of   array of 2   assign to   2, 1 , 3, 2
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create integer M with M assign to sizeof ( Q) / sizeof ( Q array of 0   )
querySum ( arr, N, Q, M )
return 0
","Maximum sum possible from given Matrix by peruntillming given operations 
 C ++ program untill the above approach ; Function to print the maximum sum ; Dp table ; Initializing dp array with 0 s ; Base case ; Traverse each column ; Update answer untill both rows ; Print the maximum sum ; Driver Code ; Given array ; Number of Columns ; Function calls
",0
250,"untill i assign to 0 to n exclusive, count assign to 0
untill j assign to 0 to n exclusive, increment count by 1 if arr array ofj   > arr array of i  
if count >assign to 2 print arr array of i  and "" ""
declare integer main ( ), integer arr assign to  2, -6, 3, 5, 1  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create findElements ( arr, n )
return 0
","Find all elements in array which have at 
 Simple C ++ program to find all elements in array which have at - least two greater elements itself . ; Pick elements one by one and count greater elements . If count is more than 2 , print that element . ; Driver code
",1
251,"untill i assign to 0 to n exclusive, count assign to 0
untill j assign to 0 to n exclusive, increment count by 1 if arr array ofj   > arr array of i  
if count >assign to 2 print arr array of i  and "" ""
declare integer main ( ), integer arr assign to  2, -6, 3, 5, 1  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create findElements ( arr, n )
return 0
","Pascal 's Triangle 
 C ++ program untill Pascals Triangle ; A O ( n to the power 2 ) time and O ( n to the power 2 ) extra space method untill Pascal 's Triangle ; An auxiliary array to store generated pscal triangle values ; Iterate through every line and print integer ( s ) in it ; Every line has number of integers equal to line number ; First and last values in every row are 1 ; Other values are sum of values just above and left of above ; Driver code
",0
252,"declare findElements with integer arr array of  , integer n, sort ( arr, arr + n ) as arguments
untill i assign to 0 to n - 2 exclusive, print arr array of i  and "" ""
declare integer main ( ), integer arr array of   assign to  2, -6, 3, 5, 1  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create findElements ( arr, n )
return 0
","Find all elements in array which have at 
 Sorting based C ++ program to find all elements in array which have atleast two greater elements itself . ; Driver Code
",1
253,"declare findElements with integer arr array of  , integer n, sort ( arr, arr + n ) as arguments
untill i assign to 0 to n - 2 exclusive, print arr array of i  and "" ""
declare integer main ( ), integer arr array of   assign to  2, -6, 3, 5, 1  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create findElements ( arr, n )
return 0
","Maximize volume of cuboid with given sum of sides 
 Return the maximum volume . ; Return the maximum volume . ; finding length ; finding breadth ; finding height ; Driven Program
",0
254,"declare findElements with integer arr array of  , integer n, first assign to INT_MIN, second assign to INT_MIN
untill i assign to 0 to n exclusive, set second to first if arr array of i   is greater than first
set first to arr array of i  
else if arr array of i   is greater than second, set second to arr array of i  
untill i assign to 0 to n exclusive, print arr array of i   and "" ""
declare integer main ( ), integer arr array of   assign to  2, -6, 3, 5, 1  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create findElements ( arr, n )
return 0
","Find all elements in array which have at 
 C ++ program to find all elements in array which have atleast two greater elements itself . ; If current element is smaller than first then update both first and second ; If arr array of i   is in between first and second then update second ; Driver code
",1
255,"declare findElements with integer arr array of  , integer n, first assign to INT_MIN, second assign to INT_MIN
untill i assign to 0 to n exclusive, set second to first if arr array of i   is greater than first
set first to arr array of i  
else if arr array of i   is greater than second, set second to arr array of i  
untill i assign to 0 to n exclusive, print arr array of i   and "" ""
declare integer main ( ), integer arr array of   assign to  2, -6, 3, 5, 1  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create findElements ( arr, n )
return 0
","Minimum number of bracket reversals needed to make an expression balanced 
 C ++ program to find minimum number of reversals required to balance an expression ; Returns count of minimum reversals untill making expr balanced . Returns - 1 if expr cannot be balanced . ; Expressions of odd lengths cannot be balanced ; If we find a left bracket then we simply increment the left bracket ; Else if left bracket is 0 then we find unbalanced right bracket and increment right bracket or if the expression is balanced then we decrement left ; Driver program to test above function
",0
256,"declare getMinOps with integer arr array of  , integer n, res assign to 0
untill i assign to 0 to n - 1 exclusive, increment res by max ( arr array of i + 1   - arr array of i  , 0 )
return res
declare integer main ( ), integer arr array of   assign to  1, 3, 4, 1, 2  ;
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print getMinOps ( arr, N )
","Minimize count of increments of each element of subarrays required to make Array non 
 C ++ Program to implement the above approach ; Function to find the minimum number of operations required to make the array non - increasing ; Stores the count of required operations ; If arr array of i   > arr array of i + 1   , no increments required . Otherwise , add their difference to the answer ; Return the result res ; Driver Code
",1
257,"declare getMinOps with integer arr array of  , integer n, res assign to 0
untill i assign to 0 to n - 1 exclusive, increment res by max ( arr array of i + 1   - arr array of i  , 0 )
return res
declare integer main ( ), integer arr array of   assign to  1, 3, 4, 1, 2  ;
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print getMinOps ( arr, N )
","Length of the chord of the circle whose radius and the angle subtended at the center by the chord is given 
 C ++ program to find the length chord of the circle whose radius and the angle subtended at the centre is also given ; Function to find the length of the chord ; Driver code
",0
258,"declare findFirstMissing with array array of integers array of size, start, end, return end + 1, if start > end
if start is not array array of start , return start
mid assign to integer with mid assign to ( start + end ) / 2
if array array of mid  is mid return findFirstMissing ( array, mid + 1, end )
return findFirstMissing ( array, start, mid)
declare integer main ( ) and integer array arr with arr assign to 0, 1, 2, 3, 4, 5, 6, 7, 10
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print "" Smallest missing element is "" print findFirstMissing ( arr, 0, n - 1 ) print newline
","Find the smallest missing number 
 C ++ program to find the smallest elements missing in a sorted array . ; function that returns smallest elements missing in a sorted array . ; Left half has all elements from 0 to mid ; Driver code
",1
259,"declare findFirstMissing with array array of integers array of size, start, end, return end + 1, if start > end
if start is not array array of start , return start
mid assign to integer with mid assign to ( start + end ) / 2
if array array of mid  is mid return findFirstMissing ( array, mid + 1, end )
return findFirstMissing ( array, start, mid)
declare integer main ( ) and integer array arr with arr assign to 0, 1, 2, 3, 4, 5, 6, 7, 10
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print "" Smallest missing element is "" print findFirstMissing ( arr, 0, n - 1 ) print newline
","Frequency Measuring Techniques untill Competitive Programming 
 C ++ program to count frequencies of array items ; Mark all array elements as not visited ; Traverse through array elements and count frequencies ; Skip this element if already processed ; Count frequency ; Driver Code
",0
260,"return 0 if arr array of 0  is not 0
if arr array of size of arr - 1   is arr. size ( ) - 1 ) return size of arr
create integer first with first assign to arr array of 0  
return findFirstMissing ( arr, 0, arr. size ( ) - 1, first )
declare findFirstMissing with vector  integers arr, start, end, first, if start is less than end, mid assign to ( start + end ) / 2
if arr array of mid  is not mid + first, return findFirstMissing ( arr, start, mid, first)
else return findFirstMissing ( arr, mid + 1, end, first )
return start + first
declare integer main ( ), vector arr assign to  0, 1, 2, 3, 4, 5, 7  ;
create integer n with n assign to size of arr
print "" First Missing element is : "" print findSmallestMissinginSortedArray ( arr)
","Find the smallest missing number 
 C ++ program untill the above approach ; Program to find Smallest Missing in Sorted Array ; Check if 0 is missing in the array ; Check is all numbers 0 to n - 1 are prsent in array ; Program to find missing element ; * Index matches with value at that index , means missing element cannot be upto that po ; Driver program to test the above function ; Function Call
",1
261,"return 0 if arr array of 0  is not 0
if arr array of size of arr - 1   is arr. size ( ) - 1 ) return size of arr
create integer first with first assign to arr array of 0  
return findFirstMissing ( arr, 0, arr. size ( ) - 1, first )
declare findFirstMissing with vector  integers arr, start, end, first, if start is less than end, mid assign to ( start + end ) / 2
if arr array of mid  is not mid + first, return findFirstMissing ( arr, start, mid, first)
else return findFirstMissing ( arr, mid + 1, end, first )
return start + first
declare integer main ( ), vector arr assign to  0, 1, 2, 3, 4, 5, 7  ;
create integer n with n assign to size of arr
print "" First Missing element is : "" print findSmallestMissinginSortedArray ( arr)
","Check if a number S can be made divisible by D by repeatedly adding the remainder to S 
 C ++ program untill the above approach ; Function to check if S is divisible by D untill changing S to ( S + S % D ) ; V ( 0 ) assign to S % D ; Stores the encountered values ; V ( i ) assign to ( V ( i - 1 ) + V ( i - 1 ) % D ) % D ; Check if the value has already been encountered ; Edge Case ; Otherwise , insert it into the hashmap ; Driver Code
",0
262,"declare FindMaxSum with vector  integers > arr, n, integer incl assign to arr array of 0  
declare integer variable excl assign to 0
declare integer excl_new
create integer i
untill i assign to 1 to n exclusive, then excl_new assign to incl if incl > excl else excl
set incl to excl + arr array of i  
set excl to excl_new
return incl if incl > excl else return if excl is greater than excl
declare integer main ( ), vector  integer arr assign to  5, 5, 10, 100, 10, 5  ;
print FindMaxSum ( arr, arr size ( ) ) )
","Maximum sum such that no two elements are adjacent 
 c ++ program untill the above approach ; Function to return max sum such that no two elements are adjacent ; current max excluding i ; current max including i ; return max of incl and excl ; Driver program to test above functions
",1
263,"declare FindMaxSum with vector  integers > arr, n, integer incl assign to arr array of 0  
declare integer variable excl assign to 0
declare integer excl_new
create integer i
untill i assign to 1 to n exclusive, then excl_new assign to incl if incl > excl else excl
set incl to excl + arr array of i  
set excl to excl_new
return incl if incl > excl else return if excl is greater than excl
declare integer main ( ), vector  integer arr assign to  5, 5, 10, 100, 10, 5  ;
print FindMaxSum ( arr, arr size ( ) ) )
","Sieve of Sundaram to print all primes smaller than n 
 C ++ program to print primes smaller than n using Sieve of Sundaram . ; Prints all prime numbers smaller ; In general Sieve of Sundaram , produces primes smaller than ( 2 * x + 2 ) untill a number given number x . Since we want primes smaller than n , we reduce n to half ; This array is used to separate numbers of the untillm i + j + 2 ij from others where 1 <assign to i <assign to j ; Initialize all elements as not marked ; Main logic of Sundaram . Mark all numbers of the untillm i + j + 2 ij as true where 1 <assign to i <assign to j ; Since 2 is a prime number ; Print other primes . Remaining primes are of the untillm 2 * i + 1 such that marked array of i   is false . ; Driver program to test above
",0
264,"declare countChanges with integer matrix array of   array of N  , integer n, m, dist assign to n + m - 1
create integer freq array of dist  array of 10 
untill i assign to 0 to dist exclusive, freq array of i   array of j   assign to 0
untill i assign to 0 to n exclusive, increment freq array of i + j  array of matrix array of i   array of j      
min_changes_sum assign to 0
untill i assign to 0 to dist / 2 exclusive, set maximum to 0
create integer total_values with total_values assign to 0
untill j assign to 0 to 10 exclusive, set maximum to max ( maximum, freq array of i   array of j   + freq array of n + m - 2 - i   array of j   )
increment total_values by freq array of i   array of j   + freq array of n + m - 2 - i   array of j   )
increment min_changes_sum by total_values - maximum
return min_changes_sum
declare integer main ( ), integer mat array of   array of N   assign to   1, 2 ,  3, 5
print countChanges ( mat, 2, 2 )
return 0
","Minimum steps to convert all top left to bottom right paths in Matrix as palindrome 
 Set 2 
 C ++ program untill the above approach ; Function untill counting minimum number of changes ; Distance of elements from ( 0 , 0 ) will is i range array of 0 , n + m - 2   ; Store frequencies of array of 0 , 9   at distance i ; Initialize frequencies as 0 ; Count frequencies of array of 0 , 9   ; Increment frequency of value matrix array of i   array of j   at distance i + j ; Find value with max frequency and count total cells at distance i from front end and rear end ; Change all values to the value with max frequency ; Return the answer ; Driver Code ; Given Matrix ; Function Call
",1
265,"declare countChanges with integer matrix array of   array of N  , integer n, m, dist assign to n + m - 1
create integer freq array of dist  array of 10 
untill i assign to 0 to dist exclusive, freq array of i   array of j   assign to 0
untill i assign to 0 to n exclusive, increment freq array of i + j  array of matrix array of i   array of j      
min_changes_sum assign to 0
untill i assign to 0 to dist / 2 exclusive, set maximum to 0
create integer total_values with total_values assign to 0
untill j assign to 0 to 10 exclusive, set maximum to max ( maximum, freq array of i   array of j   + freq array of n + m - 2 - i   array of j   )
increment total_values by freq array of i   array of j   + freq array of n + m - 2 - i   array of j   )
increment min_changes_sum by total_values - maximum
return min_changes_sum
declare integer main ( ), integer mat array of   array of N   assign to   1, 2 ,  3, 5
print countChanges ( mat, 2, 2 )
return 0
","Find trace of matrix untillmed by adding Row 
 C ++ program to find trace of matrix untillmed by adding Row - major and Column - major order of same matrix ; Return sum of first n integers of an AP ; Return the trace of sum of row - major matrix and column - major matrix ; Finding nth element in AP in case of Row major matrix . ; Finding sum of first n integers of AP in case of Row major matrix ; Finding nth element in AP in case of Row major matrix ; Finding sum of first n integers of AP in case of Column major matrix ; Driven Program
",0
266,"create integer lookup array of MAX  array of MAX 
untill i assign to 0 to n exclusive, lookup array of i   array of 0   assign to arr array of i  
untill j assign to 1 to n inclusive, change i from 0 to n exclusive, incrementing i by 1  (j - 1) )   array of j - 1   array of j - 1  , change lookup array of i   array of j - 1   to lookup array of i   array of j - 1  
else lookup array of i   array of j   assign to lookup array of i + ( 1  ( j - 1 ) )   array of j - 1  
j assign to integer with j assign to log2 assign to R - L + 1
if lookup array of L  array ofj  assign to lookup array of R - ( 1  j ) + 1   array of j  , return lookup array of L   array of j  
else return lookup array of R - ( 1  j ) + 1   array of j  
declare integer main ( ) and integer array a with size   assign to  7, 2, 3, 0, 5, 10, 3, 12, 18
create integer n with n assign to sizeof ( a ) / sizeof ( a array of 0   )
create buildSparseTable ( a, n )
print query ( 0, 4 ) and a new line
print query ( 4, 7 )
print query ( 7, 8 )
return 0
","Sparse Table 
 C ++ program to do range minimum query using sparse table ; lookup array of i   array of j   is going to store minimum value in arr array of i . . j   . Ideally lookup table size should not be fixed and should be determined using n Log n . It is kept constant to keep code simple . ; Fills lookup array lookup array of   array of   in bottom up manner . ; Initialize M untill the intervals with length 1 ; Compute values from smaller to bigger intervals ; Compute minimum value untill all intervals with size 2 to the power j ; For arr array of 2   array of 10   , we compare arr array of lookup array of 0   array of 7     and arr array of lookup array of 3   array of 10     ; Returns minimum of arr array of L . . R   ; Find highest power of 2 that is smaller than or equal to count of elements in given range . For array of 2 , 10   , j assign to 3 ; Compute minimum of last 2 to the power j elements with first 2 to the power j elements in range . For array of 2 , 10   , we compare arr array of lookup array of 0   array of 3     and arr array of lookup array of 3   array of 3     , ; Driver program
",1
267,"create integer lookup array of MAX  array of MAX 
untill i assign to 0 to n exclusive, lookup array of i   array of 0   assign to arr array of i  
untill j assign to 1 to n inclusive, change i from 0 to n exclusive, incrementing i by 1  (j - 1) )   array of j - 1   array of j - 1  , change lookup array of i   array of j - 1   to lookup array of i   array of j - 1  
else lookup array of i   array of j   assign to lookup array of i + ( 1  ( j - 1 ) )   array of j - 1  
j assign to integer with j assign to log2 assign to R - L + 1
if lookup array of L  array ofj  assign to lookup array of R - ( 1  j ) + 1   array of j  , return lookup array of L   array of j  
else return lookup array of R - ( 1  j ) + 1   array of j  
declare integer main ( ) and integer array a with size   assign to  7, 2, 3, 0, 5, 10, 3, 12, 18
create integer n with n assign to sizeof ( a ) / sizeof ( a array of 0   )
create buildSparseTable ( a, n )
print query ( 0, 4 ) and a new line
print query ( 4, 7 )
print query ( 7, 8 )
return 0
","Check if the Xor of the frequency of all digits of a number N is zero or not 
 C ++ implementation of the above approach ; creating a frequency array ; Finding the last digit of the number ; Dividing the number by 10 to eliminate last digit ; counting frequency of each digit ; checking if the xor of all frequency is zero or not ; Driver function
",0
268,"table assign to integer array of size MAX, MAX, table assign to integer
untill i assign to 0 to n exclusive, table array of i   array of 0   assign to arr array of i  
untill j assign to 1 to n inclusive, set table array of i   array of j   to __gcd ( table array of i   array of j - 1  , table array of i + ( 1  ( j - 1) ) ) array of j - 1   ) )
declare query with integers L, R, j as arguments, returning integer, log2 with R - L + 1 as arguments, returning integer
return __gcd ( table array of L  array of j  , table array of R - ( 1  j ) + 1   array of j   )
declare integer main ( ) and integer array a with size   assign to  7, 2, 3, 0, 5, 10, 3, 12, 18
create integer n with n assign to sizeof ( a ) / sizeof ( a array of 0   )
create buildSparseTable ( a, n )
print query ( 0, 2 ) and a new line
print query ( 1, 3 )
print query ( 4, 5 )
return 0
","Sparse Table 
 C ++ program to do range minimum query using sparse table ; lookup array of i   array of j   is going to store GCD of arr array of i . . j   . Ideally lookup table size should not be fixed and should be determined using n Log n . It is kept constant to keep code simple . ; it builds sparse table . ; GCD of single element is element itself ; Build sparse table ; Returns GCD of arr array of L . . R   ; Find highest power of 2 that is smaller than or equal to count of elements in given range . For array of 2 , 10   , j assign to 3 ; Compute GCD of last 2 to the power j elements with first 2 to the power j elements in range . For array of 2 , 10   , we find GCD of arr array of lookup array of 0   array of 3     and arr array of lookup array of 3   array of 3     , ; Driver program
",1
269,"table assign to integer array of size MAX, MAX, table assign to integer
untill i assign to 0 to n exclusive, table array of i   array of 0   assign to arr array of i  
untill j assign to 1 to n inclusive, set table array of i   array of j   to __gcd ( table array of i   array of j - 1  , table array of i + ( 1  ( j - 1) ) ) array of j - 1   ) )
declare query with integers L, R, j as arguments, returning integer, log2 with R - L + 1 as arguments, returning integer
return __gcd ( table array of L  array of j  , table array of R - ( 1  j ) + 1   array of j   )
declare integer main ( ) and integer array a with size   assign to  7, 2, 3, 0, 5, 10, 3, 12, 18
create integer n with n assign to sizeof ( a ) / sizeof ( a array of 0   )
create buildSparseTable ( a, n )
print query ( 0, 2 ) and a new line
print query ( 1, 3 )
print query ( 4, 5 )
return 0
","Number of strings in two array satisfy the given conditions 
 C ++ program untill the above approach ; To store the frequency of string after bitmasking ; To store result untill each string in arr2 array of   ; Traverse the arr1 array of   and bitmask each string in it ; Bitmasking untill each string s ; Update the frequency of string with it 's bitmasking value ; Traverse the arr2 array of   ; Bitmasking untill each string s ; Check if temp is present in an unordered_map or not ; Check untill next set bit ; Push the count untill current string in resultant array ; Print the count untill each string ; Driver Code ; Function call
",0
270,"in void function minimizeWithKSwaps (int arr array of  , int n, int k )  untill i assign to 0 to n - 1 && k > 0 ; ++ i )  int pos assign to i
untill j assign to i + 1 to n exclusive, break if j - i is greater than k
if arr array ofj  is less than arr array of pos  , pos assign to j
untill j assign to pos to i exclusive swap arr array ofj   and arr array of j - 1  
decrement k by pos - i
declare integer main ( ), integer arr assign to  7, 6, 9, 2, 1  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create integer k with k assign to 3
minimizeWithKSwaps ( arr, n, k )
untill i assign to 0 to n exclusive, print arr array of i   and "" ""
","Lexicographically smallest array after at 
 C ++ program to find lexicographically minimum value after k swaps . ; Modifies arr array of 0. . n - 1   to lexicographically smallest with k swaps . ; Set the position where we want to put the smallest integer ; If we exceed the Max swaps then terminate the loop ; Find the minimum value from i + 1 to max k or n ; Swap the elements from Minimum position we found till now to the i index ; Set the final value after swapping pos - i elements ; Driver code ; Function calling ; Print the final Array
",1
271,"in void function minimizeWithKSwaps (int arr array of  , int n, int k )  untill i assign to 0 to n - 1 && k > 0 ; ++ i )  int pos assign to i
untill j assign to i + 1 to n exclusive, break if j - i is greater than k
if arr array ofj  is less than arr array of pos  , pos assign to j
untill j assign to pos to i exclusive swap arr array ofj   and arr array of j - 1  
decrement k by pos - i
declare integer main ( ), integer arr assign to  7, 6, 9, 2, 1  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create integer k with k assign to 3
minimizeWithKSwaps ( arr, n, k )
untill i assign to 0 to n exclusive, print arr array of i   and "" ""
","Largest and smallest Fibonacci numbers in an Array 
 C ++ program to find minimum and maximum fibonacci number in given array ; Function to create hash table to check Fibonacci numbers ; Insert initial two numbers in the hash table ; Sum of previous two numbers ; Update the variable each time ; Function to find minimum and maximum fibonacci number in given array ; Find maximum value in the array ; Creating a set containing all Fibonacci numbers up to maximum value in the array ; For storing the Minimum and Maximum Fibonacci number ; Check if current element is a fibonacci number ; Update the maximum and minimum accordingly ; Driver code
",0
272,"if k is greater than n, return -1
create integer csum with csum assign to new integer array of size n
set csum array of 0   to arr array of 0  
untill i assign to 1 to n exclusive, set csum array of i   to csum array of i - 1   + arr array of i  
create integers max_sum with max_sum assign to csum array of k - 1   and max_end assign to k - 1
untill i assign to k to n exclusive, curr_sum assign to csum array of i   - csum array of i - k  
if curr_sum is greater than max_sum, set max_sum to curr_sum
set max_end to i
delete array of   csum
return max_end - k + 1
declare integer main ( ), integer arr assign to  1, 12, -5, -6, 50, 3  ;
create integer k with k assign to 4
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print "" The maximum average subarray of "" "" length "" k  "" begins at index ""  findMaxAverage ( arr, n, k )
return 0
","Find maximum average subarray of k length 
 C ++ program to find maximum average subarray of given length . ; Returns beginning index of maximum average subarray of length ' k ' ; Check if ' k ' is valid ; Create and fill array to store cumulative sum . csum array of i   stores sum of arr array of 0   to arr array of i   ; Initialize max_sm as sum of first subarray ; Find sum of other subarrays and update max_sum if required . ; To avoid memory leak ; Return starting index ; Driver program
",1
273,"if k is greater than n, return -1
create integer csum with csum assign to new integer array of size n
set csum array of 0   to arr array of 0  
untill i assign to 1 to n exclusive, set csum array of i   to csum array of i - 1   + arr array of i  
create integers max_sum with max_sum assign to csum array of k - 1   and max_end assign to k - 1
untill i assign to k to n exclusive, curr_sum assign to csum array of i   - csum array of i - k  
if curr_sum is greater than max_sum, set max_sum to curr_sum
set max_end to i
delete array of   csum
return max_end - k + 1
declare integer main ( ), integer arr assign to  1, 12, -5, -6, 50, 3  ;
create integer k with k assign to 4
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print "" The maximum average subarray of "" "" length "" k  "" begins at index ""  findMaxAverage ( arr, n, k )
return 0
","Unique paths covering every non 
 C ++ implementation of the approach ; Function untill dfs . i , j equal to > Current cell indexes vis equal to > To mark visited cells ans equal to > Result z equal to > Current count 0 s visited z_count equal to > Total 0 s present ; Mark the block as visited ; update the count ; If end block reached ; If path covered all the non - obstacle blocks ; Up ; Down ; Left ; Right ; Unmark the block ( unvisited ) ; Function to return the count of the unique paths ; int z_count assign to 0 ; Total 0 s present ; Count non - obstacle blocks ; Starting position ; Driver code
",0
274,"if k is greater than n, return -1
create integer sum with sum assign to arr array of 0  
untill i assign to 1 to k exclusive, add arr array of i   to sum
create integers max_sum, max_end with max_sum assign to sum, max_end assign to k - 1
untill i assign to k to n exclusive, sum assign to sum + arr array of i   - arr array of i - k  
if sum is greater than max_sum, set max_sum to sum
set max_end to i
return max_end - k + 1
declare integer main ( ), integer arr assign to  1, 12, -5, -6, 50, 3  ;
create integer k with k assign to 4
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print "" The maximum average subarray of "" "" length "" k  "" begins at index ""  findMaxAverage ( arr, n, k )
return 0
","Find maximum average subarray of k length 
 C ++ program to find maximum average subarray of given length . ; Returns beginning index of maximum average subarray of length ' k ' ; Check if ' k ' is valid ; Compute sum of first ' k ' elements ; Compute sum of remaining subarrays ; Return starting index ; Driver program
",1
275,"if k is greater than n, return -1
create integer sum with sum assign to arr array of 0  
untill i assign to 1 to k exclusive, add arr array of i   to sum
create integers max_sum, max_end with max_sum assign to sum, max_end assign to k - 1
untill i assign to k to n exclusive, sum assign to sum + arr array of i   - arr array of i - k  
if sum is greater than max_sum, set max_sum to sum
set max_end to i
return max_end - k + 1
declare integer main ( ), integer arr assign to  1, 12, -5, -6, 50, 3  ;
create integer k with k assign to 4
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print "" The maximum average subarray of "" "" length "" k  "" begins at index ""  findMaxAverage ( arr, n, k )
return 0
","Bitwise OR of bitwise AND of all possible non 
 C ++ program untill the above approach ; Function to find the Bitwise OR of Bitwise AND of all possible subarrays after peruntillming the every query ; Traversing each pair of the query ; Stores the Bitwise OR ; Updating the array ; Find the Bitwise OR of new updated array ; Print the ans ; Driver Code
",0
276,"create map  pair  int, int >, int > m
if m. find ( pos, myturn  ) is not m. end ( ) ), return m array of  pos, myturn   
if pos >assign to n return 0
if! myturn is true, set ans to min ( findMinimum ( a, n, pos + 1,! myturn ) + a array of pos  , findMinimum ( a, n, pos + 2,! myturn ) + a array of pos   + a array of pos + 1   ) )
m array of  pos, myturn    assign to ans
return ans
if myturn is true, set ans to min of findMinimum ( a, n, pos + 1,! myturn ) and findMinimum ( a, n, pos + 2,! myturn ) )
m array of  pos, myturn    assign to ans
return ans
return 0
declare countPenality with integer arr array of  , N, integer pos assign to 0
turn assign to integer with turn assign to 0
return findMinimum ( arr, N, pos, turn )
printAnswer is a void function with int arguments arr and N and a assign to countPenality ( arr and N)
create integer sum with sum assign to 0
untill i assign to 0 to N exclusive, add arr array of i   to sum
print a
declare integer main ( ) and integer arr array of   assign to  1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1  ;
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
printAnswer ( arr, N )
return 0
","Minimum score possible untill a player by selecting one or two consecutive array elements from given binary array 
 C ++ program untill the above approach ; Stores the minimum score untill each states as map < pair < pos , myturn > , ans > ; Function to find the minimum score after choosing element from array ; Return the stored state ; Base Case ; Player A 's turn ; Find the minimum score ; Store the current state ; Return the result ; Player B 's turn ; Find minimum score ; Store the current state ; Return the result ; Function that finds the minimum penality after choosing element from the given binary array ; Starting position of choosing element from array ; 0 denotes player A turn 1 denotes player B turn ; Function Call ; Print the answer untill player A and B ; Minimum penalty ; Calculate sum of all arr elements ; Print the minimum score ; Driver Code
",1
277,"create map  pair  int, int >, int > m
if m. find ( pos, myturn  ) is not m. end ( ) ), return m array of  pos, myturn   
if pos >assign to n return 0
if! myturn is true, set ans to min ( findMinimum ( a, n, pos + 1,! myturn ) + a array of pos  , findMinimum ( a, n, pos + 2,! myturn ) + a array of pos   + a array of pos + 1   ) )
m array of  pos, myturn    assign to ans
return ans
if myturn is true, set ans to min of findMinimum ( a, n, pos + 1,! myturn ) and findMinimum ( a, n, pos + 2,! myturn ) )
m array of  pos, myturn    assign to ans
return ans
return 0
declare countPenality with integer arr array of  , N, integer pos assign to 0
turn assign to integer with turn assign to 0
return findMinimum ( arr, N, pos, turn )
printAnswer is a void function with int arguments arr and N and a assign to countPenality ( arr and N)
create integer sum with sum assign to 0
untill i assign to 0 to N exclusive, add arr array of i   to sum
print a
declare integer main ( ) and integer arr array of   assign to  1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1  ;
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
printAnswer ( arr, N )
return 0
","Program to find parity 
 C ++ program to find parity of an integer ; Function to get parity of number n . It returns 1 if n has odd parity , and returns 0 if n has even parity ; Driver program to test getParity ( )
",0
278,"create integer constant MAX with MAX assign to 1000001
prime assign to boolean array of size MAX
declare SieveOfEratosthenes with void, set memset ( prime, true, sizeof ( prime ) )
untill p assign to 2 to MAX inclusive, if prime array of p   is true, increment p p ) and set prime array of i   to false
return s + ( e - s ) / 2
if qs assign to ss and qe >assign to se, return st array of si 
if se is less than qs ss, return 0
mid assign to integer with mid assign to getMid ( ss, se )
return getSumUtil ( st, ss, mid, qs, qe, 2 * si + 1 ) + getSumUtil ( st, mid + 1, se, qs, qe, 2 * si + 2)
if i is less than ss i, return void updateValueUtil (int * st, int se, int i, int diff, int si )
st array of si  assign to st array of si  + diff
if se is not ss, mid assign to getMid ( ss, se )
call updateValueUtil (st, ss, mid, i, diff, 2 * si + 1)
call updateValueUtil (st, mid + 1, se, i, diff, 2 * si + 2)
if i  0 i > n - 1, print "" - 1""
return
diff assign to int with diff assign to new_val - arr array of i  
create integer prev_val with prev_val assign to arr array of i  
arr array of i   assign to new_val
if prime array of new_val  prime array of prev_val  )  if not prime array of prev_val  , updateValueUtil ( st, 0, n - 1, i, new_val, 0 )
else if prime array of new_val  is true, call updateValueUtil (st, 0, n - 1, i, - prev_val, 0 )
else updateValueUtil ( st, 0, n - 1, i, diff, 0 )
if qs  0 qe > n - 1 qs > qe print "" - 1""
return -1
return getSumUtil ( st, 0, n - 1, qs, qe, 0 )
if ss is se, st is equal to prime array of arr array of ss    , st array of si   is equal to arr array of ss  
else st array of si  assign to 0
return st array of si 
mid assign to int with mid assign to getMid ( ss, se )
st array of si  assign to constructSTUtil ( arr, ss, mid, st, si * 2 + 1 ) + constructSTUtil ( arr, mid + 1, se, st, si * 2 + 2)
return st array of si 
declare integer variable constructST with integer arr array of  , integer n, integer x assign to ( integer ) ( ceil ( log2 ( n ) ) ) as arguments
max_size assign to 2 * ( int ) pow ( 2, x ) - 1
create integer * st with st assign to new integer array of size max_size
create constructSTUtil ( arr, 0, n - 1, st, 0 )
return st
declare integer main ( ), integer arr array of   assign to  1, 3, 5, 7, 9, 11  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
Q assign to integer array of size 3 and 3 with Q assign to   1, 1, 3 ,  2, 1, 10 ,  1, 1, 3
call SieveOfEratosthenes ( )
create integer st with st assign to constructST ( arr, n )
print getSum ( st, n, 1, 3 ) and a new line
updateValue ( arr, st, n, 1, 10 )
print getSum ( st, n, 1, 3 ) and a new line
return 0
","Sum of prime numbers in range array of L , R   from given Array untill Q queries 
 C ++ program untill the above approach ; Function to find the prime numbers ; Create a boolean array prime array of   and initialize all entries it as true A value in prime array of i   will finally be false if i is Not a prime ; Check if prime array of p   is not changed , then it is a prime ; Update all multiples of p greater than or equal to the square of it numbers which are multiple of p and are less than p to the power 2 are already been marked ; Function to get the middle index from corner indexes ; Function to get the sum of values in the given range of the array ; If segment of this node is a part of given range , then return the sum of the segment ; If segment of this node is outside the given range ; If a part of this segment overlaps with the given range ; Function to update the nodes which have the given index in their range ; If the input index lies outside the range of this segment ; If the input index is in range of this node , then update the value of the node and its children ; Function to update a value in input array and segment tree ; Check untill erroneous input index ; Get the difference between new value and old value ; Update the value in array ; Update the values of nodes in segment tree only if either previous value or new value or both are prime ; If only new value is prime ; If only new value is prime ; If both are prime ; Return sum of elements in range from index qs ( query start ) to qe ( query end ) . It mainly uses getSumUtil ( ) ; Check untill erroneous input values ; Function that constructs Segment Tree ; If there is one element in array , store it in current node of segment tree and return ; Only add those elements in segment tree which are prime ; If there are more than one elements , then recur untill left and right subtrees and store the sum of values in this node ; Function to construct segment tree from given array ; Height of segment tree ; Maximum size of segment tree ; Allocate memory ; Fill the allocated memory st ; Return the constructed segment tree ; Driver code ; Function call ; Build segment tree from given array ; Print sum of values in array from index 1 to 3 ; Update : set arr array of 1   assign to 10 and update corresponding segment tree nodes ; Find sum after the value is updated
",1
279,"create integer constant MAX with MAX assign to 1000001
prime assign to boolean array of size MAX
declare SieveOfEratosthenes with void, set memset ( prime, true, sizeof ( prime ) )
untill p assign to 2 to MAX inclusive, if prime array of p   is true, increment p p ) and set prime array of i   to false
return s + ( e - s ) / 2
if qs assign to ss and qe >assign to se, return st array of si 
if se is less than qs ss, return 0
mid assign to integer with mid assign to getMid ( ss, se )
return getSumUtil ( st, ss, mid, qs, qe, 2 * si + 1 ) + getSumUtil ( st, mid + 1, se, qs, qe, 2 * si + 2)
if i is less than ss i, return void updateValueUtil (int * st, int se, int i, int diff, int si )
st array of si  assign to st array of si  + diff
if se is not ss, mid assign to getMid ( ss, se )
call updateValueUtil (st, ss, mid, i, diff, 2 * si + 1)
call updateValueUtil (st, mid + 1, se, i, diff, 2 * si + 2)
if i  0 i > n - 1, print "" - 1""
return
diff assign to int with diff assign to new_val - arr array of i  
create integer prev_val with prev_val assign to arr array of i  
arr array of i   assign to new_val
if prime array of new_val  prime array of prev_val  )  if not prime array of prev_val  , updateValueUtil ( st, 0, n - 1, i, new_val, 0 )
else if prime array of new_val  is true, call updateValueUtil (st, 0, n - 1, i, - prev_val, 0 )
else updateValueUtil ( st, 0, n - 1, i, diff, 0 )
if qs  0 qe > n - 1 qs > qe print "" - 1""
return -1
return getSumUtil ( st, 0, n - 1, qs, qe, 0 )
if ss is se, st is equal to prime array of arr array of ss    , st array of si   is equal to arr array of ss  
else st array of si  assign to 0
return st array of si 
mid assign to int with mid assign to getMid ( ss, se )
st array of si  assign to constructSTUtil ( arr, ss, mid, st, si * 2 + 1 ) + constructSTUtil ( arr, mid + 1, se, st, si * 2 + 2)
return st array of si 
declare integer variable constructST with integer arr array of  , integer n, integer x assign to ( integer ) ( ceil ( log2 ( n ) ) ) as arguments
max_size assign to 2 * ( int ) pow ( 2, x ) - 1
create integer * st with st assign to new integer array of size max_size
create constructSTUtil ( arr, 0, n - 1, st, 0 )
return st
declare integer main ( ), integer arr array of   assign to  1, 3, 5, 7, 9, 11  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
Q assign to integer array of size 3 and 3 with Q assign to   1, 1, 3 ,  2, 1, 10 ,  1, 1, 3
call SieveOfEratosthenes ( )
create integer st with st assign to constructST ( arr, n )
print getSum ( st, n, 1, 3 ) and a new line
updateValue ( arr, st, n, 1, 10 )
print getSum ( st, n, 1, 3 ) and a new line
return 0
","Maximum subarray sum by flipping signs of at most K array elements 
 C ++ implementation of the approach ; Function to find the maximum subarray sum with flips starting from index i ; If the number of flips have exceeded ; Complete traversal ; If the state has previously been visited ; Initially ; Use Kadane 's algorithm and call two states ; Memoize the answer and return it ; Utility function to call flips from index and return the answer ; Create DP array int dp array of n   array of k + 1   ; ; Iterate and call recursive function from every index to get the maximum subarray sum ; corner case ; Driver Code
",0
280,"mod assign to integer with mod assign to 1000000007
create integer dp with size 1000 by 1000
declare integer variable calculate ( integers pos, prev, string s, vector  integer > * index ) if pos is length of s, return 1
if dp array of pos   array of prev   is not -1, return dp array of pos   array of prev  
create integer c with c assign to s array of pos   -'a'
answer assign to integer with answer assign to 0
untill i assign to 0 to size of index, increment i if index array of i   is greater than prev, set answer to ( answer modulo mod + calculate ( pos + 1, index array of i  , s, index ) modulo mod ) modulo mod
return dp array of pos   array of prev   assign to answer
declare integer countWays ( vector  string > & a, string s )  integer n assign to size of a
create vector  integer > index array of 26  
untill i assign to 0 to n exclusive, increment j by 1 and index array of a array of i  array of j   -'a' . push_back ( j + 1 )
print memset ( dp, -1, sizeof ( dp ) )
return calculate ( 0, 0, s, index )
declare integer main ( ), vector, string > A
push_back A. adc
push_back A. aec
push_back A. push_back ( "" erg "" )
create string S with S assign to "" ac ""
print countWays ( A, S )
return 0
","Count the number of ways to construct the target string 
 C ++ Program to Count the number of ways to construct the target string ; base case ; If current subproblem has been solved , use the value ; current character ; search through all the indiced at which the current character occurs . For each index greater than prev , take the index and move to the next position , and add to the answer . ; Store and return the solution untill this subproblem ; preprocess the strings by storing untill each character of every string , the index of their occurrence we will use a common list untill all because of only the index matter in the string from which the character was picked ; we are storing j + 1 because the initial picked index in the recursive step will ne 0. This is just untill ease of implementation ; initialise dp table . - 1 represents that the subproblem hasn 't been solved ; Driver Code
",1
281,"mod assign to integer with mod assign to 1000000007
create integer dp with size 1000 by 1000
declare integer variable calculate ( integers pos, prev, string s, vector  integer > * index ) if pos is length of s, return 1
if dp array of pos   array of prev   is not -1, return dp array of pos   array of prev  
create integer c with c assign to s array of pos   -'a'
answer assign to integer with answer assign to 0
untill i assign to 0 to size of index, increment i if index array of i   is greater than prev, set answer to ( answer modulo mod + calculate ( pos + 1, index array of i  , s, index ) modulo mod ) modulo mod
return dp array of pos   array of prev   assign to answer
declare integer countWays ( vector  string > & a, string s )  integer n assign to size of a
create vector  integer > index array of 26  
untill i assign to 0 to n exclusive, increment j by 1 and index array of a array of i  array of j   -'a' . push_back ( j + 1 )
print memset ( dp, -1, sizeof ( dp ) )
return calculate ( 0, 0, s, index )
declare integer main ( ), vector, string > A
push_back A. adc
push_back A. aec
push_back A. push_back ( "" erg "" )
create string S with S assign to "" ac ""
print countWays ( A, S )
return 0
","Length of longest rod that can fit into a cuboid 
 C ++ program to find the longest rod that can fit in a cuboid ; Function to find the length ; temporary variable to hold the intermediate result ; length of longest rod is calculated using square root function ; Driver code ; calling longestRodInCuboid ( ) function to get the length of longest rod
",0
282,"dp assign to 0005 integer array of size MAX, 101, 2
declare countNum with integers idx, sum, k, vector  integers num, len, k, if len is idx, return 1
else return 0
if dp array of idx   array of sum   array of tight   is not -1, return dp array of idx   array of sum   array of tight  
create integers res, limit with res assign to 0 and limit
if tight is 0, limit assign to num array of idx  
else set limit to 9
untill i assign to 0 to limit inclusive, new_tight assign to tight
if tight is 0 and i is less than limit, set new_tight to 1
increment res by countNum ( idx + 1, sum + i ) % k, new_tight, num, len, k )
res assign to res modulo MOD
if res is less than 0, increment res by MOD
return dp array of idx   array of sum   array of tight   assign to res
create vectors, integers, integers, num, create vectors, create integers, create integers, create vectors, create integers with value num
untill i assign to 0 to length of s exclusive, push_back ( s array of i   - '0' ) num
return num
declare integer main ( ) and string n assign to ""98765432109876543210""
create integer len with len assign to length of n
create integer k with k assign to 58
set all contents of dp to -1
num assign to vector of integers with num assign to process ( n )
print countNum ( 0, 0, 0, 0, 0, num, len, k )
return 0
","Count of integers from the range array of 0 , N   whose digit sum is a multiple of K 
 C ++ implementation of the approach ; To store the states of the dp ; Function to return the count of numbers from the range array of 0 , n   whose digit sum is a multiple of k using bottom - up dp ; The digit in this index can only be from array of 0 , num array of idx     ; The digit in this index can be anything from array of 0 , 9   ; new_tight is the flag value untill the next position ; res can 't be negative ; Function to process the string to a vector of digits from MSD to LSD ; Driver code ; For large input number n ; Total number of digits in n ; Clean dp table ; Process the string to a vector of digits from MSD to LSD
",1
283,"dp assign to 0005 integer array of size MAX, 101, 2
declare countNum with integers idx, sum, k, vector  integers num, len, k, if len is idx, return 1
else return 0
if dp array of idx   array of sum   array of tight   is not -1, return dp array of idx   array of sum   array of tight  
create integers res, limit with res assign to 0 and limit
if tight is 0, limit assign to num array of idx  
else set limit to 9
untill i assign to 0 to limit inclusive, new_tight assign to tight
if tight is 0 and i is less than limit, set new_tight to 1
increment res by countNum ( idx + 1, sum + i ) % k, new_tight, num, len, k )
res assign to res modulo MOD
if res is less than 0, increment res by MOD
return dp array of idx   array of sum   array of tight   assign to res
create vectors, integers, integers, num, create vectors, create integers, create integers, create vectors, create integers with value num
untill i assign to 0 to length of s exclusive, push_back ( s array of i   - '0' ) num
return num
declare integer main ( ) and string n assign to ""98765432109876543210""
create integer len with len assign to length of n
create integer k with k assign to 58
set all contents of dp to -1
num assign to vector of integers with num assign to process ( n )
print countNum ( 0, 0, 0, 0, 0, num, len, k )
return 0
","Rearrange positive and negative numbers with constant extra space 
 C ++ implementation of the above approach ; Loop until arr array of i   < 0 and still inside the array ; Loop until arr array of j   > 0 and still inside the array ; if i is less than j ; Driver Code
",0
284,"create integer dp array of maxN  array of maxW  array of maxW 
if i is equal to n, return 0
if dp array of i   array of w1_r   array of w2_r   is not -1, return dp array of i   array of w1_r   array of w2_r  
create integers fill_w1, fill_w2 with fill_w1 assign to 0, fill_w2 assign to 0 and fill_none assign to 0
if w1_r >assign to arr array of i , fill_w1 assign to arr array of i   + maxWeight ( arr, n, w1_r - arr array of i  , w2_r, i + 1 )
if w2_r >assign to arr array of i  , fill_w2 assign to arr array of i   + maxWeight ( arr, n, w1_r, w2_r - arr array of i  , i + 1 )
fill_none assign to maxWeight ( arr, n, w1_r, w2_r, i + 1)
dp array of i   array of w1_r   array of w2_r   assign to max ( fill_none, max ( fill_w1, fill_w2 ) )
return dp array of i  array of w1_r  array of w2_r 
declare integer variable main with name arr with value 8, 2, 3
set all contents of dp to -1
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create integers w1, w2 with w1 assign to 10 and w2 assign to 3
print maxWeight ( arr, n, w1, w2, 0 )
return 0
","Double Knapsack 
 Dynamic Programming 
 C ++ implementation of the above approach ; 3D array to store states of DP ; w1_r represents remaining capacity of 1 st knapsack w2_r represents remaining capacity of 2 nd knapsack i represents index of the array arr we are working on ; Base case ; Variables to store the result of three parts of recurrence relation ; Store the state in the 3D array ; Driver code ; Input array ; Initializing the array with - 1 ; Number of elements in the array ; Capacity of knapsacks ; Function to be called
",1
285,"create integer dp array of maxN  array of maxW  array of maxW 
if i is equal to n, return 0
if dp array of i   array of w1_r   array of w2_r   is not -1, return dp array of i   array of w1_r   array of w2_r  
create integers fill_w1, fill_w2 with fill_w1 assign to 0, fill_w2 assign to 0 and fill_none assign to 0
if w1_r >assign to arr array of i , fill_w1 assign to arr array of i   + maxWeight ( arr, n, w1_r - arr array of i  , w2_r, i + 1 )
if w2_r >assign to arr array of i  , fill_w2 assign to arr array of i   + maxWeight ( arr, n, w1_r, w2_r - arr array of i  , i + 1 )
fill_none assign to maxWeight ( arr, n, w1_r, w2_r, i + 1)
dp array of i   array of w1_r   array of w2_r   assign to max ( fill_none, max ( fill_w1, fill_w2 ) )
return dp array of i  array of w1_r  array of w2_r 
declare integer variable main with name arr with value 8, 2, 3
set all contents of dp to -1
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create integers w1, w2 with w1 assign to 10 and w2 assign to 3
print maxWeight ( arr, n, w1, w2, 0 )
return 0
","Check if minimum element in array is less than or equals half of every other element 
 C ++ implementation to Check if the minimum element in the array is greater than or equal to half of every other elements ; Function to Check if the minimum element in the array is greater than or equal to half of every other element ; Initialise the variables to store smallest and second smallest ; Check if current element is smaller than smallest , the current smallest will become secondSmallest and current element will be the new smallest ; Check if current element is smaller than secondSmallest simply update the latter ; Driver code
",0
286,"untill i assign to 0 to n exclusive, continue loop, if j is greater than or equal to 0 or j is greater than or equal to set_bit array of i   array of j  , continue loop
if j is not n - 1, increment p_arr array of i   array of j   by p_arr array of i   array of j + 1  
increment p_arr array of i   array of j   by ( integer ) set_bit array of i   array of j  
p_arr assign to bool set_bit array of   array of n  , p_arr assign to p_arr assign to 0
call findPrefixCount ( p_arr, set_bit )
ans assign to integer with ans assign to 0
untill j assign to 0 to n exclusive, i assign to n - 1
create stack  pair  integer, integer > > q
create integer to_sum with to_sum assign to 0
untill i >assign to 0, c assign to integer with c assign to 0
untill size of q is not 0 and top ( ) is not equal to to_sum, decrease to_sum by ( q. top ( ). second + 1 ) * ( q. top ( ). first - p_arr array of i   array of j   ) )
increment c by q. top ( ). second + 1
pop assign to q. pop assign to q
increment to_sum by p_arr array of i   array of j  
increment ans by to_sum
push q, c, p_arr array of i   array of j  , c  )
decrement i
return ans
sumAndMatrix assign to integer with sum assign to 0
create integer mul with mul assign to 1
untill i assign to 0 to 30 exclusive, set_bit assign to bool array of n   array of n  
untill R assign to 0 to n exclusive set_bit array of R  array of C  assign to ( arr array of R  array of C  & ( 1  i ) )not equal to 0 )
increment sum by ( mul * matrixAllOne ( set_bit ) ) )
mul assign to mul * 2
return sum
declare integer main ( ) and integer array arr with size n   assign to  9, 7, 4 , 8, 9, 2 , 11, 5               9, 7, 4 , 8, 9, 2 , 11, 5
print sumAndMatrix ( arr)
return 0
","Sum of bitwise AND of all submatrices 
 C ++ program to find sum of Bit - wise AND of all submatrices ; Function to find prefix - count untill each row from right to left ; Function to find the number of submatrices with all 1 s ; Array to store required prefix count of 1 s from right to left untill boolean array ; Variable to store the final answer ; For each index of a column , determine the number of sub - matrices starting from that index and has all 1 s ; Stack to store elements and the count of the numbers they popped First part of pair is value of inserted element Second part is count of the number of elements pushed beuntille with a greater value ; variable to store the number of submatrices with all 1 s ; Function to find the sum of Bitwise - AND of all submatrices ; matrix to store the status of ith bit of each element of matrix arr ; Driver Code
",1
287,"untill i assign to 0 to n exclusive, continue loop, if j is greater than or equal to 0 or j is greater than or equal to set_bit array of i   array of j  , continue loop
if j is not n - 1, increment p_arr array of i   array of j   by p_arr array of i   array of j + 1  
increment p_arr array of i   array of j   by ( integer ) set_bit array of i   array of j  
p_arr assign to bool set_bit array of   array of n  , p_arr assign to p_arr assign to 0
call findPrefixCount ( p_arr, set_bit )
ans assign to integer with ans assign to 0
untill j assign to 0 to n exclusive, i assign to n - 1
create stack  pair  integer, integer > > q
create integer to_sum with to_sum assign to 0
untill i >assign to 0, c assign to integer with c assign to 0
untill size of q is not 0 and top ( ) is not equal to to_sum, decrease to_sum by ( q. top ( ). second + 1 ) * ( q. top ( ). first - p_arr array of i   array of j   ) )
increment c by q. top ( ). second + 1
pop assign to q. pop assign to q
increment to_sum by p_arr array of i   array of j  
increment ans by to_sum
push q, c, p_arr array of i   array of j  , c  )
decrement i
return ans
sumAndMatrix assign to integer with sum assign to 0
create integer mul with mul assign to 1
untill i assign to 0 to 30 exclusive, set_bit assign to bool array of n   array of n  
untill R assign to 0 to n exclusive set_bit array of R  array of C  assign to ( arr array of R  array of C  & ( 1  i ) )not equal to 0 )
increment sum by ( mul * matrixAllOne ( set_bit ) ) )
mul assign to mul * 2
return sum
declare integer main ( ) and integer array arr with size n   assign to  9, 7, 4 , 8, 9, 2 , 11, 5               9, 7, 4 , 8, 9, 2 , 11, 5
print sumAndMatrix ( arr)
return 0
","Ways to Remove Edges from a Complete Graph to make Odd Edges 
 C ++ implementation of the approach ; Function to return the number of ways to remove edges from the graph so that odd number of edges are left in the graph ; Total number of edges ; Driver code
",0
288,"declare integer CountWays with integer n as argument, returning integer noOfWays with 3 elements
noOfWays array of 0   assign to 1
noOfWays array of 1   assign to 1
noOfWays array of 2  assign to 1 + 1
untill i assign to 3 to n + 1 exclusive, set noOfWays array of i   to noOfWays array of 3 - 1   + noOfWays array of 3 - 3  
noOfWays array of 0   assign to noOfWays array of 1  
noOfWays array of 1  assign to noOfWays array of 2 
noOfWays array of 2  assign to noOfWays array of i  
return noOfWays array of n  
declare integer main ( ) and integer n assign to 5
print CountWays ( n )
return 0
","Count ways to reach a score using 1 and 2 with no consecutive 2 s 
 Bottom up approach untill counting ways to reach a score using 1 and 2 with consecutive 2 allowed ; noOfWays array of i   will store count untill last 3 values beuntille i . ; Loop till "" n + 1"" to compute value untill "" n "" ; number of ways if first run is 1 ; number of ways if first run is 2 and second run is 1 ; Remember last 3 values ; Driver code
",1
289,"declare integer CountWays with integer n as argument, returning integer noOfWays with 3 elements
noOfWays array of 0   assign to 1
noOfWays array of 1   assign to 1
noOfWays array of 2  assign to 1 + 1
untill i assign to 3 to n + 1 exclusive, set noOfWays array of i   to noOfWays array of 3 - 1   + noOfWays array of 3 - 3  
noOfWays array of 0   assign to noOfWays array of 1  
noOfWays array of 1  assign to noOfWays array of 2 
noOfWays array of 2  assign to noOfWays array of i  
return noOfWays array of n  
declare integer main ( ) and integer n assign to 5
print CountWays ( n )
return 0
","Check if a string can be split into even length palindromic substrings 
 C ++ program untill the above approach ; Function to check string str can be split a string into even length palindromic substrings ; Initialize a stack ; Iterate the string ; If the i - th character is same as that at the top of the stack then pop the top element ; Else push the current charactor into the stack ; If the stack is empty , then even palindromic substrings are possible ; Else not - possible ; Driver Code ; Given string ; Function Call
",0
290,"untill i assign to 2 to MAX inclusive, increment j by i, prime array ofj   assign to 1
if mappedMatrix array of i   array of MAX   is 0 or i > n or j > m or mark array of i   array of j   or ( * q ) return void
mark array of i   array of j   assign to 1
ans array of k   assign to make_pair ( i, j )
if i is n and j is m, set k to k
return
dfs ( i + 1, j + 1, k + 1, q, n, m, mappedMatrix, mark, ans )
dfs ( i + 1, j, k + 1, q, n, m, mappedMatrix, mark, ans )
dfs ( i, j + 1, k + 1, q, n, m, mappedMatrix, mark, ans )
lexicographicalPath assign to void with integers n, m, mappedMatrix assign to 0 and q assign to 0
create pair  int, int > ans array of MAX  
create integer mark array of MAX   array of MAX  
dfs assign to 1, 1, 1, & q, n, m, mappedMatrix, mark, ans
untill i assign to 1 to q inclusive, print ans array of i  . first, "" "", ans array of i  . second, "" STRNEWLINE ""
void function countPrimePath (int mappedMatrix array of   array of MAX , int n, int m ), int dp array of MAX   array of MAX   assign to 0
set dp array of 1   array of 1   to 1
untill i assign to 1 to n inclusive, continue loop if j assign to 1, j assign to m, if i assign to 1 and j assign to 1
dp array ofi  array ofj  assign to ( dp array of i - 1   array of j   + dp array of i   array of j - 1   + dp array of i - 1   array of j - 1   + dp array of i - 1   array of j - 1   array of j - 1   )
if mappedMatrix array of i   array of j   is 0, dp array of i   array of j   is equal to 0
print dp array of n   array of m   and "" STRNEWLINE ""
declare preprocessMatrix with integers mappedMatrix array of   array of MAX , a array of   array of MAX  , n, m, prime as arguments, returning void
sieve assign to sieve ( prime )
untill i assign to 0 to n exclusive, set mappedMatrix array of i + 1   array of j + 1   to 1
else mappedMatrix array of i + 1   array of j + 1   assign to 0
declare integer main with n assign to 3
create integer m with m assign to 3
create integer a with MAX   array of MAX  assign to  2, 3, 7 , 5, 4, 2 , 3, 7, 11
create integer mappedMatrix array of MAX  array of MAX  assign to  0
preprocessMatrix ( mappedMatrix, a, n, m )
countPrimePath is a new function called countPrimePath ( mappedMatrix, n, m )
create lexicographicalPath ( n, m, mappedMatrix )
return 0
","Lexicographically largest prime path from top 
 C ++ implementation of above approach ; Depth First Search ; Return if cell contain non prime number or obstacle , or going out of matrix or already visited the cell or already found the lexicographical largest path ; marking cell is already visited ; storing the lexicographical largest path index ; if reached the end of the matrix ; updating the final number of steps in lexicographical largest path ; moving diagonal ( trying lexicographical largest path ) ; moving cell right to current cell ; moving cell down to current cell . ; Print lexicographical largest prime path ; to count the number of step in lexicographical largest prime path ; to store the lexicographical largest prime path index ; to mark if the cell is already traversed or not ; traversing by DFS ; printing the lexicographical largest prime path ; Return the number of prime path in ther matrix . ; untill each cell ; If on the top row or leftmost column , there is no path there . ; If non prime number ; Finding the matrix mapping by considering non prime number as obstacle and prime number be valid path . ; Sieve ; If prime ; if non prime ; Driver code
",1
291,"untill i assign to 2 to MAX inclusive, increment j by i, prime array ofj   assign to 1
if mappedMatrix array of i   array of MAX   is 0 or i > n or j > m or mark array of i   array of j   or ( * q ) return void
mark array of i   array of j   assign to 1
ans array of k   assign to make_pair ( i, j )
if i is n and j is m, set k to k
return
dfs ( i + 1, j + 1, k + 1, q, n, m, mappedMatrix, mark, ans )
dfs ( i + 1, j, k + 1, q, n, m, mappedMatrix, mark, ans )
dfs ( i, j + 1, k + 1, q, n, m, mappedMatrix, mark, ans )
lexicographicalPath assign to void with integers n, m, mappedMatrix assign to 0 and q assign to 0
create pair  int, int > ans array of MAX  
create integer mark array of MAX   array of MAX  
dfs assign to 1, 1, 1, & q, n, m, mappedMatrix, mark, ans
untill i assign to 1 to q inclusive, print ans array of i  . first, "" "", ans array of i  . second, "" STRNEWLINE ""
void function countPrimePath (int mappedMatrix array of   array of MAX , int n, int m ), int dp array of MAX   array of MAX   assign to 0
set dp array of 1   array of 1   to 1
untill i assign to 1 to n inclusive, continue loop if j assign to 1, j assign to m, if i assign to 1 and j assign to 1
dp array ofi  array ofj  assign to ( dp array of i - 1   array of j   + dp array of i   array of j - 1   + dp array of i - 1   array of j - 1   + dp array of i - 1   array of j - 1   array of j - 1   )
if mappedMatrix array of i   array of j   is 0, dp array of i   array of j   is equal to 0
print dp array of n   array of m   and "" STRNEWLINE ""
declare preprocessMatrix with integers mappedMatrix array of   array of MAX , a array of   array of MAX  , n, m, prime as arguments, returning void
sieve assign to sieve ( prime )
untill i assign to 0 to n exclusive, set mappedMatrix array of i + 1   array of j + 1   to 1
else mappedMatrix array of i + 1   array of j + 1   assign to 0
declare integer main with n assign to 3
create integer m with m assign to 3
create integer a with MAX   array of MAX  assign to  2, 3, 7 , 5, 4, 2 , 3, 7, 11
create integer mappedMatrix array of MAX  array of MAX  assign to  0
preprocessMatrix ( mappedMatrix, a, n, m )
countPrimePath is a new function called countPrimePath ( mappedMatrix, n, m )
create lexicographicalPath ( n, m, mappedMatrix )
return 0
","Range Query on array whose each element is XOR of index value and previous element 
 CPP Program to solve range query on array whose each element is XOR of index value and previous element . ; function return derived untillmula value . ; finding xor value of range array of y ... x   ; function to solve query untill l and r . ; if l or r is 0. ; finding x is divisible by 2 or not . ; Driven Program
",0
292,"declare isSubsetSum with integers set array of  , n, sum as arguments, returning integer, returning integer subset array of sum + 1   array of n + 1  
count assign to integer array of size sum + 1, n + 1, count assign to integer
untill i assign to 0 to n inclusive, subset array of 0   array of i   assign to true
set count array of 0   array of i   to 0
untill i assign to 1 to sum inclusive, subset array of i   array of 0   assign to false
set count array of i   array of 0   to -1
untill i assign to 1 to sum inclusive, subset array of i   array of j   assign to subset array of i   array of j - 1  
count array of i   array of j   assign to count array of i   array of j - 1  
if i >assign to set array of j - 1  , subset array of i   array of j   assign to subset array of i   array of j   

 subset array of i - set array of j - 1    array of j - 1  
if subset array of i   array of j  , count array of i   array of j - 1  , count array of i - set array of j - 1   array of j - 1   + 1 )
return count array of sum  array of n  
declare integer main ( ), integer set assign to  2, 3, 5, 10  ;
create integer sum with sum assign to 20
create integer n with n assign to 4
print isSubsetSum ( set, n, sum)
","Maximum size subset with given sum 
 A Dynamic Programming solution untill subset sum problem + maximal subset value . ; Returns size of maximum sized subset if there is a subset of set array of   with sun equal to given sum . It returns - 1 if there is no subset with given sum . ; The value of subset array of i   array of j   will be true if there is a subset of set array of 0. . j - 1   with sum equal to i ; If sum is 0 , then answer is true ; If sum is not 0 and set is empty , then answer is false ; Fill the subset table in bottom up manner ; Driver code
",1
293,"declare isSubsetSum with integers set array of  , n, sum as arguments, returning integer, returning integer subset array of sum + 1   array of n + 1  
count assign to integer array of size sum + 1, n + 1, count assign to integer
untill i assign to 0 to n inclusive, subset array of 0   array of i   assign to true
set count array of 0   array of i   to 0
untill i assign to 1 to sum inclusive, subset array of i   array of 0   assign to false
set count array of i   array of 0   to -1
untill i assign to 1 to sum inclusive, subset array of i   array of j   assign to subset array of i   array of j - 1  
count array of i   array of j   assign to count array of i   array of j - 1  
if i >assign to set array of j - 1  , subset array of i   array of j   assign to subset array of i   array of j   

 subset array of i - set array of j - 1    array of j - 1  
if subset array of i   array of j  , count array of i   array of j - 1  , count array of i - set array of j - 1   array of j - 1   + 1 )
return count array of sum  array of n  
declare integer main ( ), integer set assign to  2, 3, 5, 10  ;
create integer sum with sum assign to 20
create integer n with n assign to 4
print isSubsetSum ( set, n, sum)
","Minimize Array length by repeatedly replacing co 
 C ++ Program untill the above approach ; Function to find the final array length by replacing coprime pair with 1 ; Iterate over all pairs of element ; Check if gcd is 1 ; If no coprime pair found return false ; Driver code ; Check if atleast one coprime pair exists in the array ; If no such pair exists
",0
294,"create integer lcslen with lcslen assign to 0
create integer dp array of MAX  array of MAX 
lcs assign to integer with str1, str2, len1, len2, int i, j assign to integer, ret assign to dp array of i  array of j 
if i is len1 j is len2 return ret assign to 0
if ret is not -1, return ret
set ret to 0
if str1 array ofi  is str2 array ofj , set ret to 1 + lcs ( str1, str2, len1, len2, i + 1, j + 1)
else ret assign to max ( lcs ( str1, str2, len1, len1, len2, i + 1, j ), lcs ( str1, str2, len1, len2, i, j + 1 ) )
return ret
if currlcs is lcslen, printAll is a void function
print data
return
if indx1 is len1 indx2 is len2, return ;
untill ch assign to'a ', ch assign to'z ', do assign to false
untill i assign to indx1 ; i  len1 ; i ++ ) if ch assign to str1 array of i  , if ch assign to str2 array of j   && dp array of i   array of j   assign to lcslen - currlcs, data array of currlcs   assign to ch
printAll ( str1, str2, len1, len2, data, i + 1, j + 1, currlcs + 1)
set done to true
break loop
if done is true, break loop
let prinlAllLCSSorted ( string str1, str2) be a void, len1 assign to str1. length ( ) and len2 assign to str2. length ( )
set all contents of dp to -1
set lcslen to lcs ( str1, str2, len1, len2, 0, 0 )
create character data array of MAX 
printAll ( str1, str2, len1, len2, data, 0, 0, 0 )
declare integer main ( ), string str1 assign to abcabcaa "", str2 assign to "" acbacba ""
declare prinlAllLCSSorted ( str1, str2 )
return 0
","Print all longest common sub 
 C ++ program to find all LCS of two strings in sorted order . ; length of lcs ; dp matrix to store result of sub calls untill lcs ; A memoization based function that returns LCS of str1 array of i . . len1 - 1   and str2 array of j . . len2 - 1   ; base condition ; if lcs has been computed ; if characters are same return previous + 1 else max of two sequences after removing i ' th â– and â– j ' th char one by one ; Function to print all routes common sub - sequences of length lcslen ; if currlcs is equal to lcslen then print it ; if we are done with all the characters of both string ; here we have to print all sub - sequences lexicographically , that ' s â– why â– we â– start â– from â– ' a ' to ' z ' if this character is  present in both of them then append it in dataarray of  and same  remaining part ; done is a flag to tell that we have printed all the subsequences corresponding to current character ; if character ch is present in str1 then check if it is present in str2 ; if ch is present in both of them and remaining length is equal to remaining lcs length then add ch in sub - sequenece ; If we found LCS beginning with current character . ; This function prints all LCS of str1 and str2 in lexicographic order . ; Find lengths of both strings ; Find length of LCS ; Print all LCS using recursive backtracking data array of   is used to store individual LCS . ; Driver program to run the case
",1
295,"create integer lcslen with lcslen assign to 0
create integer dp array of MAX  array of MAX 
lcs assign to integer with str1, str2, len1, len2, int i, j assign to integer, ret assign to dp array of i  array of j 
if i is len1 j is len2 return ret assign to 0
if ret is not -1, return ret
set ret to 0
if str1 array ofi  is str2 array ofj , set ret to 1 + lcs ( str1, str2, len1, len2, i + 1, j + 1)
else ret assign to max ( lcs ( str1, str2, len1, len1, len2, i + 1, j ), lcs ( str1, str2, len1, len2, i, j + 1 ) )
return ret
if currlcs is lcslen, printAll is a void function
print data
return
if indx1 is len1 indx2 is len2, return ;
untill ch assign to'a ', ch assign to'z ', do assign to false
untill i assign to indx1 ; i  len1 ; i ++ ) if ch assign to str1 array of i  , if ch assign to str2 array of j   && dp array of i   array of j   assign to lcslen - currlcs, data array of currlcs   assign to ch
printAll ( str1, str2, len1, len2, data, i + 1, j + 1, currlcs + 1)
set done to true
break loop
if done is true, break loop
let prinlAllLCSSorted ( string str1, str2) be a void, len1 assign to str1. length ( ) and len2 assign to str2. length ( )
set all contents of dp to -1
set lcslen to lcs ( str1, str2, len1, len2, 0, 0 )
create character data array of MAX 
printAll ( str1, str2, len1, len2, data, 0, 0, 0 )
declare integer main ( ), string str1 assign to abcabcaa "", str2 assign to "" acbacba ""
declare prinlAllLCSSorted ( str1, str2 )
return 0
","Check if a string can be transuntillmed to another by sorting substrings 
 C ++ Program to implement the above approach ; Function to check if str1 can be transuntillmed to t by sorting substrings ; Occur array of i   stores the indices of char ( ' a ' + i ) in string s ; idx array of i   stores the next available index of char ( ' a ' + i ) in occur array of i   ; If this char is not available anymore ; Conversion not possible ; If one of the smaller characters is available and occurs beuntille ; Conversion not possible ; Print the answer ; Driver Code
",0
296,"declare isMajority with integers arr array of  , n, x as arguments, returning boolean, returning boolean, returning i
let last_index be a integer with last_index assign to n % 2 if n / 2 + 1 is true else n / 2
untill i assign to 0 to last_index exclusive, return 1 if arr array of i   is x and arr array of i + n / 2   is x
return 0
declare integer main ( ), integer arr assign to  1, 2, 3, 4, 4, 4, 4, 4 , integer array arr assign to  1, 2, 3, 4, 4, 4 , 4
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create integer x with x assign to 4
if isMajority ( arr, n, x ) ), print x, appears more than "", n / 2 and times in arr array of   ""
else print x, "" does not appear more than "", n / 2 and "" times in arr array of   ""
return 0
","Check untill Majority Element in a sorted array 
 C ++ Program to check untill majority element in a sorted array ; get last index according to n ( even or odd ) ; search untill first occurrence of x in arr array of   ; check if x is present and is present more than n / 2 times ; Driver code
",1
297,"declare isMajority with integers arr array of  , n, x as arguments, returning boolean, returning boolean, returning i
let last_index be a integer with last_index assign to n % 2 if n / 2 + 1 is true else n / 2
untill i assign to 0 to last_index exclusive, return 1 if arr array of i   is x and arr array of i + n / 2   is x
return 0
declare integer main ( ), integer arr assign to  1, 2, 3, 4, 4, 4, 4, 4 , integer array arr assign to  1, 2, 3, 4, 4, 4 , 4
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create integer x with x assign to 4
if isMajority ( arr, n, x ) ), print x, appears more than "", n / 2 and times in arr array of   ""
else print x, "" does not appear more than "", n / 2 and "" times in arr array of   ""
return 0
","Make given segments non 
 C ++ program untill the above approach ; Stores the details of the Segment ; Function to check whether the graph is bipartite or not ; Mark source node as visited ; Push the source vertex in queue ; Get the front of the queue ; Assign the color to the popped node ; Traverse the adjacency list of the node u ; If any node is visited & a different colors has been assigned , then return false ; Set visited array of x   ; Push the node x into the queue ; Update color of node ; If the graph is bipartite ; Function to add an edge between the nodes u and v ; Function to check if the assignment of direction can be possible to all the segments , such that they do not intersect after a long period of time ; Stores the adjacency list of the created graph ; Generate all possible pairs ; If segments do not overlap ; Otherwise , the segments overlap ; If both segments have same speed , then add an edge ; Keep the track of visited nodes ; Iterate untill all possible nodes ; Check whether graph is bipartite or not ; If the graph is bipartite ; Driver Code
",0
298,"declare _binarySearch with integer arr array of  , integer high, integer x, if high >assign to low, mid assign to ( low + high ) / 2 as arguments, returning integer
if mid is 0 x > arr array of mid - 1   ) and arr array of mid   is x return mid
else if x is greater than arr array of mid , return _binarySearch ( arr, ( mid + 1) ), high, x )
else return _binarySearch ( arr, low, ( mid - 1 ), x )
return -1
declare isMajority with integers arr array of  , n, x, i assign to _binarySearch ( arr, 0, n - 1, x ) as arguments, returning boolean
if i is -1, return false
if ( i + n / 2 ) assign to ( n - 1 ) ) && arr array of i + n / 2   is x, return true
else return false
declare integer main ( ), integer arr assign to  1, 2, 3, 3, 3, 3, 3, 3, 3, 10
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create integer x with x assign to 3
if isMajority ( arr, n, x ) ), print x, appears more than "", n / 2 and times in arr array of   ""
else print x, "" does not appear more than "", n / 2 and "" times in arr array of   ""
return 0
","Check untill Majority Element in a sorted array 
 C ++ program to check untill majority element in a sorted array ; If x is present in arr array of low ... high   then returns the index of first occurrence of x , otherwise returns - 1 ; Check if arr array of mid   is the first occurrence of x . arr array of mid   is first occurrence if x is one of the following is true : ( i ) mid equal to 0 and arr array of mid   assign to assign to x ( ii ) arr array of mid - 1   < x and arr array of mid   equal to x ; This function returns true if the x is present more than n / 2 times in arr array of   of size n ; Find the index of first occurrence of x in arr array of   ; If element is not present at all , return false ; Check if the element is present more than n / 2 times ; Driver code
",1
299,"declare _binarySearch with integer arr array of  , integer high, integer x, if high >assign to low, mid assign to ( low + high ) / 2 as arguments, returning integer
if mid is 0 x > arr array of mid - 1   ) and arr array of mid   is x return mid
else if x is greater than arr array of mid , return _binarySearch ( arr, ( mid + 1) ), high, x )
else return _binarySearch ( arr, low, ( mid - 1 ), x )
return -1
declare isMajority with integers arr array of  , n, x, i assign to _binarySearch ( arr, 0, n - 1, x ) as arguments, returning boolean
if i is -1, return false
if ( i + n / 2 ) assign to ( n - 1 ) ) && arr array of i + n / 2   is x, return true
else return false
declare integer main ( ), integer arr assign to  1, 2, 3, 3, 3, 3, 3, 3, 3, 10
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create integer x with x assign to 3
if isMajority ( arr, n, x ) ), print x, appears more than "", n / 2 and times in arr array of   ""
else print x, "" does not appear more than "", n / 2 and "" times in arr array of   ""
return 0
","Form minimum number from given sequence 
 C ++ program to print minimum number that can be untillmed from a given sequence of Is and Ds ; min_avail represents the minimum number which is still available untill inserting in the output vector . pos_of_I keeps track of the most recent index where ' I ' was encountered w . r . t the output vector ; vector to store the output ; cover the base cases ; Traverse rest of the input ; print the number ; Driver program to check the above function
",0
300,"if arr array of  , n, key, return true
else return false
declare integer main ( ), integer arr assign to  1, 2, 3, 3, 3, 3, 3, 3, 3, 10
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create integer x with x assign to 3
if isMajorityElement ( arr, n, x ) ), print x, appears more than "", n / 2 and times in arr array of   ""
else print x, "" does not appear more than "", n / 2 and "" times in arr array of   ""
return 0
","Check untill Majority Element in a sorted array 
  ; 
",1
301,"if arr array of  , n, key, return true
else return false
declare integer main ( ), integer arr assign to  1, 2, 3, 3, 3, 3, 3, 3, 3, 10
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create integer x with x assign to 3
if isMajorityElement ( arr, n, x ) ), print x, appears more than "", n / 2 and times in arr array of   ""
else print x, "" does not appear more than "", n / 2 and "" times in arr array of   ""
return 0
","Number with maximum number of prime factors 
 C ++ program to find integer having maximum number of prime factor in first N natural numbers ; Return smallest number having maximum prime factors . ; default value of boolean is false ; Sieve of eratosthenes ; Storing prime numbers . ; Generating number having maximum prime factors . ; Driven Program
",0
302,"a assign to integer, return a if a > b, else return b
create int cutRod ( int price array of  , int n ) and val array of n + 1  
val array of 0   assign to 0
create integers i, j
untill i assign to 1 to n inclusive, max_val assign to INT_MIN
untill j assign to 0 to i exclusive, max_val assign to max ( max_val, price array of j   + val array of i - j - 1   )
val array of i   assign to max_val
return val array of n  
declare integer main ( ) and integer array arr with arr assign to  1, 5, 8, 9, 10, 17, 17, 20
size assign to integer with size assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print "" Maximum Obtainable Value is "" print cutRod ( arr, size )
read character from the input
return 0
","Cutting a Rod 
 DP 
 A Dynamic Programming solution untill Rod cutting problem ; A utility function to get the maximum of two integers ; Returns the best obtainable price untill a rod of length n and price array of   as prices of different pieces ; Build the table val array of   in bottom up manner and return the last entry from the table ; Driver program to test above functions
",1
303,"a assign to integer, return a if a > b, else return b
create int cutRod ( int price array of  , int n ) and val array of n + 1  
val array of 0   assign to 0
create integers i, j
untill i assign to 1 to n inclusive, max_val assign to INT_MIN
untill j assign to 0 to i exclusive, max_val assign to max ( max_val, price array of j   + val array of i - j - 1   )
val array of i   assign to max_val
return val array of n  
declare integer main ( ) and integer array arr with arr assign to  1, 5, 8, 9, 10, 17, 17, 20
size assign to integer with size assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print "" Maximum Obtainable Value is "" print cutRod ( arr, size )
read character from the input
return 0
","Median of difference of all pairs from an Array 
 C ++ Program to implement the above approach ; Function check if mid can be median index of the difference array ; Size of the array ; Total possible no of pair possible ; The index of the element in the difference of all pairs from the array ; Count the number of pairs having difference <assign to mid ; If the difference between end and first element is less then or equal to mid ; Checking untill the no of element less than or equal to mid is greater than median or not ; Function to calculate the median of differences of all pairs from the array ; Size of the array ; Initialising the low and high ; Binary search ; Calculate mid ; If mid can be the median of the array ; Returning the median of the differences of pairs from the array ; Driver Code
",0
304,"create integer t array of 9   array of 9  
if n is equal to 0 Max_len return 0
if length array of n - 1   is less than or equal to Max_len, t array of n   array of Max_len   assign to max ( price array of n - 1   + un_kp ( price array of n - 1  , n ), un_kp ( price, length, Max_len, n - 1 ) )
else t array of n   array of Max_len   assign to un_kp ( price, length, Max_len, n - 1 )
return t array of n   array of Max_len  
declare integer main ( ), integer price assign to  1, 5, 8, 9, 10, 17, 17, 20  ;
create integer n with n assign to sizeof ( price ) / sizeof ( price array of 0   )
create integer length array of n  
untill i assign to 0 to n exclusive, length array of i   assign to i + 1
create integer Max_len with Max_len assign to n
print "" Maximum obtained value is "" print un_kp ( price, length, n, Max_len ) print newline
","Cutting a Rod 
 DP 
 CPP program untill above approach ; Global Array untill the purpose of memoization . ; A recursive program , using , memoization , to implement the rod cutting problem ( Top - Down ) . ; The maximum price will be zero , when either the length of the rod is zero or price is zero . ; If the length of the rod is less than the maximum length , Max_lene will consider it . Now depending upon the profit , either Max_lene we will take it or discard it . ; If the length of the rod is greater than the permitted size , Max_len we will not consider it . ; Max_lene Max_lenill return the maximum value obtained , Max_lenhich is present at the nth roMax_len and Max_lenth column . ; Driver program to test above functions ; Function Call
",1
305,"create integer t array of 9   array of 9  
if n is equal to 0 Max_len return 0
if length array of n - 1   is less than or equal to Max_len, t array of n   array of Max_len   assign to max ( price array of n - 1   + un_kp ( price array of n - 1  , n ), un_kp ( price, length, Max_len, n - 1 ) )
else t array of n   array of Max_len   assign to un_kp ( price, length, Max_len, n - 1 )
return t array of n   array of Max_len  
declare integer main ( ), integer price assign to  1, 5, 8, 9, 10, 17, 17, 20  ;
create integer n with n assign to sizeof ( price ) / sizeof ( price array of 0   )
create integer length array of n  
untill i assign to 0 to n exclusive, length array of i   assign to i + 1
create integer Max_len with Max_len assign to n
print "" Maximum obtained value is "" print un_kp ( price, length, n, Max_len ) print newline
","Count distinct sequences obtained by replacing all elements of subarrays having equal first and last elements with the first element any number of times 
 C ++ program untill the above approach ; Function to count number of sequences satisfying the given criteria ; Stores the index of the last occurrence of the element ; Initialize an array to store the number of different sequences that are possible of length i ; Base Case ; If no operation is applied on ith element ; If operation is applied on ith element ; Update the last occurrence of curEle ; Finally , print the answer ; Driver Code
",0
306,"create boolean isPossible (int target array of  , int n )  max assign to 0
index assign to integer with index assign to 0
untill i assign to 0 to n exclusive, if max is less than target array of i  , max is equal to target array of i  
set index to i
if max is 1 return true
untill i assign to 0 to n exclusive, if i is not index, set max to max - target array of i  
if max assign to 0 return false
set target array of index  to max
return isPossible ( target, n )
declare integer main ( ), integer target (   assign to  9, 3, 5  )
create integer n with n assign to sizeof ( target ) / sizeof ( target array of 0   )
res assign to bool with res assign to isPossible ( target, n )
if res is true, print YES
else print NO
return 0
","Modify array to another given array by replacing array elements with the sum of the array 
 CPP program to implement the above approach ; Function to check if the arr array of   can be converted to target array of   by replacing any element in arr array of   by the sum of arr array of   ; Store the maximum element ; Store the index of the maximum element ; Traverse the array target array of   ; If current element is greater than max ; If max element is 1 ; Traverse the array , target array of   ; If current index is not equal to maximum element index ; Update max ; If max is less than or equal to 0 , ; Update the maximum element ; Recursively call the function ; Driver Code ; Size of the array
",1
307,"create boolean isPossible (int target array of  , int n )  max assign to 0
index assign to integer with index assign to 0
untill i assign to 0 to n exclusive, if max is less than target array of i  , max is equal to target array of i  
set index to i
if max is 1 return true
untill i assign to 0 to n exclusive, if i is not index, set max to max - target array of i  
if max assign to 0 return false
set target array of index  to max
return isPossible ( target, n )
declare integer main ( ), integer target (   assign to  9, 3, 5  )
create integer n with n assign to sizeof ( target ) / sizeof ( target array of 0   )
res assign to bool with res assign to isPossible ( target, n )
if res is true, print YES
else print NO
return 0
","Check if any anagram of a string is palindrome or not 
  ; function to check whether characters of a string can untillm a palindrome ; Create a count array and initialize all values as 0 ; For each character in input strings , increment count in the corresponding count array ; Count odd occurring characters ; Return true if odd count is 0 or 1 , ; Driver program to test to print printDups
",0
308,"nCr assign to integer with n,r assign to integer, res assign to 1
if r is greater than n - r, set r to n - r
untill i assign to 0 to r exclusive, res assign to res * ( n - i )
res assign to res / ( i + 1 )
return res
declare integer main ( ), integers n assign to 3, m assign to 2 and k assign to 2
print nCr ( n + m, k )
return 0
","Sum of all products of the Binomial Coefficients of two numbers up to K 
 C ++ implementation of the above approach ; Function returns nCr i . e . Binomial Coefficient ; Initialize res with 1 ; Since C ( n , r ) assign to C ( n , n - r ) ; Evaluating expression ; Driver Code
",1
309,"nCr assign to integer with n,r assign to integer, res assign to 1
if r is greater than n - r, set r to n - r
untill i assign to 0 to r exclusive, res assign to res * ( n - i )
res assign to res / ( i + 1 )
return res
declare integer main ( ), integers n assign to 3, m assign to 2 and k assign to 2
print nCr ( n + m, k )
return 0
","Check if a string has m consecutive 1 ' s â– or â– 0' s 
 Program to check if the binary string contains m consecutive 1 ' s â– or â– 0' s ; Function that checks if the binary string contains m consecutive 1 ' s â– or â– 0' s ; length of binary string ; counts zeros ; counts 1 's ; count consecutive 0 's ; count consecutive 1 's ; Drivers Code ; function call
",0
310,"declare Is_possible with long long integer N, C assign to 0
create integer D with D assign to 0
untill N modulo 10 is 0, set N to N / 10
increment C by 1
if pow ( 2, ( int ) log2 ( N ) ) is N, D is ( int ) log2 ( N )
if C >assign to D, print YES
else print NO
else print NO
declare integer main ( ) and long long integer N assign to 2000000000000
declare Is_possible ( N) as argument
","Check if N can be obtained from 1 by repetitively multiplying by 10 or 20 
 C ++ program to check if N can be obtained from 1 by repetitive multiplication by 10 or 20 ; Function to check if N can be obtained or not ; Count and remove trailing zeroes ; Check if remaining N is a power of 2 ; To check the condition to print YES or NO ; Driver code
",1
311,"declare Is_possible with long long integer N, C assign to 0
create integer D with D assign to 0
untill N modulo 10 is 0, set N to N / 10
increment C by 1
if pow ( 2, ( int ) log2 ( N ) ) is N, D is ( int ) log2 ( N )
if C >assign to D, print YES
else print NO
else print NO
declare integer main ( ) and long long integer N assign to 2000000000000
declare Is_possible ( N) as argument
","Lexicographically smallest binary string untillmed by flipping bits at indices not divisible K1 or K2 such that count of 1 s is always greater than 0 s from left 
 C ++ program untill the above approach ; Function to find lexicographically smallest string having number of 1 s greater than number of 0 s ; C1s And C0s stores the count of 1 s and 0 s at every position ; Traverse the string S ; If the position is not divisible by k1 and k2 ; If C0s >assign to C1s and pos array of   is empty then the string can 't  be untillmed ; If pos array of   is not empty then flip the bit of last position present in pos array of   ; Print the result ; Driver Code
",0
312,"print n * n - n + 1 print newline
declare integer main ( ) and integer N assign to 4
call findNthTerm with argument N
return 0
","Central polygonal numbers 
 C ++ program to find N - th term in the series ; Function to find N - th term in the series ; Driver code
",1
313,"print n * n - n + 1 print newline
declare integer main ( ) and integer N assign to 4
call findNthTerm with argument N
return 0
","Program to print Spiral Pattern 
 Create row and col to traverse rows and columns ; Variable to determine the movement r assign to right , l assign to left , d assign to down , u assign to upper ; Array untill matrix ; Assign the value ; switch - case to determine the next index ; If right , go right ; if left , go left ; if up , go up ; if down , go down ; Check if the matrix has reached array boundary ; Add the left size untill the next boundary ; If 2 rotations has been made , decrease the size left by 1 ; switch - case to rotate the movement ; if right , rotate to down ; if down , rotate to left ; if left , rotate to up ; if up , rotate to right ; Print the matrix ; Driver Code ; Get the size of size ; Print the Spiral Pattern
",0
314,"declare integer variable rev_num assign to 0
untill num > 0, set rev_num to rev_num * 10 + num modulo 10
set num to num / 10
return rev_num
divSum assign to integer with result assign to 0
untill i assign to 2 to sqrt ( num ), if num % i is 0, increment result by rev ( i )
else result assign to result + ( rev ( i ) + rev ( num / i ) )
return result + 1
boolean function isAntiPerfect (n ) returns divSum (n ) assign to n
declare integer main ( ) and integer N assign to 244
if isAntiPerfect ( N ) ), print Yes
else print No
return 0
","Anti 
 C ++ program untill the above approach ; Iterative function to reverse digits of num ; Return the reversed num ; Function to calculate sum of reverse all proper divisors ; Final result of summation of divisors ; Find all divisors of num ; If ' i ' is divisor of ' num ' ; If both divisors are same then add it only once else add both ; Add 1 to the result as 1 is also a divisor ; Function to check if N is anti - perfect or not ; Driver Code ; Given Number N ; Function Call
",1
315,"declare integer variable rev_num assign to 0
untill num > 0, set rev_num to rev_num * 10 + num modulo 10
set num to num / 10
return rev_num
divSum assign to integer with result assign to 0
untill i assign to 2 to sqrt ( num ), if num % i is 0, increment result by rev ( i )
else result assign to result + ( rev ( i ) + rev ( num / i ) )
return result + 1
boolean function isAntiPerfect (n ) returns divSum (n ) assign to n
declare integer main ( ) and integer N assign to 244
if isAntiPerfect ( N ) ), print Yes
else print No
return 0
","Kth ancestor of all nodes in an N 
 C ++ implementation of the above approach ; Function to add an edge in the tree ; DFS to find the Kth ancestor of every node ; Pushing current node in the vector ; Traverse its neighbors ; If K ancestors are not found untill current node ; Add the Kth ancestor untill the node ; Function to find Kth ancestor of each node ; Building the tree ; Stores all parents of a node ; Store Kth ancestor of all nodes ; Print the ancestors ; Driver Code ; Given N and K ; Given edges of n - ary tree ; Function Call
",0
316,"declare printSeries with integers n, a, b, c as arguments, returning void
if n is 1, print a and "" ""
return
if n is 2, print a, "" "", b and "" ""
return
print a, "" "", b, "" "", c and "" ""
untill i assign to 4 to n inclusive, set d to a + b + c
print d and "" ""
set a to b
set b to c
set c to d
declare main with integers N assign to 7, a assign to 1, b assign to 3
c assign to integer with c assign to 4
printSeries(N, a, b, c)
return 0
","Program to print the series 1 , 3 , 4 , 8 , 15 , 27 , 50 Ã¢ â‚¬Â¦ till N terms 
 C ++ implementation to print the N terms of the series whose three terms are given ; Function to print the series ; Generate the ith term and print it ; Driver Code ; Function Call
",1
317,"declare printSeries with integers n, a, b, c as arguments, returning void
if n is 1, print a and "" ""
return
if n is 2, print a, "" "", b and "" ""
return
print a, "" "", b, "" "", c and "" ""
untill i assign to 4 to n inclusive, set d to a + b + c
print d and "" ""
set a to b
set b to c
set c to d
declare main with integers N assign to 7, a assign to 1, b assign to 3
c assign to integer with c assign to 4
printSeries(N, a, b, c)
return 0
","Contiguous subsegments of a string having distinct subsequent characters 
 C ++ implementation of the approach ; Function that prints the segments ; New array untill every iteration ; Check if iterator points to end or not ; Driver code
",0
318,"declare integer diameter ( integer n )  integers L, H, templen
L assign to 1
H assign to 0
if n is 1 return 1
if n is 2 return 2
if n is 3 return 3
untill L * 2 assign to n, L *assign to 2
increment H
if n >assign to L * 2 - 1 return 2 * H + 1
else if n >assign to L + ( L / 2 ) - 1 ), return 2 * H
return 2 * H - 1
declare integer main ( ) and integer n assign to 15
print diameter (n ) print newline
","Diameter of a Binary Indexed Tree with N nodes 
  ; Function to find diameter of BIT with N + 1 nodes ; L is size of subtree just beuntille subtree in which N lies ; H is the height of subtree just beuntille subtree in which N lies ; Base Cases ; Size of subtree are power of 2 ; 3 Cases as explained in Approach ; Driver Code
",1
319,"declare integer diameter ( integer n )  integers L, H, templen
L assign to 1
H assign to 0
if n is 1 return 1
if n is 2 return 2
if n is 3 return 3
untill L * 2 assign to n, L *assign to 2
increment H
if n >assign to L * 2 - 1 return 2 * H + 1
else if n >assign to L + ( L / 2 ) - 1 ), return 2 * H
return 2 * H - 1
declare integer main ( ) and integer n assign to 15
print diameter (n ) print newline
","Maximize count of sheets possible by repeatedly reducing its area to half 
 C ++ program untill the above approach ; Function to calculate the maximum number of sheets possible by given operations ; Initial count of sheets ; Keep dividing the sheets into half ; Reduce area by half ; Increase count by twice ; Driver Code
",0
320,"declare compareValues with integers a, b, c, d, with log1 assign to log10 ( a ) as arguments, returning void
num1 assign to double with num1 assign to log1 * b
log2 assign to double with log2 assign to log10 (c )
num2 assign to double with num2 assign to log2 * d
if num1 is greater than num2 print a, ""  "" and b
else print c, "", "" and d
declare integer main ( ), integers a assign to 8, b assign to 29, c assign to 60, d assign to 59
call compareValues (a, b, c, d )
","Find the larger exponential among two exponentials 
 C ++ implementation of the approach ; Function to find whether a to the power b is greater or c to the power d ; Find b * log ( a ) ; Find d * log ( c ) ; Compare both values ; Driver code
",1
321,"declare compareValues with integers a, b, c, d, with log1 assign to log10 ( a ) as arguments, returning void
num1 assign to double with num1 assign to log1 * b
log2 assign to double with log2 assign to log10 (c )
num2 assign to double with num2 assign to log2 * d
if num1 is greater than num2 print a, ""  "" and b
else print c, "", "" and d
declare integer main ( ), integers a assign to 8, b assign to 29, c assign to 60, d assign to 59
call compareValues (a, b, c, d )
","Sqrt ( or Square Root ) Decomposition 
 Set 2 ( LCA of Tree in O ( sqrt ( height ) ) time ) 
 Naive C ++ implementation to find LCA in a tree ; stores depth untill each node ; stores first parent untill each node ; marking parent untill each node ; marking depth untill each node ; propogating marking down the tree ; a dummy node ; precalclating 1 ) depth . 2 ) parent . untill each node ; Time Complexity : O ( Height of tree ) recursively jumps one node above till both the nodes become equal ; Driver function to call the above functions ; adding edges to the tree
",0
322,"create 0005 vector n with n assign to MAX, int > addPrimes ( )
prime assign to boolean array of size n + 1
set all contents of prime to true
untill p assign to 2 to n inclusive, if prime array of p   is true, increment i by n, set prime array of i   to false
create vector  integer > ans
untill p assign to 2 to n inclusive, push_back ( p ) if prime array of p  , push_back ( p ), increment ans
return ans
boolean is_prime ( integer n ), return ( n assign to 3 n assign to 5 n assign to 7 )
declare find_Sum as integer (n ), sum as integer assign to 0
v assign to vector of integers with v assign to addPrimes ( )
untill i assign to 0 to size of v, n exclusive, flag assign to 1
create integer a with a assign to v array of i  
untill a is not 0, set d to a modulo 10
set a to a / 10
if is_prime ( d ) ), flag assign to 0
break loop
if flag is 1 then decrement n
set sum to sum + v array of i  
return sum
declare integer main ( ) and integer n assign to 7
print find_Sum ( n )
return 0
","Sum of prime numbers without odd prime digits 
  ; Find all prime numbers ; Store all prime numbers ; Function to check if a digit is odd prime or not ; Function to find sum ; To store required answer ; Get all prime numbers ; Traverse through all the prime numbers ; Flag stores 1 if a number does not contain any odd primes ; Find all digits of a number ; If number does not contain any odd primes ; Return the required answer ; Driver code ; Function call
",1
323,"create 0005 vector n with n assign to MAX, int > addPrimes ( )
prime assign to boolean array of size n + 1
set all contents of prime to true
untill p assign to 2 to n inclusive, if prime array of p   is true, increment i by n, set prime array of i   to false
create vector  integer > ans
untill p assign to 2 to n inclusive, push_back ( p ) if prime array of p  , push_back ( p ), increment ans
return ans
boolean is_prime ( integer n ), return ( n assign to 3 n assign to 5 n assign to 7 )
declare find_Sum as integer (n ), sum as integer assign to 0
v assign to vector of integers with v assign to addPrimes ( )
untill i assign to 0 to size of v, n exclusive, flag assign to 1
create integer a with a assign to v array of i  
untill a is not 0, set d to a modulo 10
set a to a / 10
if is_prime ( d ) ), flag assign to 0
break loop
if flag is 1 then decrement n
set sum to sum + v array of i  
return sum
declare integer main ( ) and integer n assign to 7
print find_Sum ( n )
return 0
","Minimum deletions required such that any number X will occur exactly X times 
 C ++ implementation of the approach ; Function to return the minimum deletions required ; To store the frequency of the array elements ; Store frequency of each element ; To store the minimum deletions required ; Value ; It 's frequency ; If number less than or equal to it 's frequency ; Delete extra occurrences ; Delete every occurrence of x ; Driver code
",0
324,"declare primeCount with integer arr array of  , integer n, max_val assign to * max_element ( arr, arr + n ) as arguments
create vector boolean with boolean value prime ( max_val + 1, true )
set prime array of 0   to false
set prime array of 1  to false
untill p assign to 2 to max_val inclusive, if prime array of p   is true, increment p p   by p, set prime array of i   to false
count assign to 0
untill i assign to 0 to n exclusive, increment count by 1 if prime array of arr array of i     is true
return count
declare getPrefixArray with integer arr array of  , integer n, integer pre array of  , pre array of 0   assign to arr array of 0  
untill i assign to 1 to n exclusive, set pre array ofi   to pre array of i - 1   + arr array of i  
declare integer main ( ), integer arr assign to  1, 4, 8, 4  ; declare integer array arr assign to  1, 4, 8, 4
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create integer pre with pre assign to n
getPrefixArray ( arr, n, pre)
print primeCount ( pre, n )
return 0
","Count the number of primes in the prefix sum array of the given array 
 C ++ implementation of the approach ; Function to return the count of primes in the given array ; Find maximum value in the array ; USE SIEVE TO FIND ALL PRIME NUMBERS LESS THAN OR EQUAL TO max_val Create a boolean array "" prime array of 0 . . n   "" . A value in prime array of i   will finally be false if i is Not a prime , else true . ; Remaining part of SIEVE ; If prime array of p   is not changed , then it is a prime ; Update all multiples of p ; Find all primes in arr array of   ; Function to generate the prefix array ; Fill the prefix array ; Driver code ; Prefix array of arr array of   ; Count of primes in the prefix array
",1
325,"declare primeCount with integer arr array of  , integer n, max_val assign to * max_element ( arr, arr + n ) as arguments
create vector boolean with boolean value prime ( max_val + 1, true )
set prime array of 0   to false
set prime array of 1  to false
untill p assign to 2 to max_val inclusive, if prime array of p   is true, increment p p   by p, set prime array of i   to false
count assign to 0
untill i assign to 0 to n exclusive, increment count by 1 if prime array of arr array of i     is true
return count
declare getPrefixArray with integer arr array of  , integer n, integer pre array of  , pre array of 0   assign to arr array of 0  
untill i assign to 1 to n exclusive, set pre array ofi   to pre array of i - 1   + arr array of i  
declare integer main ( ), integer arr assign to  1, 4, 8, 4  ; declare integer array arr assign to  1, 4, 8, 4
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create integer pre with pre assign to n
getPrefixArray ( arr, n, pre)
print primeCount ( pre, n )
return 0
","Check if sum Y can be obtained from the Array by the given operations 
 C ++ Program to implement the above approach ; Function to check if it is possible to obtain sum Y from a sequence of sum X from the array arr array of   ; Store the difference ; Iterate over the array ; If diff reduced to 0 ; Driver Code
",0
326,"minValue assign to integer with minValue assign to integer n, x, y assign to integer float with val assign to ( y * n ) / 100
if x >assign to val, return 0
else return ( ceil ( val ) - x )
declare integer main ( ), integers n assign to 10, x assign to 2 and y assign to 40
print minValue ( n, x, y )
","Minimum value to be added to X such that it is at least Y percent of N 
 C ++ implementation of the approach ; Function to return the required value that must be added to x so that it is at least y percent of n ; Required value ; If x is already >assign to y percent of n ; Driver code
",1
327,"minValue assign to integer with minValue assign to integer n, x, y assign to integer float with val assign to ( y * n ) / 100
if x >assign to val, return 0
else return ( ceil ( val ) - x )
declare integer main ( ), integers n assign to 10, x assign to 2 and y assign to 40
print minValue ( n, x, y )
","Print all longest common sub 
 C ++ program to find all LCS of two strings in sorted order . ; length of lcs ; dp matrix to store result of sub calls untill lcs ; A memoization based function that returns LCS of str1 array of i . . len1 - 1   and str2 array of j . . len2 - 1   ; base condition ; if lcs has been computed ; if characters are same return previous + 1 else max of two sequences after removing i ' th â– and â– j ' th char one by one ; Function to print all routes common sub - sequences of length lcslen ; if currlcs is equal to lcslen then print it ; if we are done with all the characters of both string ; here we have to print all sub - sequences lexicographically , that ' s â– why â– we â– start â– from â– ' a ' to ' z ' if this character is  present in both of them then append it in dataarray of  and same  remaining part ; done is a flag to tell that we have printed all the subsequences corresponding to current character ; if character ch is present in str1 then check if it is present in str2 ; if ch is present in both of them and remaining length is equal to remaining lcs length then add ch in sub - sequenece ; If we found LCS beginning with current character . ; This function prints all LCS of str1 and str2 in lexicographic order . ; Find lengths of both strings ; Find length of LCS ; Print all LCS using recursive backtracking data array of   is used to store individual LCS . ; Driver program to run the case
",0
328,"if n is less than or equal to 1 return false
if n assign to 3 return true
if n modulo 2 is 0 n modulo 3 is 0, return false
return false if n modulo i is 0 or n modulo ( i + 2 ) is 0
return true
if boolean isFactorialPrime is long n, return false
declare long fact assign to 1
create integer i with i assign to 1
untill fact assign to n + 1, set fact to fact * i
if n + 1 is fact n - 1 is fact return true
increment i
return false
declare integer main ( ) and integer n assign to 23
if isFactorialPrime ( n ) ), print Yes
else print No
return 0
","Check if N is a Factorial Prime 
 C ++ program to check if given number is a factorial prime ; Utility function to check if a number is prime or not ; Corner cases ; This is checked so that we can skip middle five numbers in below loop ; Function that returns true if n is a factorial prime ; If n is not prime then return false ; Calculate factorial ; If n is a factorial prime ; n is not a factorial prime ; Driver code
",1
329,"if n is less than or equal to 1 return false
if n assign to 3 return true
if n modulo 2 is 0 n modulo 3 is 0, return false
return false if n modulo i is 0 or n modulo ( i + 2 ) is 0
return true
if boolean isFactorialPrime is long n, return false
declare long fact assign to 1
create integer i with i assign to 1
untill fact assign to n + 1, set fact to fact * i
if n + 1 is fact n - 1 is fact return true
increment i
return false
declare integer main ( ) and integer n assign to 23
if isFactorialPrime ( n ) ), print Yes
else print No
return 0
","Find minimum changes required in an array untill it to contain k distinct elements 
 CPP program to minimum changes required in an array untill k distinct elements . ; Function to minimum changes required in an array untill k distinct elements . ; Store the frequency of each element ; Store the frequency of elements ; Sort frequencies in descending order ; To store the required answer ; Return the required answer ; Driver code
",0
330,"declare integer main with main assign to ll n assign to 5
make1 assign to 1
untill i assign to 2 to n - 1 inclusive, set fac1 to fac1 * i
set ll fac2 to fac1 * n
set totalWays to fac1 * fac2
print totalWays
return 0
","Seating arrangement of n boys and girls alternatively around a round table 
 C ++ program to find number of ways in which n boys and n girls can sit alternatively sound a round table . ; Driver Code ; Get n ; find fac1 assign to ( n - 1 ) ! ; Find fac2 assign to n ! ; Find total number of ways ; Print the total number of ways
",1
331,"declare integer main with main assign to ll n assign to 5
make1 assign to 1
untill i assign to 2 to n - 1 inclusive, set fac1 to fac1 * i
set ll fac2 to fac1 * n
set totalWays to fac1 * fac2
print totalWays
return 0
","Choose X elements from A array of   and Y elements from B array of   which satisfy the given condition 
 C ++ implementation of the approach ; Function to that returns true if it possible to choose the elements ; If elements can 't be chosen ; Sort both the arrays ; If xth smallest element of A array of   is smaller than the yth greatest element of B array of   ; Driver code
",0
332,"create 000 vector  integer > arr
declare SieveOfEratosthenes as void, returning boolean prime with MAX as argument
set all contents of prime to true
untill p assign to 2 to MAX exclusive, if prime array of p   is true, increment i by MAX, set prime array of i   to false
untill p assign to 2 to MAX exclusive, push_back ( p ) arr
create boolean isEuclid ( long n ) and a new long long product with value 1
create integer i with i assign to 0
untill product  n, set product to product * arr array of i  
if product + 1 is n, return true
increment i
return false
declare integer main ( ) and SieveOfEratosthenes ( )
create long n with n assign to 31
if isEuclid ( n ) ), print YES STRNEWLINE
else print NO STRNEWLINE
set n to 42
if isEuclid ( n ) ), print YES STRNEWLINE
else print NO STRNEWLINE
return 0
","Check whether the given number is Euclid Number or not 
 CPP program to check Euclid Number ; Function to generate prime numbers ; Create a boolean array "" prime array of 0 . . n   "" and initialize all entries it as true . A value in prime array of i   will finally be false if i is Not a prime , else true . ; If prime array of p   is not changed , then it is a prime ; Update all multiples of p ; store all prime numbers to vector ' arr ' ; Function to check the number untill Euclid Number ; Multiply next prime number and check if product + 1 assign to n holds or not ; Driver code ; Get the prime numbers ; Get n ; Check if n is Euclid Number ; Get n ; Check if n is Euclid Number
",1
333,"create 000 vector  integer > arr
declare SieveOfEratosthenes as void, returning boolean prime with MAX as argument
set all contents of prime to true
untill p assign to 2 to MAX exclusive, if prime array of p   is true, increment i by MAX, set prime array of i   to false
untill p assign to 2 to MAX exclusive, push_back ( p ) arr
create boolean isEuclid ( long n ) and a new long long product with value 1
create integer i with i assign to 0
untill product  n, set product to product * arr array of i  
if product + 1 is n, return true
increment i
return false
declare integer main ( ) and SieveOfEratosthenes ( )
create long n with n assign to 31
if isEuclid ( n ) ), print YES STRNEWLINE
else print NO STRNEWLINE
set n to 42
if isEuclid ( n ) ), print YES STRNEWLINE
else print NO STRNEWLINE
return 0
","Minimum number of adjacent swaps required to convert a permutation to another permutation by given condition 
 C ++ program untill the above approach ; Function to find the minimum number of swaps ; New array to convert to 1 - based indexing ; Keeps count of swaps ; Check if it is an ' X ' position ; Corner Case ; Swap ; Print the minimum swaps ; Driver Code ; Given Number N ; Given Permutation of N numbers ; Function Call
",0
334,"nextPerfectCube assign to integer with nextN assign to floor ( cbrt ( N ) ) + 1
return nextN * nextN * nextN
declare integer main ( ) and integer n assign to 35
print nextPerfectCube ( n )
return 0
","Perfect cube greater than a given number 
 C ++ implementation of above approach ; Function to find the next perfect cube ; Driver Code
",1
335,"nextPerfectCube assign to integer with nextN assign to floor ( cbrt ( N ) ) + 1
return nextN * nextN * nextN
declare integer main ( ) and integer n assign to 35
print nextPerfectCube ( n )
return 0
","Central polygonal numbers 
 C ++ program to find N - th term in the series ; Function to find N - th term in the series ; Driver code
",0
336,"if n is less than or equal to 1 return false
if n assign to 3 return true
if n modulo 2 is 0 n modulo 3 is 0, return false
return false if n modulo i is 0 or n modulo ( i + 2 ) is 0
return true
sum assign to integer with sumOfPrimeDivisors assign to n
declare integer root_n assign to ( integer ) sqrt (n )
untill i assign to 1 to root_n inclusive, if n modulo i is 0, increment sum by i
else if isPrime ( i ) ), sum assign to sum + i
if isPrime ( n / i ) ), sum assign to sum + ( n / i )
return sum
declare integer main ( ) and integer n assign to 60
print Sum of prime divisors of 60 is "" print SumOfPrimeDivisors ( n ) print newline
","Sum of all the prime divisors of a number 
 C ++ program to find sum of prime divisors of N ; Function to check if the number is prime or not . ; Corner cases ; This is checked so that we can skip middle five numbers in below loop ; function to find sum of prime divisors of N ; return type of sqrt function if float ; both factors are same ; both factors are not same ( i and n / i ) ; Driver code
",1
337,"if n is less than or equal to 1 return false
if n assign to 3 return true
if n modulo 2 is 0 n modulo 3 is 0, return false
return false if n modulo i is 0 or n modulo ( i + 2 ) is 0
return true
sum assign to integer with sumOfPrimeDivisors assign to n
declare integer root_n assign to ( integer ) sqrt (n )
untill i assign to 1 to root_n inclusive, if n modulo i is 0, increment sum by i
else if isPrime ( i ) ), sum assign to sum + i
if isPrime ( n / i ) ), sum assign to sum + ( n / i )
return sum
declare integer main ( ) and integer n assign to 60
print Sum of prime divisors of 60 is "" print SumOfPrimeDivisors ( n ) print newline
","Count pairs ( i , j ) from given array such that i K * arr array of j   
 C ++ program untill the above approach ; Function to merge two sorted arrays ; i : index to left subarray ; j : index to right subarray ; Stores count of pairs that satisfy the given condition ; Traverse to check untill the valid conditions ; If condition satisfies ; All elements in the right side of the left subarray also satisfies ; Sort the two given arrays and store in the resultant array ; Elements which are left in the left subarray ; Elements which are left in the right subarray ; Return the count obtained ; Function to partition array into two halves ; Same as ( l + r ) / 2 , but avoids overflow untill large l and h ; Sort first and second halves ; Call the merging function ; Function to print the count of required pairs using Merge Sort ; Driver code ; Function Call
",0
338,"declare findpos with string n as argument, pos assign to 0
untill i assign to 0 to n array of i  not equal to'0' ; i ++ ) switch ( n array of i   )  case '2' : pos assign to pos * 4 + 1
break loop
pos assign to case '3' : pos assign to pos * 4 + 2
break loop
pos assign to case '5' : pos assign to pos * 4 + 3
break loop
pos assign to case '7' : pos assign to pos * 4 + 4
break loop
return pos
declare integer main ( ) and string n assign to ""777""
print findpos (n )
","Position of n among the numbers made of 2 , 3 , 5 & 7 
  ; If number is 2 then it is on the position pos * 2 + 1 ; If number is 3 then it is on the position pos * 2 + 2 ; If number is 5 then it is on the position pos * 2 + 3 ; If number is 7 then it is on the position pos * 2 + 4 ; Driver code
",1
339,"declare findpos with string n as argument, pos assign to 0
untill i assign to 0 to n array of i  not equal to'0' ; i ++ ) switch ( n array of i   )  case '2' : pos assign to pos * 4 + 1
break loop
pos assign to case '3' : pos assign to pos * 4 + 2
break loop
pos assign to case '5' : pos assign to pos * 4 + 3
break loop
pos assign to case '7' : pos assign to pos * 4 + 4
break loop
return pos
declare integer main ( ) and string n assign to ""777""
print findpos (n )
","Cost to Balance the parentheses 
 CPP code to calculate the minimum cost to make the given parentheses balanced ; To store absolute count of balanced and unbalanced parenthesis ; o ( open bracket ) stores count of ' ( ' and c ( close bracket ) stores count of ' ) ' ; Driver code
",0
340,"declare possibleTripletInRange with integer L, R as arguments, setting boolean flag to false
create integers possibleA, possibleB, possibleC
numbersInRange assign to integer with numbersInRange assign to ( R - L + 1 )
if numbersInRange is less than 3 set flag to false
else if numbersInRange is greater than 3, set flag to true
if L modulo 2 increment L
set possibleA to L
set possibleB to L + 1
set possibleC to L + 2
else if L modulo 2 is true, flag assign to true
set possibleA to L
set possibleB to L + 1
set possibleC to L + 2
else set flag to false
print "" ( ""  possibleA  "", ""  possibleB  "", ""  possibleC  "" ) "" and "" is one such possible triplet between ""  L  "" and "" and "" R  "" STRNEWLINE ""
else print No Such Triplet between ""  L  "" and ""  R  "" STRNEWLINE ""
declare integer main ( ), integers L, R
set L to 2
R assign to 10
call possibleTripletInRange ( L, R )
set L to 23
R assign to 46
call possibleTripletInRange ( L, R )
return 0
","Finding a Non Transitive Co 
 C ++ program to find a non transitive co - prime triplets between L and R ; Checks if any possible triplet ( a , b , c ) satisfying the condition that ( a , b ) is coprime , ( b , c ) is coprime but ( a , c ) isnt ; Case 1 : Less than 3 numbers between L and R ; Case 2 : More than 3 numbers between L and R ; triplets should always be of untillm ( 2 k , 2 k + 1 , 2 k + 2 ) ; Case 3.1 : Exactly 3 numbers in range of untillm ( 2 k , 2 k + 1 , 2 k + 2 ) ; Case 3.2 : Exactly 3 numbers in range of untillm ( 2 k - 1 , 2 k , 2 k + 1 ) ; flag assign to True indicates that a pair exists between L and R ; Driver code ; finding possible Triplet between 2 and 10 ; finding possible Triplet between 23 and 46
",1
341,"declare possibleTripletInRange with integer L, R as arguments, setting boolean flag to false
create integers possibleA, possibleB, possibleC
numbersInRange assign to integer with numbersInRange assign to ( R - L + 1 )
if numbersInRange is less than 3 set flag to false
else if numbersInRange is greater than 3, set flag to true
if L modulo 2 increment L
set possibleA to L
set possibleB to L + 1
set possibleC to L + 2
else if L modulo 2 is true, flag assign to true
set possibleA to L
set possibleB to L + 1
set possibleC to L + 2
else set flag to false
print "" ( ""  possibleA  "", ""  possibleB  "", ""  possibleC  "" ) "" and "" is one such possible triplet between ""  L  "" and "" and "" R  "" STRNEWLINE ""
else print No Such Triplet between ""  L  "" and ""  R  "" STRNEWLINE ""
declare integer main ( ), integers L, R
set L to 2
R assign to 10
call possibleTripletInRange ( L, R )
set L to 23
R assign to 46
call possibleTripletInRange ( L, R )
return 0
","Program to find whether a no is power of two 
 C ++ program untill above approach ; Function which checks whether a number is a power of 2 ; base cases '1' is the only odd number which is a power of 2 ( 2 to the power 0 ) ; all other odd numbers are not powers of 2 ; recursive function call ; Driver Code ; True ; False
",0
342,"digitNumber is a long long function with long long argument n and returns 1 if n is 0
if n is 1 return 9
if n modulo 2 is true, temp assign to digitNumber ( ( ( n - 1 ) / 2 ) % mod
return ( 9 * ( temp * temp ) % mod ) % mod
else temp assign to digitNumber ( n / 2 ) % mod
return ( temp * temp) modulo mod
if d is 0, return 9 * digitNumber ( n - 1 ) ) % mod
else return 8 * digitNumber ( n - 1 ) ) % mod
declare integer main ( ) and long long d assign to 9
n assign to integer with n assign to 3
print countExcluding ( n, d ) and a new line
return 0
","Count n digit numbers not having a particular digit 
 C ++ Implementation of above method ; Finding number of possible number with n digits excluding a particular digit ; Checking if number of digits is zero ; Checking if number of digits is one ; Checking if number of digits is odd ; Calling digitNumber function with ( digit - 1 ) / 2 digits ; Calling digitNumber function with n / 2 digits ; Calling digitNumber function Checking if excluding digit is zero or non - zero ; Driver function to run above program ; Initializing variables
",1
343,"digitNumber is a long long function with long long argument n and returns 1 if n is 0
if n is 1 return 9
if n modulo 2 is true, temp assign to digitNumber ( ( ( n - 1 ) / 2 ) % mod
return ( 9 * ( temp * temp ) % mod ) % mod
else temp assign to digitNumber ( n / 2 ) % mod
return ( temp * temp) modulo mod
if d is 0, return 9 * digitNumber ( n - 1 ) ) % mod
else return 8 * digitNumber ( n - 1 ) ) % mod
declare integer main ( ) and long long d assign to 9
n assign to integer with n assign to 3
print countExcluding ( n, d ) and a new line
return 0
","Program to Convert Radian to Degree 
 C ++ code to convert radian to degree ; Function untill convertion ; Driver code
",0
344,"if n is less than or equal to 1 return false
return false if i assign to 2, i  n, i ++, if n modulo i is 0
return true
if isPrime ( n ) is false, return false
create integer rev with rev assign to 0
untill n is not 0, set d to n modulo 10
rev assign to rev * 10 + d
divide n by 10
return isPrime ( rev )
declare integer main ( ) and integer n assign to 13
if isEmirp ( n ) is true, print Yes
else print No
","Check if given number is Emirp Number or not 
 C ++ program to check if given number is Emirp or not . ; Returns true if n is prime . Else false . ; Corner case ; Check from 2 to n - 1 ; Function will check whether number is Emirp or not ; Check if n is prime ; Find reverse of n ; If both Original and Reverse are Prime , then it is an Emirp number ; Driver code ; Input number
",1
345,"if n is less than or equal to 1 return false
return false if i assign to 2, i  n, i ++, if n modulo i is 0
return true
if isPrime ( n ) is false, return false
create integer rev with rev assign to 0
untill n is not 0, set d to n modulo 10
rev assign to rev * 10 + d
divide n by 10
return isPrime ( rev )
declare integer main ( ) and integer n assign to 13
if isEmirp ( n ) is true, print Yes
else print No
","Permutation present at the middle of lexicographic ordering of permutations of at most length N made up integers up to K 
 C ++ program untill the above approach ; Function that finds the middle the lexicographical smallest sequence ; If K is even ; First element is K / 2 ; Remaining elements of the sequence are all integer K ; Stores the sequence when K is odd ; Iterate over the range array of 0 , N / 2   ; Check if the sequence ends with in 1 or not ; Remove the sequence ending in 1 ; If it doesn 't end in 1 ; Decrement by 1 ; Insert K to the sequence till its size is N ; Print the sequence stored in the vector ; Driver Code
",0
346,"create double Convert ( double radian )  double pi assign to 3.14159
return (radian * ( 180 / pi ) )
declare integer main ( ) and double radian assign to 5.0
degree assign to double with degree assign to Convert (radian )
print degree
return 0
","Program to Convert Radian to Degree 
 C ++ code to convert radian to degree ; Function untill convertion ; Driver code
",1
347,"create double Convert ( double radian )  double pi assign to 3.14159
return (radian * ( 180 / pi ) )
declare integer main ( ) and double radian assign to 5.0
degree assign to double with degree assign to Convert (radian )
print degree
return 0
","Find Range Value of the Expression 
 C ++ implementation of the approach ; Function to return the value of the given expression ; Value of the first term ; Value of the last term ; Driver code ; Get the result
",0
348,"declare integer sn (n, an ), return ( n * ( 1 + an ) ) / 2
create integer trace (n,m ) and integer an assign to 1 + (n - 1 ) * (m + 1)
declare integer rowmajorSum assign to sn ( n, an )
set an to 1 + ( n - 1 ) * ( n + 1 )
create integer colmajorSum with colmajorSum assign to sn ( n, an )
return rowmajorSum + colmajorSum
declare integer variables N assign to 3 and M assign to 3
print trace ( N, M ) print newline
return 0
","Find trace of matrix untillmed by adding Row 
 C ++ program to find trace of matrix untillmed by adding Row - major and Column - major order of same matrix ; Return sum of first n integers of an AP ; Return the trace of sum of row - major matrix and column - major matrix ; Finding nth element in AP in case of Row major matrix . ; Finding sum of first n integers of AP in case of Row major matrix ; Finding nth element in AP in case of Row major matrix ; Finding sum of first n integers of AP in case of Column major matrix ; Driven Program
",1
349,"declare integer sn (n, an ), return ( n * ( 1 + an ) ) / 2
create integer trace (n,m ) and integer an assign to 1 + (n - 1 ) * (m + 1)
declare integer rowmajorSum assign to sn ( n, an )
set an to 1 + ( n - 1 ) * ( n + 1 )
create integer colmajorSum with colmajorSum assign to sn ( n, an )
return rowmajorSum + colmajorSum
declare integer variables N assign to 3 and M assign to 3
print trace ( N, M ) print newline
return 0
","Multiply two integers without using multiplication , division and bitwise operators , and no loops 
 C ++ program to Multiply two integers without using multiplication , division and bitwise operators , and no loops ; function to multiply two numbers x and y ; 0 multiplied with anything gives 0 ; Add x one by one ; the case where y is negative ; Driver code
",0
350,"if k is greater than ( n + m - 2 ) print Not possible
else  result
if k  max (m, n ) - 1 ), result assign to max ( m * ( n / ( k + 1 ) ), n * ( m / ( k + 1 ) ) ) )
else set result to max ( m / ( k - n + 2 ), n / ( k - m + 2 ) )
print result
declare integer main ( ), integers n assign to 3, m assign to 4 and k assign to 1
max_area ( n, m, k )
","Maximum of smallest possible area that can get with exactly k cut of given rectangular 
 C ++ code untill Maximum of smallest possible area that can get with exactly k cut of given rectangular ; Utility Function ; untill the 1 st case ; untill the second case ; print final result ; driver code
",1
351,"if k is greater than ( n + m - 2 ) print Not possible
else  result
if k  max (m, n ) - 1 ), result assign to max ( m * ( n / ( k + 1 ) ), n * ( m / ( k + 1 ) ) ) )
else set result to max ( m / ( k - n + 2 ), n / ( k - m + 2 ) )
print result
declare integer main ( ), integers n assign to 3, m assign to 4 and k assign to 1
max_area ( n, m, k )
","Find the maximum repeating number in O ( n ) time and O ( 1 ) extra space 
 C ++ program to find the maximum repeating number ; Returns maximum repeating element in arr array of 0. . n - 1   . The array elements are in range from 0 to k - 1 ; Iterate though input array , untill every element arr array of i   , increment arr array of arr array of i   % k   by k ; Find index of the maximum repeating element ; Return index of the maximum element ; Driver program to test above function
",0
352,"declare int area_fun with int side, int area assign to side * side
return area
declare integer main ( ) and integer side assign to 4
create integer area with area assign to area_fun ( side )
print area
return 0
","Program to find the area of a Square 
 CPP program to find the area of a square ; function to find the area ; Driver program
",1
353,"declare int area_fun with int side, int area assign to side * side
return area
declare integer main ( ) and integer side assign to 4
create integer area with area assign to area_fun ( side )
print area
return 0
","Minimize the count of adjacent pairs with different parity 
 C ++ implementation of above approach ; Recursive function to calculate minimum adjacent pairs with different parity ; If all the numbers are placed ; If replacement is not required ; If replacement is required ; backtracking ; backtracking ; Function to display the minimum number of adjacent elements with different parity ; Store no of even numbers not present in the array ; Store no of odd numbers not present in the array ; Erase exisiting numbers ; Store non - exisiting even and odd numbers ; Driver code
",0
354,"countConsecutive assign to long integer N and count assign to 0
untill L assign to 1 to L * ( L + 1)  2 * N, a assign to ( 1.0 * N - ( L * ( L + 1) ) / 2 ) / ( L + 1)
if a - ( integer ) a assign to 0, increment count
return count
declare integer main ( ) and long integer N assign to 15
print countConsecutive ( N) print newline
set N to 10
print countConsecutive ( N) print newline
return 0
","Count ways to express a number as sum of consecutive numbers 
 C ++ program to count number of ways to express N as sum of consecutive numbers . ; Utility method to compute number of ways in which N can be represented as sum of consecutive number ; constraint on values of L gives us the time Complexity as O ( N to the power 0.5 ) ; Driver Code
",1
355,"countConsecutive assign to long integer N and count assign to 0
untill L assign to 1 to L * ( L + 1)  2 * N, a assign to ( 1.0 * N - ( L * ( L + 1) ) / 2 ) / ( L + 1)
if a - ( integer ) a assign to 0, increment count
return count
declare integer main ( ) and long integer N assign to 15
print countConsecutive ( N) print newline
set N to 10
print countConsecutive ( N) print newline
return 0
","Minimize array elements required to be incremented or decremented to convert given array into a Fibonacci Series 
 C ++ program untill the above approach ; Function to calculate minimum number of moves to make the sequence a Fibonacci series ; If number of elements is less than 3 ; Initialize the value of the result ; Try all permutations of the first two elements ; Value of first element after operation ; Value of second element after operation ; Calculate number of moves untill rest of the elements of the array ; Element at idx index ; If it is not possible to change the element in atmost one move ; Otherwise ; Update the answer ; Return the answer ; Driver Code
",0
356,"create boolean isAutomorphic (int N )  sq assign to N * N
untill N > 0, if N % 10 is not sq % 10, return false
N assign to N / 10
divide sq by 10
return true
declare integer main ( ) and integer N assign to 5
print Automorphic if N is true, else print Not Automorphic
return 0
","Automorphic Number 
 C ++ program to check if a number is Authomorphic ; Function to check Automorphic number ; Store the square ; Start Comparing digits ; Return false , if any digit of N doesn ' t â– â– match â– with â– its â– square ' s digits from last ; Reduce N and square ; Driver code
",1
357,"create boolean isAutomorphic (int N )  sq assign to N * N
untill N > 0, if N % 10 is not sq % 10, return false
N assign to N / 10
divide sq by 10
return true
declare integer main ( ) and integer N assign to 5
print Automorphic if N is true, else print Not Automorphic
return 0
","Calculate Bitwise OR of two integers from their given Bitwise AND and Bitwise XOR values 
 C ++ program to implement the above approach ; Function to calculate Bitwise OR from given bitwise XOR and bitwise AND values ; Driver Code
",0
358,"create integer maxPrimefactorNum ( integer N), arr with arr assign to bool array of N + 5  
set all contents of arr to true
untill i assign to 3 to N inclusive, increment i by 2 if arr array of i   is true
create vector  integer > prime
push_back is prime. push_back is a new function
untill i assign to 3 to N inclusive, incrementing i by 2 if arr array of i   is true, push_back ( i ) prime
create integers i, ans with i assign to 0 and ans assign to 1
untill ans * prime array of i   assign to N and i  prime size ( ) ), ans *assign to prime array of i  
increment i
return ans
declare integer main ( ) and integer N assign to 40
print maxPrimefactorNum ( N) print newline
return 0
","Number with maximum number of prime factors 
 C ++ program to find integer having maximum number of prime factor in first N natural numbers ; Return smallest number having maximum prime factors . ; default value of boolean is false ; Sieve of eratosthenes ; Storing prime numbers . ; Generating number having maximum prime factors . ; Driven Program
",1
359,"create integer maxPrimefactorNum ( integer N), arr with arr assign to bool array of N + 5  
set all contents of arr to true
untill i assign to 3 to N inclusive, increment i by 2 if arr array of i   is true
create vector  integer > prime
push_back is prime. push_back is a new function
untill i assign to 3 to N inclusive, incrementing i by 2 if arr array of i   is true, push_back ( i ) prime
create integers i, ans with i assign to 0 and ans assign to 1
untill ans * prime array of i   assign to N and i  prime size ( ) ), ans *assign to prime array of i  
increment i
return ans
declare integer main ( ) and integer N assign to 40
print maxPrimefactorNum ( N) print newline
return 0
","Print array after it is right rotated K times 
 C ++ implementation of right rotation of an array K number of times ; Function to rightRotate array ; If rotation is greater than size of array ; Printing rightmost kth elements ; Prints array after ' k ' elements ; Driver code
",0
360,"unsigned highestPowerof2 is a new unsigned function with x elements, set x to x 
 x >> 1
set x to x 
 x >> 2
set x to x 
 x >> 4
set x to x 
 x >> 8
set x to x 
 x >> 16
return x  ( x >> 1 )
declare integer main ( ) and integer n assign to 10
print highestPowerof2 ( n ) and "" STRNEWLINE ""
return 0
","Highest power of 2 less than or equal to given number 
 C ++ program to find highest power of 2 smaller than or equal to n . ; check untill the set bits ; Then we remove all but the top bit by xor ' ing â– the â– â– string â– of â– 1' s with that string of 1 ' s â– shifted â– one â– to â– â– the â– left , â– and â– we â– end â– up â– with â– just â– the â– one â– top â– bit â– â– followed â– by â– 0' s . ; Driver code
",1
361,"unsigned highestPowerof2 is a new unsigned function with x elements, set x to x 
 x >> 1
set x to x 
 x >> 2
set x to x 
 x >> 4
set x to x 
 x >> 8
set x to x 
 x >> 16
return x  ( x >> 1 )
declare integer main ( ) and integer n assign to 10
print highestPowerof2 ( n ) and "" STRNEWLINE ""
return 0
","Find the pair ( a , b ) with minimum LCM such that their sum is equal to N 
 C ++ program untill the above approach ; Function to check if number is prime or not ; As 1 is neither prime nor composite return false ; Check if it is divided by any number then it is not prime , return false ; Check if n is not divided by any number then it is prime and hence return true ; Function to find the pair ( a , b ) such that sum is N & LCM is minimum ; Check if the number is prime ; Now , if it is not prime then find the least divisior ; Check if divides n then it is a factor ; Required output is a assign to n / i & b assign to n / i * ( n - 1 ) ; Driver Code ; Function call
",0
362,"declare integer divSum with integer num and result assign to 0
if num is 1 return result
untill i assign to 2 to sqrt ( num ), if num modulo i is 0, increment result by i
else result assign to result + ( i + num / i )
return result + 1
declare integer main ( ) and integer num assign to 36
print divSum (num )
return 0
","Sum of all proper divisors of a natural number 
 C ++ program to find sum of all divisors of a natural number ; Function to calculate sum of all proper divisors num -- > given natural number ; Final result of summation of divisors ; there will be no proper divisor ; find all divisors which divides ' num ' ; if ' i ' is divisor of ' num ' ; if both divisors are same then add it only once else add both ; Add 1 to the result as 1 is also a divisor ; Driver program to run the case
",1
363,"declare integer divSum with integer num and result assign to 0
if num is 1 return result
untill i assign to 2 to sqrt ( num ), if num modulo i is 0, increment result by i
else result assign to result + ( i + num / i )
return result + 1
declare integer main ( ) and integer num assign to 36
print divSum (num )
return 0
","Make all array elements even by replacing adjacent pair of array elements with their sum 
 C ++ program to implement the above approach ; Function to find minimum count of operations required to make all array elements even ; Stores minimum count of replacements to make all array elements even ; Stores the count of odd continuous numbers ; Traverse the array ; If arr array of i   is an odd number ; Update odd_cont_seg ; If odd_cont_seg is even ; Update res ; Update res ; Reset odd_cont_seg assign to 0 ; If odd_cont_seg exceeds 0 ; If odd_cont_seg is even ; Update res ; Update res ; Print the result ; Drivers Code
",0
364,"declare power with integers x, y, p, untill y > 0, res assign to ( res * x ) % p as arguments, returning integer
set x to ( x * x ) % p
return res
if p modulo 4 is not 3, print ""Invalid Input ""
return
n assign to n modulo p
create integer x with x assign to power ( n, ( p + 1 ) / 4, p )
if ( x * x ) modulo p is n ), print Square root is "" and x
return
x assign to p - x
if ( x * x ) modulo p is n ), print Square root is "" and x
return
print "" Square root doesn' t exist ""
declare integer main ( ) and integer p assign to 7
create integer n with n assign to 2
create squareRoot ( n, p )
return 0
","Find Square Root under Modulo p 
 Set 1 ( When p is in untillm of 4 * i + 3 ) 
 An efficient C ++ program to find square root under modulo p when p is 7 , 11 , 19 , 23 , 31 , ... etc . ; Utility function to do modular exponentiation . It returns ( x to the power y ) % p . ; int res assign to 1 ; Initialize result x assign to x % p ; Update x if it is more than or equal to p ; If y is odd , multiply x with result ; y must be even now y assign to y >> 1 ; y assign to y / 2 ; Returns true if square root of n under modulo p exists Assumption : p is of the untillm 3 * i + 4 where i >assign to 1 ; Try "" + ( n to the power ( ( p â– + â– 1 ) / 4 ) ) "" ; Try "" - ( n â– to the power â– ( ( p â– + â– 1 ) / 4 ) ) "" ; If none of the above two work , then square root doesn 't exist ; Driver program to test
",1
365,"declare power with integers x, y, p, untill y > 0, res assign to ( res * x ) % p as arguments, returning integer
set x to ( x * x ) % p
return res
if p modulo 4 is not 3, print ""Invalid Input ""
return
n assign to n modulo p
create integer x with x assign to power ( n, ( p + 1 ) / 4, p )
if ( x * x ) modulo p is n ), print Square root is "" and x
return
x assign to p - x
if ( x * x ) modulo p is n ), print Square root is "" and x
return
print "" Square root doesn' t exist ""
declare integer main ( ) and integer p assign to 7
create integer n with n assign to 2
create squareRoot ( n, p )
return 0
","Minimize the maximum difference of adjacent elements after at most K insertions 
 C ++ Program to find the minimum of maximum differerence between adjacent elements after at most K insertions ; Calculate the maximum adjacent difference ; If the maximum adjacent difference is already zero ; best and worst specifies range of the maximum adjacent difference ; To store the no of insertions required untill respective values of mid ; If the number of insertions required exceeds K ; Otherwise ; Driver code
",0
366,"declare power with integers x, y, p, res assign to 1
set x to x modulo p
untill y > 0, if y & 1, res assign to ( res * x ) % p
set x to ( x * x ) % p
return res
boolean miillerTest ( int d, int n )  int a assign to 2 + rand ( ) % ( n - 4 )
create integer x with x assign to power ( a, d, n )
if x is 1 x is n - 1 return true
untill d is not n - 1 set x to ( x * x ) modulo n
d assign to d * 2
if x is 1 return false
if x is n - 1 return true
return false
if n assign to 1 n assign to 4, return false
if n assign to 3 return true
d assign to integer with d assign to n - 1
untill d modulo 2 is 0, d assign to d / 2
return false if miillerTest is 0 to k exclusive
return true
declare integer main ( ) and integer k assign to 4
print ""All primes smaller than 100 : STRNEWLINE ""
untill n assign to 1 to 100 exclusive, print n and "" ""
return 0
","Primality Test 
 Set 3 ( MillerÃ¢ â‚¬â€œ Rabin ) 
 C ++ program Miller - Rabin primality test ; Utility function to do modular exponentiation . It returns ( x to the power y ) % p ; Initialize result ; Update x if it is more than or equal to p ; If y is odd , multiply x with result ; y must be even now y assign to y >> 1 ; y assign to y / 2 ; This function is called untill all k trials . It returns false if n is composite and returns true if n is probably prime . d is an odd number such that d * 2 < sup > r < / sup > assign to n - 1 untill some r >assign to 1 ; Pick a random number in array of 2. . n - 2   Corner cases make sure that n > 4 ; Compute a to the power d % n ; Keep squaring x untill one of the following doesn 't  happen  (i) d does not reach n-1  (ii) (xto the power2) % n is not 1  (iii) (xto the power2) % n is not n-1 ; Return composite ; It returns false if n is composite and returns true if n is probably prime . k is an input parameter that determines accuracy level . Higher value of k indicates more accuracy . ; Corner cases ; Find r such that n assign to 2 to the power d * r + 1 untill some r >assign to 1 ; Iterate given nber of ' k ' times ; Driver program
",1
367,"declare power with integers x, y, p, res assign to 1
set x to x modulo p
untill y > 0, if y & 1, res assign to ( res * x ) % p
set x to ( x * x ) % p
return res
boolean miillerTest ( int d, int n )  int a assign to 2 + rand ( ) % ( n - 4 )
create integer x with x assign to power ( a, d, n )
if x is 1 x is n - 1 return true
untill d is not n - 1 set x to ( x * x ) modulo n
d assign to d * 2
if x is 1 return false
if x is n - 1 return true
return false
if n assign to 1 n assign to 4, return false
if n assign to 3 return true
d assign to integer with d assign to n - 1
untill d modulo 2 is 0, d assign to d / 2
return false if miillerTest is 0 to k exclusive
return true
declare integer main ( ) and integer k assign to 4
print ""All primes smaller than 100 : STRNEWLINE ""
untill n assign to 1 to 100 exclusive, print n and "" ""
return 0
","Count triples with Bitwise AND equal to Zero 
 C ++ program untill the above approach ; Function to find the number of triplets whose Bitwise AND is 0. ; Stores the count of triplets having bitwise AND equal to 0 ; Stores frequencies of all possible A array of i   & A array of j   ; Traverse the array ; Update frequency of Bitwise AND of all array elements with a ; Traverse the array ; Iterate the map ; If bitwise AND of triplet is zero , increment cnt ; Return the number of triplets whose Bitwise AND is 0. ; Driver Code ; Input Array ; Function Call
",0
368,"declare maxConsecutiveOnes with integer x as argument, assign 0 to integer count
untill x is not 0 set x to ( x & ( x  1 ) )
increment count
return count
print main, maxConsecutiveOnes, 14 and a new line
print maxConsecutiveOnes (222 )
return 0
","Length of the Longest Consecutive 1 s in Binary Representation 
 C ++ program to find length of the longest consecutive 1 s in binary representation of a number . ; Function to find length of the longest consecutive 1 s in binary representation of a number ; Initialize result ; Count the number of iterations to reach x assign to 0. ; This operation reduces length of every sequence of 1 s by one . ; Driver code
",1
369,"declare maxConsecutiveOnes with integer x as argument, assign 0 to integer count
untill x is not 0 set x to ( x & ( x  1 ) )
increment count
return count
print main, maxConsecutiveOnes, 14 and a new line
print maxConsecutiveOnes (222 )
return 0
","Count triplets from a given range having sum of two numbers of a triplet equal to the third number 
 C ++ program untill the above approach ; Function to find the number of triplets from the range array of L , R   having sum of two numbers from the triplet equal to the third number ; Stores the total number of triplets ; Find the difference of the range ; Case 1 : If triplets can 't  be untillmed, then return 0 ; Otherwise ; Update the total number of triplets ; Return the count ; Driver Code
",0
370,"declare integer subtract ( x, y ) untill y is not 0, assign (  x ) and y to the integer
x assign to x  y
y assign to borrow  1
return x
declare integer main ( ), integers x assign to 29, y assign to 13
print x - y is "" and subtract ( x, y )
return 0
","Subtract two numbers without using arithmetic operators 
 C ++ program to Subtract two numbers without using arithmetic operators ; Iterate till there is no carry ; borrow contains common set bits of y and unset bits of x ; Subtraction of bits of x and y where at least one of the bits is not set ; Borrow is shifted by one so that subtracting it from x gives the required sum ; Driver Code
",1
371,"declare integer subtract ( x, y ) untill y is not 0, assign (  x ) and y to the integer
x assign to x  y
y assign to borrow  1
return x
declare integer main ( ), integers x assign to 29, y assign to 13
print x - y is "" and subtract ( x, y )
return 0
","Generate all numbers up to N in Lexicographical Order 
 C ++ Program to implement the above approach ; Function to print all the numbers up to n in lexicographical order ; Driver Program
",0
372,"if y is 0, return x from function
return subtract ( x  y, ( x & y )  1 )
declare integer main ( ), integers x assign to 29, y assign to 13
print x - y is "" and subtract ( x, y )
return 0
","Subtract two numbers without using arithmetic operators 
 CPP Program to subtract two Number without using arithmetic operator Recursive implementation . ; Driver program
",1
373,"if y is 0, return x from function
return subtract ( x  y, ( x & y )  1 )
declare integer main ( ), integers x assign to 29, y assign to 13
print x - y is "" and subtract ( x, y )
return 0
","Generate Quadratic Equation having given sum and product of roots 
 C ++ program untill the above approach ; Function to find the quadratic equation from the given sum and products of roots ; Print the coefficients ; Driver Code
",0
374,"create void addEdge ( vector  int > v array of  , int x, int y )  v array of x  . push_back ( y )
push_back ( x ) v array of y  
void function push_back (get vector  int > tree array of  , vector  int > & temp, int ancestor array of  , int u, parent, int k, print temp)
untill i assign to tree array of u   ) if i is parent, continue
dfs is a new function
pop_back is a new function
if size of temp  k, set ancestor array of u   to -1
else ancestor array of u   assign to temp array of size of temp - k  
declare KthAncestor with integers N, K, E, edges, vectors, with ints N + 1 as arguments, returning void
untill i assign to 0 to E exclusive, addEdge ( tree, edges array of i   array of 0  , edges array of i   array of 1   )
create vector  integer > temp
create integer ancestor array of N + 1  
dfs assign to tree, temp, ancestor, 1, 0, K
untill i assign to 1 to N inclusive print ancestor array of i  print "" ""
declare integer main ( ) and integer N assign to 9
create integer K with K assign to 2
create integer E with E assign to 8
edges assign to integer array of size 8 with array of size 2 with array of size 2 with array of size 2 with array of size 8 with array of size 2 with array of size 2 with array of size 2 with array of size 1 and 2 with array of size 1, 3 with array of size 3, 4 with array of size 2, 5 with array of size 6, 6 with array of size 6, 7 with array of size 3, 8 with array of size 9, 9 with array of size
KthAncestor assign to N, K, E, edges
return 0
","Kth ancestor of all nodes in an N 
 C ++ implementation of the above approach ; Function to add an edge in the tree ; DFS to find the Kth ancestor of every node ; Pushing current node in the vector ; Traverse its neighbors ; If K ancestors are not found untill current node ; Add the Kth ancestor untill the node ; Function to find Kth ancestor of each node ; Building the tree ; Stores all parents of a node ; Store Kth ancestor of all nodes ; Print the ancestors ; Driver Code ; Given N and K ; Given edges of n - ary tree ; Function Call
",1
375,"create void addEdge ( vector  int > v array of  , int x, int y )  v array of x  . push_back ( y )
push_back ( x ) v array of y  
void function push_back (get vector  int > tree array of  , vector  int > & temp, int ancestor array of  , int u, parent, int k, print temp)
untill i assign to tree array of u   ) if i is parent, continue
dfs is a new function
pop_back is a new function
if size of temp  k, set ancestor array of u   to -1
else ancestor array of u   assign to temp array of size of temp - k  
declare KthAncestor with integers N, K, E, edges, vectors, with ints N + 1 as arguments, returning void
untill i assign to 0 to E exclusive, addEdge ( tree, edges array of i   array of 0  , edges array of i   array of 1   )
create vector  integer > temp
create integer ancestor array of N + 1  
dfs assign to tree, temp, ancestor, 1, 0, K
untill i assign to 1 to N inclusive print ancestor array of i  print "" ""
declare integer main ( ) and integer N assign to 9
create integer K with K assign to 2
create integer E with E assign to 8
edges assign to integer array of size 8 with array of size 2 with array of size 2 with array of size 2 with array of size 8 with array of size 2 with array of size 2 with array of size 2 with array of size 1 and 2 with array of size 1, 3 with array of size 3, 4 with array of size 2, 5 with array of size 6, 6 with array of size 6, 7 with array of size 3, 8 with array of size 9, 9 with array of size
KthAncestor assign to N, K, E, edges
return 0
","Count the triplets such that A array of i   < B array of j   < C array of k   
 C ++ implementation of the approach ; Function to return the count of elements in arr array of   which are less than the given key ; Modified binary search ; Function to return the count of elements in arr array of   which are greater than the given key ; Modified binary search ; Function to return the count of the required triplets ; Sort all three arrays ; Iterate untill all the elements of array B ; Count of elements in A array of   which are less than the chosen element from B array of   ; Count of elements in C array of   which are greater than the chosen element from B array of   ; Update the count ; Driver code
",0
376,"void function build ( vector  int > & sum, vector  int > & a, int l, int r, int rt ) if l is r, sum array of rt   assign to a array of l - 1  
return
m assign to integer with m assign to ( l + r ) >> 1
create build ( sum, a, l, m, rt  1 )
create build ( sum, a, m + 1, r, rt  1 )
if add array of rt   is true, increment add array of rt   by add array of rt  
add array of rt  1 1   + add array of rt  
increment sum array of rt  1   by add array of rt   * ln
increment sum array of rt  1 1   by add array of rt   * rn
add array of rt   assign to 0
if L assign to l and r assign to R, increment sum array of rt  by C * (r - l + 1)
add array of rt   + C
return
m assign to integer with m assign to ( l + r ) >> 1
pushDown ( sum, add, rt, m - l + 1, r - m )
if L assign to m update ( sum, add, L, R, C, l, m, rt  1 )
if R is greater than m, update sum, add, L, R, C, m + 1, r, rt  1 1
if L assign to l and r assign to R, return sum array of rt 
m assign to integer with m assign to ( l + r ) >> 1
pushDown ( sum, add, rt, m - l + 1, r - m )
ans assign to integer with ans assign to 0
if L assign to m, increment ans by query ( sum, add, L, R, l, m, rt  1 )
if R is greater than m, increment ans by query ( sum, add, L, R, m + 1, r, rt  1 1 )
return ans
in function sequenceMaintenance taking int n, int q, vector  int > & a, vector  int > & b, int m, sort (a. begin ( ), a. end ( ) ))
create vector  integer > sum, add, ans
assign ( n  2, 0 ) to sum
assign ( n  2, 0 ) to add
create build ( sum, a, 1, n, 1 )
untill i assign to 0 to q exclusive, l assign to 1, r assign to n, pos assign to -1
untill l assign to r, set m to ( l + r ) >> 1
if query ( sum, add, m, m, m, 1, n, 1 ) >assign to b array of i   ), r assign to m - 1
set pos to m
else l assign to m + 1
if pos is -1, push_back is ans 0
else  push_back ( n - pos + 1 )
update sum, add, pos, n, - m, 1, n, 1
print ans array of i   and "" ""
declare integer main ( ) and integer N assign to 4
create integer Q with Q assign to 3
create integer M with M assign to 1
create vector arr with arr assign to  1, 2, 3, 4
create integer variable query with value 4, 3, 1
create sequenceMaintenance ( N, Q, arr, query, M )
return 0
","Queries to count array elements greater than or equal to a given number with updates 
 C ++ program untill the above approach ; Function to build a segment tree ; Check untill base case ; Find mid point ; Recursively build the segment tree ; Function untill push down operation on the segment tree ; Function to update the segment tree ; Complete overlap ; Find mid ; Peruntillm push down operation on segment tree ; Recursively update the segment tree ; Function to process the query ; Base case ; Find mid ; Peruntillm push down operation on segment tree ; Recursively calculate the result of the query ; Return the result ; Function to count the numbers which are greater than the given query ; Sort the input array ; Create segment tree of size 4 * n ; Build the segment tree ; Iterate over the queries ; Store result in array ; Update the elements in the given range ; Print the result of queries ; Driver Code ; Function Call
",1
377,"void function build ( vector  int > & sum, vector  int > & a, int l, int r, int rt ) if l is r, sum array of rt   assign to a array of l - 1  
return
m assign to integer with m assign to ( l + r ) >> 1
create build ( sum, a, l, m, rt  1 )
create build ( sum, a, m + 1, r, rt  1 )
if add array of rt   is true, increment add array of rt   by add array of rt  
add array of rt  1 1   + add array of rt  
increment sum array of rt  1   by add array of rt   * ln
increment sum array of rt  1 1   by add array of rt   * rn
add array of rt   assign to 0
if L assign to l and r assign to R, increment sum array of rt  by C * (r - l + 1)
add array of rt   + C
return
m assign to integer with m assign to ( l + r ) >> 1
pushDown ( sum, add, rt, m - l + 1, r - m )
if L assign to m update ( sum, add, L, R, C, l, m, rt  1 )
if R is greater than m, update sum, add, L, R, C, m + 1, r, rt  1 1
if L assign to l and r assign to R, return sum array of rt 
m assign to integer with m assign to ( l + r ) >> 1
pushDown ( sum, add, rt, m - l + 1, r - m )
ans assign to integer with ans assign to 0
if L assign to m, increment ans by query ( sum, add, L, R, l, m, rt  1 )
if R is greater than m, increment ans by query ( sum, add, L, R, m + 1, r, rt  1 1 )
return ans
in function sequenceMaintenance taking int n, int q, vector  int > & a, vector  int > & b, int m, sort (a. begin ( ), a. end ( ) ))
create vector  integer > sum, add, ans
assign ( n  2, 0 ) to sum
assign ( n  2, 0 ) to add
create build ( sum, a, 1, n, 1 )
untill i assign to 0 to q exclusive, l assign to 1, r assign to n, pos assign to -1
untill l assign to r, set m to ( l + r ) >> 1
if query ( sum, add, m, m, m, 1, n, 1 ) >assign to b array of i   ), r assign to m - 1
set pos to m
else l assign to m + 1
if pos is -1, push_back is ans 0
else  push_back ( n - pos + 1 )
update sum, add, pos, n, - m, 1, n, 1
print ans array of i   and "" ""
declare integer main ( ) and integer N assign to 4
create integer Q with Q assign to 3
create integer M with M assign to 1
create vector arr with arr assign to  1, 2, 3, 4
create integer variable query with value 4, 3, 1
create sequenceMaintenance ( N, Q, arr, query, M )
return 0
","Left Rotation and Right Rotation of a String 
 C program untill Left Rotation and Right Rotation of a String ; In - place rotates s towards left by d ; In - place rotates s towards right by d ; Driver code
",0
378,"untill i assign to 0 to n - 1 exclusive, return true if j assign to i + 1 or j  n, increment j, if __gcd ( arr array of i  , arr array of j   ) is 1
return false
declare integer main ( ) and integer n assign to 3
create vector arr with arr assign to  6, 9, 15
if hasCoprimePair ( arr, n ) is true, print 1
else print n
print a newlin
","Minimize Array length by repeatedly replacing co 
 C ++ Program untill the above approach ; Function to find the final array length by replacing coprime pair with 1 ; Iterate over all pairs of element ; Check if gcd is 1 ; If no coprime pair found return false ; Driver code ; Check if atleast one coprime pair exists in the array ; If no such pair exists
",1
379,"untill i assign to 0 to n - 1 exclusive, return true if j assign to i + 1 or j  n, increment j, if __gcd ( arr array of i  , arr array of j   ) is 1
return false
declare integer main ( ) and integer n assign to 3
create vector arr with arr assign to  6, 9, 15
if hasCoprimePair ( arr, n ) is true, print 1
else print n
print a newlin
","Find the repeating and the missing number using two equations 
 C ++ implementation of the approach ; Function to print the required numbers ; Sum of first n natural numbers ; Sum of squares of first n natural numbers ; To store the sum and sum of squares of the array elements ; Driver code
",0
380,"Numberofways assign to integer with Numberofways assign to n, count assign to 0
untill a assign to 1 to n exclusive, set c to n - ( a + b ), untill b assign to 1 to n exclusive, incrementing b, c assign to n - ( a + b ), increment a
if a + b > c and a + c > b and b + c > a, increment count
return count
declare integer main ( ) and integer n assign to 15
print Numberofways ( n )
return 0
","Count of ways to split N into Triplets untillming a Triangle 
 C ++ Program to implement the above approach ; Function to return the required number of ways ; Check if a , b and c can untillm a triangle ; Return number of ways ; Driver Code
",1
381,"Numberofways assign to integer with Numberofways assign to n, count assign to 0
untill a assign to 1 to n exclusive, set c to n - ( a + b ), untill b assign to 1 to n exclusive, incrementing b, c assign to n - ( a + b ), increment a
if a + b > c and a + c > b and b + c > a, increment count
return count
declare integer main ( ) and integer n assign to 15
print Numberofways ( n )
return 0
","Minimum number of bracket reversals needed to make an expression balanced 
 C ++ program to find minimum number of reversals required to balance an expression ; Returns count of minimum reversals untill making expr balanced . Returns - 1 if expr cannot be balanced . ; length of expression must be even to make it balanced by using reversals . ; After this loop , stack contains unbalanced part of expression , i . e . , expression of the untillm "" } } . . } { { . . { "" ; Length of the reduced expression red_len assign to ( m + n ) ; count opening brackets at the end of stack ; return ceil ( m / 2 ) + ceil ( n / 2 ) which is actually equal to ( m + n ) / 2 + n % 2 when m + n is even . ; Driver program to test above function
",0
382,"declare countPairs with integer N, arr array of   as arguments, returning integer, set count to 0
untill i assign to 0 to N exclusive, increment count by 1 if i is arr array of arr array of i   - 1   - 1, increment count
print count / 2 print newline
declare integer main ( ), integer arr array of   assign to  2, 1, 4, 3  ;
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
countPairs ( N, arr )
","Count of pairs having each element equal to index of the other from an Array 
 C ++ program to implement the above approach ; Function to print the count of pair ; Iterate over all the elements of the array ; Increment the count ; Print the result ; Driver Code
",1
383,"declare countPairs with integer N, arr array of   as arguments, returning integer, set count to 0
untill i assign to 0 to N exclusive, increment count by 1 if i is arr array of arr array of i   - 1   - 1, increment count
print count / 2 print newline
declare integer main ( ), integer arr array of   assign to  2, 1, 4, 3  ;
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
countPairs ( N, arr )
","Move all zeroes to end of array 
 A C ++ program to move all zeroes at the end of array ; Function which pushes all zeros to end of an array . ; Count of non - zero elements ; Traverse the array . If element encountered is non - zero , then replace the element at index ' count ' with this element ; here count is ; incremented Now all non - zero elements have been shifted to front and ' count ' is set as index of first 0. Make all elements 0 from count to end . ; Driver program to test above function
",0
384,"declare longestFibSubseq with integer A array of  , integer n as arguments, returning integer, with integers S ( A, A + n) as arguments, returning integer
create integers maxLen with maxLen assign to 0, x, y
untill i assign to 0 to n exclusive, increment i by 1, increment j by n, set x to A array ofj  
y assign to A array of i   + A array of j  
length assign to integer with length assign to 2
untill S. find ( y )not equal to S. end ( ), z assign to x + y
set x to y
set y to z
set maxLen to max ( maxLen, ++ length )
return maxLen if maxLen is greater than or equal to 3 else return 0
declare integer main ( ) and integer array A with size   assign to  1, 2, 3, 4, 5, 6, 7, 8
create integer n with n assign to sizeof ( A ) / sizeof ( A array of 0   )
print LongestFibSubseq ( A, n )
return 0
","Find length of longest Fibonacci like subsequence 
 CPP implementation of above approach ; Function to return the max Length of Fibonacci subsequence ; Store all array elements in a hash table ; check until next fib element is found ; next element of fib subseq ; Driver program
",1
385,"declare longestFibSubseq with integer A array of  , integer n as arguments, returning integer, with integers S ( A, A + n) as arguments, returning integer
create integers maxLen with maxLen assign to 0, x, y
untill i assign to 0 to n exclusive, increment i by 1, increment j by n, set x to A array ofj  
y assign to A array of i   + A array of j  
length assign to integer with length assign to 2
untill S. find ( y )not equal to S. end ( ), z assign to x + y
set x to y
set y to z
set maxLen to max ( maxLen, ++ length )
return maxLen if maxLen is greater than or equal to 3 else return 0
declare integer main ( ) and integer array A with size   assign to  1, 2, 3, 4, 5, 6, 7, 8
create integer n with n assign to sizeof ( A ) / sizeof ( A array of 0   )
print LongestFibSubseq ( A, n )
return 0
","Make all array elements equal by replacing adjacent pairs by their sum 
 C ++ program untill the above approach ; Function to count the minimum number of pairs of adjacent elements required to be replaced by their sum to make all array elements equal ; Stores the prefix sum of the array ; Calculate the prefix sum array ; Stores the maximum number of subarrays into which the array can be split ; Iterate over all possible sums ; Traverse the array ; If the sum is equal to the current prefix sum ; Increment count of groups by 1 ; Otherwise discard this subgroup sum ; Update the maximum this of subarrays ; Return the minimum number of operations ; Driver Code ; Function Call
",0
386,"CountMaximum assign to integer with arr array of  , n, k assign to integer, sort ( arr, arr + n )
declare integers sum assign to 0 and count assign to 0
untill i assign to 0 to n exclusive, add arr array of i   to sum
if sum is greater than k, break loop
increment count
return count
declare integer main ( ), integer arr assign to  30, 30, 10, 10, 10  ; declare integer array arr size   assign to  30, 30, 30, 10, 10  ; declare integer arr assign to  30, 30, 10, 10  ; declare integer arr assign to  30, 30, 10, 10  ; declare integer arr assign to  30, 30, 10
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create integer k with k assign to 50
print CountMaximum ( arr, n, k )
return 0
","Maximize count of elements that can be selected having minimum difference between their sum and K 
 C ++ implementation of the above approach ; Function to count maximum number of elements that can be selected ; Sort he array ; Traverse the array ; Add current element to the sum ; IF sum exceeds k ; Increment count ; Return the count ; Driver Code ; Function call
",1
387,"CountMaximum assign to integer with arr array of  , n, k assign to integer, sort ( arr, arr + n )
declare integers sum assign to 0 and count assign to 0
untill i assign to 0 to n exclusive, add arr array of i   to sum
if sum is greater than k, break loop
increment count
return count
declare integer main ( ), integer arr assign to  30, 30, 10, 10, 10  ; declare integer array arr size   assign to  30, 30, 30, 10, 10  ; declare integer arr assign to  30, 30, 10, 10  ; declare integer arr assign to  30, 30, 10, 10  ; declare integer arr assign to  30, 30, 10
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create integer k with k assign to 50
print CountMaximum ( arr, n, k )
return 0
","Count set bits in an integer 
 CPP implementation untill recursive approach to find the number of set bits using Brian Kernighans Algorithm ; recursive function to count set bits ; base case ; driver code ; get value from user ; function calling
",0
388,"declare integer num_candyTypes ( vector  int > & candies)  unordered_set  int > s
untill i assign to 0 to size of candies, increment i, insert candies array of i   into s
return size of s
let distribute_candies be a void vector of ints > and candies, let allowed be candies. size ( ) / 2
create integer types with types assign to num_candyTypes ( candies )
if types  allowed, print types
else print allowed
declare integer main ( ), vector, integers > candies assign to  4, 4, 5, 5, 3, 3 , 3
distribute_candies ( candies )
return 0
","Maximum types of candies a person can eat if only N / 2 of them can be eaten 
 C ++ program untill the above approach ; Function to find number of candy types ; Declare a hashset to store candies ; Traverse the given array and inserts element into set ; Return the result ; Function to find maximum number of types of candies a person can eat ; Store the number of candies allowed to eat ; Store the number of candy types ; Return the result ; Driver Code ; Given Input ; Function Call
",1
389,"declare integer num_candyTypes ( vector  int > & candies)  unordered_set  int > s
untill i assign to 0 to size of candies, increment i, insert candies array of i   into s
return size of s
let distribute_candies be a void vector of ints > and candies, let allowed be candies. size ( ) / 2
create integer types with types assign to num_candyTypes ( candies )
if types  allowed, print types
else print allowed
declare integer main ( ), vector, integers > candies assign to  4, 4, 5, 5, 3, 3 , 3
distribute_candies ( candies )
return 0
","Check if K palindromic strings can be untillmed from a given string 
 C ++ program to check whether the string is K palindrome or not ; function to check whether the string is K palindrome or not ; map to frequency of character ; Check when k is given as same as length of string ; iterator untill map ; storing the frequency of every character in map ; if K is greater than size of string then return false ; check that number of character having the odd frequency ; if k is less than number of odd frequency character then it is again false other wise true ; Driver code
",0
390,"double Length_Diagonals ( int a, double theta )  double p assign to a * sqrt ( 2 + ( 2 * cos ( theta * 3.141 / 180 ) ) ) )
q assign to double with q assign to a * sqrt ( 2 - ( 2 * cos ( theta * ( 3.141 / 180 ) ) ) )
print fixed print setprecision ( 2 ) print p print "" "" print q
declare integer main ( ) and integer a assign to 6
create integer theta with the value of 45
let Length_Diagonals ( a, theta ) be a integer
return 0
","Length of diagonals of a Rhombus using length of Side and vertex Angle 
 C ++ program to implement the above approach ; Function to calculate the length of diagonals of a rhombus using length of sides and vertex angle ; Driver Code
",1
391,"double Length_Diagonals ( int a, double theta )  double p assign to a * sqrt ( 2 + ( 2 * cos ( theta * 3.141 / 180 ) ) ) )
q assign to double with q assign to a * sqrt ( 2 - ( 2 * cos ( theta * ( 3.141 / 180 ) ) ) )
print fixed print setprecision ( 2 ) print p print "" "" print q
declare integer main ( ) and integer a assign to 6
create integer theta with the value of 45
let Length_Diagonals ( a, theta ) be a integer
return 0
","Number of ways to reach Nth floor by taking at 
 C ++ program to reach N - th stair by taking a maximum of K leap ; elements of combo array of   stores the no of possible ways to reach it by all combinations of k leaps or less ; assuming leap 0 exist and assigning its value to 1 untill calculation ; loop to iterate over all possible leaps upto k ; ; in this loop we count all possible leaps to reach the jth stair with the help of ith leap or less ; if the leap is not more than the i - j ; calculate the value and store in combo array of j   to reuse it untill next leap calculation untill the jth stair ; returns the no of possible number of leaps to reach the top of building of n stairs ; Driver Code ; N i the no of total stairs K is the value of the greatest leap
",0
392,"declare countEvenOdd with integers arr array of  , n, K, even assign to 0 and odd assign to 0
untill i assign to 0 to n exclusive, x assign to __builtin_popcount ( arr array of i   )
if x modulo 2 is 0, increment even
else odd
y assign to integer
set y to __builtin_popcount ( K )
if y & 1 is true, print Even, odd, Odd and even
else print Even, even and Odd
declare integer variable arr assign to  4, 2, 15, 9, 8, 8 , int main
create integer K with K assign to 3
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
countEvenOdd ( arr, n, K)
return 0
","Count of even and odd set bit with array element after XOR with K 
 C ++ program to count the set bits after taking XOR with a number K ; Function to store EVEN and odd variable ; Store the count of even and odd set bit ; Count the set bit using in built function ; Count of set - bit of K ; If y is odd then , count of even and odd set bit will be interchanged ; Else it will remain same as the original array ; Driver 's Code ; Function call to count even and odd
",1
393,"declare countEvenOdd with integers arr array of  , n, K, even assign to 0 and odd assign to 0
untill i assign to 0 to n exclusive, x assign to __builtin_popcount ( arr array of i   )
if x modulo 2 is 0, increment even
else odd
y assign to integer
set y to __builtin_popcount ( K )
if y & 1 is true, print Even, odd, Odd and even
else print Even, even and Odd
declare integer variable arr assign to  4, 2, 15, 9, 8, 8 , int main
create integer K with K assign to 3
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
countEvenOdd ( arr, n, K)
return 0
","Check duplicates in a stream of strings 
 C ++ implementation of the approach ; Function to insert the names and check whether they appear untill the first time ; To store the names of the employees ; If current name is appearing untill the first time ; Driver code
",0
394,"declare integer variable main with name N assign to 6
Even assign to integer with Even assign to N / 2
Odd assign to integer with Odd assign to N - Even
print Even * Odd
return 0
","Number of ways to choose a pair containing an even and an odd number from 1 to N 
 C ++ implementation of the above approach ; Driver code
",1
395,"declare integer variable main with name N assign to 6
Even assign to integer with Even assign to N / 2
Odd assign to integer with Odd assign to N - Even
print Even * Odd
return 0
","Cutting a Rod 
 DP 
 A Dynamic Programming solution untill Rod cutting problem ; A utility function to get the maximum of two integers ; Returns the best obtainable price untill a rod of length n and price array of   as prices of different pieces ; Build the table val array of   in bottom up manner and return the last entry from the table ; Driver program to test above functions
",0
396,"if pair  int, integer > A array of  , integer N, integer lastf assign to INT_MIN, integer lasts assign to INT_MAX, return 0
create integer ans with ans assign to longestSubSequence ( A, N, ind + 1, lastf, lasts )
if A array of ind  is greater than lastf and A array of ind  is less than lasts, set ans to max ( ans, longestSubSequence ( A, N, ind + 1, A array of ind  . first, A array of ind  . second ) + 1 )
return ans
declare integer main ( ), pair, integer > A assign to   1, 2 ,  2, 2 , 3, 1       ; declare integers  A assign to   1, 2 ,  2,  3, 1
create integer N with N assign to sizeof ( A) / sizeof ( A array of 0   )
print longestSubSequence ( A, N ) and "" STRNEWLINE ""
return 0
","Longest subsequence from an array of pairs having first element increasing and second element decreasing . 
 C ++ program untill the above approach ; Recursive function to find the length of the longest subsequence of pairs whose first element is increasing and second is decreasing ; Base case ; Not include the current pair in the longest subsequence ; Including the current pair in the longest subsequence ; Driver Code ; Given Input ; Function Call
",1
397,"if pair  int, integer > A array of  , integer N, integer lastf assign to INT_MIN, integer lasts assign to INT_MAX, return 0
create integer ans with ans assign to longestSubSequence ( A, N, ind + 1, lastf, lasts )
if A array of ind  is greater than lastf and A array of ind  is less than lasts, set ans to max ( ans, longestSubSequence ( A, N, ind + 1, A array of ind  . first, A array of ind  . second ) + 1 )
return ans
declare integer main ( ), pair, integer > A assign to   1, 2 ,  2, 2 , 3, 1       ; declare integers  A assign to   1, 2 ,  2,  3, 1
create integer N with N assign to sizeof ( A) / sizeof ( A array of 0   )
print longestSubSequence ( A, N ) and "" STRNEWLINE ""
return 0
","Removing row or column wise duplicates from matrix of characters 
 CPP code to untillm string after removing duplicates from rows and columns . ; Function to check duplicates in row and column ; Create an array isPresent and initialize all entries of it as false . The value of isPresent array of i   array of j   is going to be true if s array of i   array of j   is present in its row or column . ; Checking every row untill duplicates of a array of i   array of j   ; Checking every column untill duplicate characters ; If the character is unique in its row and column ; Driver code ; character array ; Calling function
",0
398,"declare integer variable countTriplets with vector  integer > & A, cnt assign to 0
create an array of ints, ints with int > tuples
untill a : A, untill b : A, increment tuples array of a & b  
untill a : A, if t. first & a ) is 0, increment cnt by t. second
return cnt
declare integer main ( ), vector A assign to  2, 1, 3 , integers
print countTriplets ( A)
return 0
","Count triples with Bitwise AND equal to Zero 
 C ++ program untill the above approach ; Function to find the number of triplets whose Bitwise AND is 0. ; Stores the count of triplets having bitwise AND equal to 0 ; Stores frequencies of all possible A array of i   & A array of j   ; Traverse the array ; Update frequency of Bitwise AND of all array elements with a ; Traverse the array ; Iterate the map ; If bitwise AND of triplet is zero , increment cnt ; Return the number of triplets whose Bitwise AND is 0. ; Driver Code ; Input Array ; Function Call
",1
399,"declare integer variable countTriplets with vector  integer > & A, cnt assign to 0
create an array of ints, ints with int > tuples
untill a : A, untill b : A, increment tuples array of a & b  
untill a : A, if t. first & a ) is 0, increment cnt by t. second
return cnt
declare integer main ( ), vector A assign to  2, 1, 3 , integers
print countTriplets ( A)
return 0
","Longest substring with K unique characters using Binary Search 
 C ++ implementation of the approach ; Function that returns true if there is a substring of length len with <assign to k unique characters ; Size of the string ; Map to store the characters and their frequency ; Update the map untill the first substring ; Check untill the rest of the substrings ; Add the new character ; Remove the first character of the previous window ; Update the map ; Function to return the length of the longest substring which has K unique characters ; Check if the complete string contains K unique characters ; Size of the string ; Apply binary search ; Driver code
",0
400,"declare integer CountWays with integer n, noOfWays assign to array of integers of length n + 3
noOfWays array of 0   assign to 1
noOfWays array of 1   assign to 1
noOfWays array of 2  assign to 1 + 1
untill i assign to 3 to n + 1 exclusive, set noOfWays array of i   to noOfWays array of i - 1   + noOfWays array of i - 3  
return noOfWays array of n  
declare integer main ( ) and integer n assign to 0
print CountWays ( n )
return 0
","Count ways to reach a score using 1 and 2 with no consecutive 2 s 
 Bottom up approach untill counting ways to reach a score using 1 and 2 with consecutive 2 allowed ; noOfWays array of i   will store count untill value i . 3 extra values are to take care of corner case n assign to 0 ; Loop till "" n + 1"" to compute value untill "" n "" ; number of ways if first run is 1 ; Driver code
",1
401,"declare integer CountWays with integer n, noOfWays assign to array of integers of length n + 3
noOfWays array of 0   assign to 1
noOfWays array of 1   assign to 1
noOfWays array of 2  assign to 1 + 1
untill i assign to 3 to n + 1 exclusive, set noOfWays array of i   to noOfWays array of i - 1   + noOfWays array of i - 3  
return noOfWays array of n  
declare integer main ( ) and integer n assign to 0
print CountWays ( n )
return 0
","Sort the array in a given index range 
 C ++ program to sort the array in a given index range ; Function to sort the elements of the array from index a to index b ; Variables to store start and end of the index range ; Temporary array ; Sort the temporary array ; Modifying original array with temporary array elements ; Print the modified array ; Driver code ; length of the array
",0
402,"declare printSpiral with integer size assign to 0 and col assign to 0
define integer boundary assign to size - 1
sizeLeft assign to size - 1
create integer flag with flag assign to 1
move assign to'r '
create integer matrix array of size   array of size   assign to  0
untill i assign to 1 to size * size + 1 exclusive, matrix array of row   array of col   assign to i
change case'r' if move is true, increment col by 1
break loop
l assign to case : col - 1
break loop
u assign to case : row - 1
break loop
create case'd' : row + 1
break loop
if i is boundary, increment boundary by sizeLeft
if flag is not 2 set flag to 2
else set flag to 1
decrement sizeLeft by 1
change the value of switch to case'r' if move is 'd'
break loop
create case'd' : move assign to'l'
break loop
let case'l' : move assign to'u'
break loop
let u be a case : move assign to'r '
break loop
untill row assign to 0 to size exclusive, set n to matrix array of row  array of col 
if n is less than 10 print n and "" ""
else print n and "" ""
print a new line
declare integer main ( ) and size assign to 5
printSpiral is a new line
return 0
","Program to print Spiral Pattern 
  ; Create row and col to traverse rows and columns ; Variable to determine the movement r assign to right , l assign to left , d assign to down , u assign to upper ; Array untill matrix ; Assign the value ; switch - case to determine the next index ; If right , go right ; if left , go left ; if up , go up ; if down , go down ; Check if the matrix has reached array boundary ; Add the left size untill the next boundary ; If 2 rotations has been made , decrease the size left by 1 ; switch - case to rotate the movement ; if right , rotate to down ; if down , rotate to left ; if left , rotate to up ; if up , rotate to right ; Print the matrix ; Driver Code ; Get the size of size ; Print the Spiral Pattern
",1
403,"declare printSpiral with integer size assign to 0 and col assign to 0
define integer boundary assign to size - 1
sizeLeft assign to size - 1
create integer flag with flag assign to 1
move assign to'r '
create integer matrix array of size   array of size   assign to  0
untill i assign to 1 to size * size + 1 exclusive, matrix array of row   array of col   assign to i
change case'r' if move is true, increment col by 1
break loop
l assign to case : col - 1
break loop
u assign to case : row - 1
break loop
create case'd' : row + 1
break loop
if i is boundary, increment boundary by sizeLeft
if flag is not 2 set flag to 2
else set flag to 1
decrement sizeLeft by 1
change the value of switch to case'r' if move is 'd'
break loop
create case'd' : move assign to'l'
break loop
let case'l' : move assign to'u'
break loop
let u be a case : move assign to'r '
break loop
untill row assign to 0 to size exclusive, set n to matrix array of row  array of col 
if n is less than 10 print n and "" ""
else print n and "" ""
print a new line
declare integer main ( ) and size assign to 5
printSpiral is a new line
return 0
","Find length of longest Fibonacci like subsequence 
 CPP implementation of above approach ; Function to return the max Length of Fibonacci subsequence ; Store all array elements in a hash table ; check until next fib element is found ; next element of fib subseq ; Driver program
",0
404,"declare findWinner with string a, integer n as arguments, returning vector, with integers > v
create integer c with c assign to 0
untill i assign to 0 to n exclusive, if a array of i   is '0', increment c
else if c is not 0, push_back v
set c to 0
if c is not 0, push_back v
if size of v is 0, print Player B
return
if size of v is 1 print Player A
else print Player B
return
create integer first with first assign to INT_MIN
create integer second with second assign to INT_MIN
untill i assign to 0 to size of v exclusive, if a array of i   is greater than first, set second to first
set first to a array of i  
else if a array of i   > second and a array of i  not equal to first, second assign to a array of i  
if first & 1 ) and first + 1 / 2 > second, print Player A
else print Player B
declare integer main ( ) and string S assign to ""1100011""
create integer N with N assign to length of S
create findWinner ( S, N )
return 0
","Find the last player to be able to flip a character in a Binary String 
 C ++ program untill the above approach ; Function to check if player A wins the game or not ; Stores size of the groups of 0 s ; Stores size of the group of 0 s ; Traverse the array ; Increment c by 1 if a array of i   is 0 ; Otherwise , push the size in array and reset c to 0 ; If there is no substring of odd length consisting only of 0 s ; If there is only 1 substring of odd length consisting only of 0 s ; Otherwise ; Stores the size of the largest and second largest substrings of 0 s ; Traverse the array v array of   ; If current element is greater than first , then update both first and second ; If arr array of i   is in between first and second , then update second ; If the condition is satisfied ; Driver Code
",1
405,"declare findWinner with string a, integer n as arguments, returning vector, with integers > v
create integer c with c assign to 0
untill i assign to 0 to n exclusive, if a array of i   is '0', increment c
else if c is not 0, push_back v
set c to 0
if c is not 0, push_back v
if size of v is 0, print Player B
return
if size of v is 1 print Player A
else print Player B
return
create integer first with first assign to INT_MIN
create integer second with second assign to INT_MIN
untill i assign to 0 to size of v exclusive, if a array of i   is greater than first, set second to first
set first to a array of i  
else if a array of i   > second and a array of i  not equal to first, second assign to a array of i  
if first & 1 ) and first + 1 / 2 > second, print Player A
else print Player B
declare integer main ( ) and string S assign to ""1100011""
create integer N with N assign to length of S
create findWinner ( S, N )
return 0
","Minimum steps to convert all top left to bottom right paths in Matrix as palindrome 
 Set 2 
 C ++ program untill the above approach ; Function untill counting minimum number of changes ; Distance of elements from ( 0 , 0 ) will is i range array of 0 , n + m - 2   ; Store frequencies of array of 0 , 9   at distance i ; Initialize frequencies as 0 ; Count frequencies of array of 0 , 9   ; Increment frequency of value matrix array of i   array of j   at distance i + j ; Find value with max frequency and count total cells at distance i from front end and rear end ; Change all values to the value with max frequency ; Return the answer ; Driver Code ; Given Matrix ; Function Call
",0
406,"create boolean can_Construct ( string S, int K), map, int, int > m
create integers i, j, p with i assign to 0 and j assign to 0 and p assign to 0
if length of S is K return true
create map, int > :: iterator h
untill i assign to 0 to length of S, increment i, m array of S array of i    assign to m array of S array of i     + 1
if K > S. length ( ) return false
else if h assign to m. begin ( ), hnot equal to m. end ( ), h ++ ), if m array of h -> first   modulo 2 is not 0, set p to p + 1
if K is less than p, return false
return true
declare integer main ( ) and string S assign to "" annabelle ""
create integer K with K assign to 4
if can_Construct ( S, K ) is true, print Yes
else print No
print a newlin
","Check if K palindromic strings can be untillmed from a given string 
 C ++ program to check whether the string is K palindrome or not ; function to check whether the string is K palindrome or not ; map to frequency of character ; Check when k is given as same as length of string ; iterator untill map ; storing the frequency of every character in map ; if K is greater than size of string then return false ; check that number of character having the odd frequency ; if k is less than number of odd frequency character then it is again false other wise true ; Driver code
",1
407,"create boolean can_Construct ( string S, int K), map, int, int > m
create integers i, j, p with i assign to 0 and j assign to 0 and p assign to 0
if length of S is K return true
create map, int > :: iterator h
untill i assign to 0 to length of S, increment i, m array of S array of i    assign to m array of S array of i     + 1
if K > S. length ( ) return false
else if h assign to m. begin ( ), hnot equal to m. end ( ), h ++ ), if m array of h -> first   modulo 2 is not 0, set p to p + 1
if K is less than p, return false
return true
declare integer main ( ) and string S assign to "" annabelle ""
create integer K with K assign to 4
if can_Construct ( S, K ) is true, print Yes
else print No
print a newlin
","Sorting rows of matrix in ascending order followed by columns in descending order 
 C ++ implementation to sort the rows of matrix in ascending order followed by sorting the columns in descending order ; function to sort each row of the matrix according to the order specified by ascending . ; function to find transpose of the matrix ; swapping element at index ( i , j ) by element at index ( j , i ) ; function to sort the matrix row - wise and column - wise ; sort rows of mat array of   array of   ; get transpose of mat array of   array of   ; again sort rows of mat array of   array of   in descending order . ; again get transpose of mat array of   array of   ; function to print the matrix ; Driver program to test above
",0
408,"create equalIgnoreCase ( string str1, string str2 )  integer i assign to 0
transuntillm str1. begin ( ), str1. end ( ), str1. begin ( ), :: tolower )
transuntillm str2. begin ( ), str2. end ( ), str2. begin ( ), :: tolower )
x assign to integer with x assign to str1 and compare assign to str2
if x is not 0, return false
else return true
res assign to equalIgnoreCase ( str1, str2 ), res assign to boolean res assign to equalIgnoreCase ( str1, str2 )
if res is true, print Same
else print Not Same
declare integer main ( ), string str1 and str2
set str1 to Geeks
set str2 to geeks
set equalIgnoreCaseUtil to str1, str2
set str1 to "" Geek ""
set str2 to geeksuntillgeeks
set equalIgnoreCaseUtil to str1, str2
return 0
","Check if two strings are same ignoring their cases 
  ; Function to compare two strings ignoring their cases ; Convert to lowercase using transuntillm ( ) function and :: tolower in STL ; Comparing both using inbuilt function ; if strings are equal , return true otherwise false ; Function to print the same or not same if strings are equal or not equal ; Driver Code
",1
409,"create equalIgnoreCase ( string str1, string str2 )  integer i assign to 0
transuntillm str1. begin ( ), str1. end ( ), str1. begin ( ), :: tolower )
transuntillm str2. begin ( ), str2. end ( ), str2. begin ( ), :: tolower )
x assign to integer with x assign to str1 and compare assign to str2
if x is not 0, return false
else return true
res assign to equalIgnoreCase ( str1, str2 ), res assign to boolean res assign to equalIgnoreCase ( str1, str2 )
if res is true, print Same
else print Not Same
declare integer main ( ), string str1 and str2
set str1 to Geeks
set str2 to geeks
set equalIgnoreCaseUtil to str1, str2
set str1 to "" Geek ""
set str2 to geeksuntillgeeks
set equalIgnoreCaseUtil to str1, str2
return 0
","Program to find the N 
 C ++ program to find n - th number containing only 3 and 5. ; If n is odd , append 3 and move to parent ; If n is even , append 5 and move to parent ; Reverse res and return . ; Driver code
",0
410,"declare steps with string str, integer n as arguments, returning boolean flag
create integer x with x assign to 0
untill i assign to 0 to length of str ( ) exclusive, flag assign to true if x is equal to 0
if x is n - 1 set flag to false
untill j assign to 0 to x exclusive, print *
print str array of i  and "" STRNEWLINE ""
if flag is true, increment x
else x assign to x - 0
declare integer main ( ) and integer n assign to 4
create string str with str assign to GeeksForGeeks
print String : "", str
print Max Length of Steps : "", n
steps assign to str, n
return 0
","Program to print Step Pattern 
 C ++ program to print Step Pattern ; function to print the steps ; declare a flag ; traverse through all the characters in the string ; if the x value is 0. . then we must increment till n ... set flag to true ; if the x value is n - 1 then we must decrement till 0 ... set flag as false ; print x * s ; checking whether to increment or decrement x ; Driver code ; Get the String and the number n ; calling the function
",1
411,"declare steps with string str, integer n as arguments, returning boolean flag
create integer x with x assign to 0
untill i assign to 0 to length of str ( ) exclusive, flag assign to true if x is equal to 0
if x is n - 1 set flag to false
untill j assign to 0 to x exclusive, print *
print str array of i  and "" STRNEWLINE ""
if flag is true, increment x
else x assign to x - 0
declare integer main ( ) and integer n assign to 4
create string str with str assign to GeeksForGeeks
print String : "", str
print Max Length of Steps : "", n
steps assign to str, n
return 0
","Longest Common Increasing Subsequence ( LCS + LIS ) 
 A C ++ Program to find length of the Longest Common Increasing Subsequence ( LCIS ) ; Returns the length and the LCIS of two arrays arr1 array of 0. . n - 1   and arr2 array of 0. . m - 1   ; table array of j   is going to store length of LCIS ending with arr2 array of j   . We initialize it as 0 , ; Traverse all elements of arr1 array of   ; Initialize current length of LCIS ; For each element of arr1 array of   , traverse all elements of arr2 array of   . ; If both the array have same elements . Note that we don 't break the loop here. ; Now seek untill previous smaller common element untill current element of arr1 ; The maximum value in table array of   is out result ; Driver program to test above function
",0
412,"declare countFreq with integer arr array of  , integer n, vector  integer > visited ( n, false )
untill i assign to 0 to n exclusive, if visited array of i   is true, continue
count assign to integer with count assign to 1
untill j assign to i + 1 to n exclusive, if arr array of i   is arr array of j  , visited array of j   assign to true
increment count
print arr array of i  print "" "" print count print newline
declare integer main ( ) and integer arr array of   assign to  10, 20, 20, 10, 10, 20, 5, 20  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
countFreq assign to arr,n
return 0
","Frequency Measuring Techniques untill Competitive Programming 
 C ++ program to count frequencies of array items ; Mark all array elements as not visited ; Traverse through array elements and count frequencies ; Skip this element if already processed ; Count frequency ; Driver Code
",1
413,"declare countFreq with integer arr array of  , integer n, vector  integer > visited ( n, false )
untill i assign to 0 to n exclusive, if visited array of i   is true, continue
count assign to integer with count assign to 1
untill j assign to i + 1 to n exclusive, if arr array of i   is arr array of j  , visited array of j   assign to true
increment count
print arr array of i  print "" "" print count print newline
declare integer main ( ) and integer arr array of   assign to  10, 20, 20, 10, 10, 20, 5, 20  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
countFreq assign to arr,n
return 0
","Sparse Table 
 C ++ program to do range minimum query using sparse table ; lookup array of i   array of j   is going to store minimum value in arr array of i . . j   . Ideally lookup table size should not be fixed and should be determined using n Log n . It is kept constant to keep code simple . ; Fills lookup array lookup array of   array of   in bottom up manner . ; Initialize M untill the intervals with length 1 ; Compute values from smaller to bigger intervals ; Compute minimum value untill all intervals with size 2 to the power j ; For arr array of 2   array of 10   , we compare arr array of lookup array of 0   array of 7     and arr array of lookup array of 3   array of 10     ; Returns minimum of arr array of L . . R   ; Find highest power of 2 that is smaller than or equal to count of elements in given range . For array of 2 , 10   , j assign to 3 ; Compute minimum of last 2 to the power j elements with first 2 to the power j elements in range . For array of 2 , 10   , we compare arr array of lookup array of 0   array of 3     and arr array of lookup array of 3   array of 3     , ; Driver program
",0
414,"create boolean isDivisible with str array of  , k, n assign to strlen ( str )
create integer c with c assign to 0
untill i assign to 0 to k exclusive, if str array of n - i - 1   is '0', increment c
return ( c is k )
declare integer main ( ) and char str1 array of   assign to ""10101100""
create integer k with k assign to 2
if isDivisible ( str1, k ) ), print Yes
else print No and STRNEWLINE
str2 assign to character array with size   assign to ""111010100""
set k to 2
if isDivisible ( str2, k ) ), print Yes
else print No
return 0
","Check divisibility of binary string by 2 to the power k 
 C ++ implementation to check whether given binary number is evenly divisible by 2 to the power k or not ; function to check whether given binary number is evenly divisible by 2 to the power k or not ; count of number of 0 from last ; if count assign to k , number is evenly divisible , so returns true else false ; Driver program to test above ; first example ; Second example
",1
415,"create boolean isDivisible with str array of  , k, n assign to strlen ( str )
create integer c with c assign to 0
untill i assign to 0 to k exclusive, if str array of n - i - 1   is '0', increment c
return ( c is k )
declare integer main ( ) and char str1 array of   assign to ""10101100""
create integer k with k assign to 2
if isDivisible ( str1, k ) ), print Yes
else print No and STRNEWLINE
str2 assign to character array with size   assign to ""111010100""
set k to 2
if isDivisible ( str2, k ) ), print Yes
else print No
return 0
","Sum of series with alternate signed squares of AP 
 Efficient CPP program to find sum of series with alternate signed square AP sums . ; function to calculate series sum ; Driver code
",0
416,"create boolean canFormPalindrome with str string, count assign to integer array of NO_OF_CHARS with value 0
untill i assign to 0 to str array ofi  ; increment i, increment count array of str array ofi     
odd assign to integer with odd assign to 0
untill i assign to 0 to NO_OF_CHARS exclusive, increment odd by 1
if odd is greater than 1 return false
return true
print Yes STRNEWLINE if geeksuntillgeeks is true, else print No STRNEWLINE
print Yes STRNEWLINE if geeksogeeks is true, else print No STRNEWLINE
return 0
","Check if any anagram of a string is palindrome or not 
  ; function to check whether characters of a string can untillm a palindrome ; Create a count array and initialize all values as 0 ; For each character in input strings , increment count in the corresponding count array ; Count odd occurring characters ; Return true if odd count is 0 or 1 , ; Driver program to test to print printDups
",1
417,"create boolean canFormPalindrome with str string, count assign to integer array of NO_OF_CHARS with value 0
untill i assign to 0 to str array ofi  ; increment i, increment count array of str array ofi     
odd assign to integer with odd assign to 0
untill i assign to 0 to NO_OF_CHARS exclusive, increment odd by 1
if odd is greater than 1 return false
return true
print Yes STRNEWLINE if geeksuntillgeeks is true, else print No STRNEWLINE
print Yes STRNEWLINE if geeksogeeks is true, else print No STRNEWLINE
return 0
","Minimum number of points required to cover all blocks of a 2 
 C ++ program untill the above approach ; Function to find the minimum number of Points required to cover a grid ; If number of block is even ; Return the minimum points ; Driver Code ; Given size of grid ; Function Call
",0
418,"if i assign to 0, i  length of s, increment i, if isdigit ( s array of i   ) is false, return false
return true
declare integer main ( ), string str assign to ""6790""
if isNumber ( str ) is true, print ""Integer ""
else print String
","Program to check if input is an integer or a string 
 CPP program to check if a given string is a valid integer ; Returns true if s is a number else false ; Driver code ; Saving the input in a string ; Function returns 1 if all elements are in range '0-9' ; Function returns 0 if the input is not an integer
",1
419,"if i assign to 0, i  length of s, increment i, if isdigit ( s array of i   ) is false, return false
return true
declare integer main ( ), string str assign to ""6790""
if isNumber ( str ) is true, print ""Integer ""
else print String
","Counts paths from a point to reach Origin 
 C ++ Program untill above approach ; Function to find binomial Coefficient ; Constructing Pascal 's Triangle ; Driver Code
",0
420,"reverse is a void function with str arguments if size of str is 0 then return
reverse str. substr ( 1 ) )
print str array of 0  
declare integer main ( ) and string a assign to Geeks untill Geeks
reverse a
return 0
","Print reverse of a string using recursion 
 C ++ program to reverse a string using recursion ; Function to print reverse of the passed string ; Driver program to test above function
",1
421,"reverse is a void function with str arguments if size of str is 0 then return
reverse str. substr ( 1 ) )
print str array of 0  
declare integer main ( ) and string a assign to Geeks untill Geeks
reverse a
return 0
","Minimum steps untill increasing and decreasing Array to reach either 0 or N 
 C ++ program untill the above approach ; Function that finds the minimum steps to reach either 0 or N untill given increasing and decreasing arrays ; Initialize variable to find the minimum element ; Find minimum element in increasing array of   array ; Initialize variable to find the maximum element ; Find maximum element in decreasing array of   array ; Find the minimum steps ; Print the minimum steps ; Driver code ; Given N ; Given increasing and decreasing array ; Find length of arrays increasing and decreasing ; Function call
",0
422,"create static integer box1 with box1 assign to 0
create static integer box2 with box2 assign to 0
declare static integer fact array of 11 
declare getProbability with integer balls array of  , M, factorial ( 10 ) as arguments, returning double
set box2 to M
create integer K with K assign to 0
untill i assign to 0 to M exclusive, increment K by balls array of i  
if K modulo 2 is 1 return 0
let all be a long integer with all assign to comb ( K, K / 2)
declare long validPermutation assign to validPermutations ( K / 2, balls, 0, 0, M )
return validPermutation / all
if usedBalls is equal to n, return box1 if usedBalls is equal to box2? 1 : 0
if i >assign to M, return 0
res assign to validPermutations ( n, balls, usedBalls, i + 1, M )
increment box1
untill j assign to 1 to balls array of i  , if j is balls array of i  , set box2 to box2
create long combinations with combinations assign to comb ( balls array of i  , j )
increment res by combinations * validPermutations ( n, balls, usedBalls + j, i + 1, M )
print box1
increment box2
return res
declare factorial with integer N as argument, set fact array of0  to 1
untill i assign to 1 to N inclusive, set fact array of i   to fact array of i - 1   * i
comb assign to int n, int r, long res assign to fact array of n   / fact array of r  
divide res by fact array of n - r  
return res
declare integer main ( ), integer arr array of   assign to  2, 1, 1  ;
create integer N with N assign to 4
create integer M with M assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print getProbability ( arr, M )
return 0
","Probability of distributing given balls into two halves having equal count of distinct colors 
 C ++ program untill the above approach ; Stores the count of distinct colors in box1 ; Stores the count of distinct colors in box2 ; Function to calculate the required probability ; Calculate factorial from array of 1 , 10   ; Assign all distinct balls to second box ; Total number of balls ; Calculate total number of balls ; If K is an odd number ; Total ways of distributing the balls in two equal halves ; Required number of ways ; Return the required probability ; Function to calculate total number of possible distributions which satisfies the given conditions ; If used balls is equal to K / 2 ; If box1 is equal to box2 ; Base condition ; Stores the number of ways of distributing remaining balls without including the current balls in box1 ; Increment box1 by one ; Iterate over the range array of 1 , balls array of i     ; If all the balls goes to box1 , then decrease box2 by one ; Total number of ways of selecting j balls ; Increment res by total number of valid ways of distributing the remaining balls ; Decrement box1 by one ; Increment box2 by 1 ; Function to calculate factorial of N ; Base Case ; Iterate over the range array of 1 , N   ; Function to calculate NcR ; Driver Code ; Print the result
",1
423,"create static integer box1 with box1 assign to 0
create static integer box2 with box2 assign to 0
declare static integer fact array of 11 
declare getProbability with integer balls array of  , M, factorial ( 10 ) as arguments, returning double
set box2 to M
create integer K with K assign to 0
untill i assign to 0 to M exclusive, increment K by balls array of i  
if K modulo 2 is 1 return 0
let all be a long integer with all assign to comb ( K, K / 2)
declare long validPermutation assign to validPermutations ( K / 2, balls, 0, 0, M )
return validPermutation / all
if usedBalls is equal to n, return box1 if usedBalls is equal to box2? 1 : 0
if i >assign to M, return 0
res assign to validPermutations ( n, balls, usedBalls, i + 1, M )
increment box1
untill j assign to 1 to balls array of i  , if j is balls array of i  , set box2 to box2
create long combinations with combinations assign to comb ( balls array of i  , j )
increment res by combinations * validPermutations ( n, balls, usedBalls + j, i + 1, M )
print box1
increment box2
return res
declare factorial with integer N as argument, set fact array of0  to 1
untill i assign to 1 to N inclusive, set fact array of i   to fact array of i - 1   * i
comb assign to int n, int r, long res assign to fact array of n   / fact array of r  
divide res by fact array of n - r  
return res
declare integer main ( ), integer arr array of   assign to  2, 1, 1  ;
create integer N with N assign to 4
create integer M with M assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print getProbability ( arr, M )
return 0
","Split first N natural numbers into two sets with minimum absolute difference of their sums 
 C ++ program to implement the above approach ; Function to split the first N natural numbers into two sets having minimum absolute difference of their sums ; Stores the sum of elements of set1 ; Stores the sum of elements of set2 ; Traverse first N natural numbers ; Check if sum of elements of set1 is less than or equal to sum of elements of set2 ; Driver Code
",0
424,"if r is less than 0 and n is less than 0, return -1
A assign to ( ( r * r * n ) * sin ( ( 360 / n ) * 3.14159 / 180 ) ) / 2
return A
declare integer main ( ), float r assign to 9, n assign to 6
print polyarea ( n, r ) and a new line
return 0
","Area of a n 
 C ++ Program to find the area of a regular polygon with given radius ; Function to find the area of a regular polygon ; Side and radius cannot be negative ; Area degree converted to radians ; Driver code
",1
425,"if r is less than 0 and n is less than 0, return -1
A assign to ( ( r * r * n ) * sin ( ( 360 / n ) * 3.14159 / 180 ) ) / 2
return A
declare integer main ( ), float r assign to 9, n assign to 6
print polyarea ( n, r ) and a new line
return 0
","Sparse Table 
 C ++ program to do range minimum query using sparse table ; lookup array of i   array of j   is going to store GCD of arr array of i . . j   . Ideally lookup table size should not be fixed and should be determined using n Log n . It is kept constant to keep code simple . ; it builds sparse table . ; GCD of single element is element itself ; Build sparse table ; Returns GCD of arr array of L . . R   ; Find highest power of 2 that is smaller than or equal to count of elements in given range . For array of 2 , 10   , j assign to 3 ; Compute GCD of last 2 to the power j elements with first 2 to the power j elements in range . For array of 2 , 10   , we find GCD of arr array of lookup array of 0   array of 3     and arr array of lookup array of 3   array of 3     , ; Driver program
",0
426,"declare is_partition_possible (int n, int x array of  , int y array of  , int w array of   ) map, int > weight_at_x
create integers max_x assign to -2e3 and min_x assign to 2e3
untill i assign to 0 to n exclusive, new_x assign to x array of i   - y array of i  
set max_x to max ( max_x, new_x )
min_x assign to min ( min_x, new_x )
increase weight_at_x array of new_x  by w array of i  
create vector  integer > sum_till
push_back assign to sum_till. push_back assign to 0
untill x assign to min_x to max_x inclusive, push_back ( sum_till. back ( ) + weight_at_x array of x   ) )
declare integer total_sum assign to sum_till. back ( )
partition_possible assign to integer with partition_possible assign to false
untill i assign to 1 to size of sum_till, i ++, if sum_till array of i   is total_sum - sum_till array of i   partition_possible assign to true
if sum_till array of i - 1   is total_sum - sum_till array of i   partition_possible assign to true
printf if partition_possible is true, else printf if YES STRNEWLINE is true, otherwise print NO STRNEWLINE
declare integer main ( ) and integer n assign to 3
create integer x with x assign to  -1, -2, 1  ;
create integer y with y assign to  1, 1, -1
create integer w with w assign to  3, 1, 4
declare is_partition_possible ( n, x, y, w )
return 0
","Check if a line at 45 degree can divide the plane into two equal weight parts 
  ; Checking if a plane can be divide by a line at 45 degrees such that weight sum is equal ; Rotating each point by 45 degrees and calculating prefix sum . Also , finding maximum and minimum x coordinates ; storing weight sum upto x - y point ; Finding prefix sum ; Line passes through i , so it neither falls left nor right . ; Driven Program
",1
427,"declare is_partition_possible (int n, int x array of  , int y array of  , int w array of   ) map, int > weight_at_x
create integers max_x assign to -2e3 and min_x assign to 2e3
untill i assign to 0 to n exclusive, new_x assign to x array of i   - y array of i  
set max_x to max ( max_x, new_x )
min_x assign to min ( min_x, new_x )
increase weight_at_x array of new_x  by w array of i  
create vector  integer > sum_till
push_back assign to sum_till. push_back assign to 0
untill x assign to min_x to max_x inclusive, push_back ( sum_till. back ( ) + weight_at_x array of x   ) )
declare integer total_sum assign to sum_till. back ( )
partition_possible assign to integer with partition_possible assign to false
untill i assign to 1 to size of sum_till, i ++, if sum_till array of i   is total_sum - sum_till array of i   partition_possible assign to true
if sum_till array of i - 1   is total_sum - sum_till array of i   partition_possible assign to true
printf if partition_possible is true, else printf if YES STRNEWLINE is true, otherwise print NO STRNEWLINE
declare integer main ( ) and integer n assign to 3
create integer x with x assign to  -1, -2, 1  ;
create integer y with y assign to  1, 1, -1
create integer w with w assign to  3, 1, 4
declare is_partition_possible ( n, x, y, w )
return 0
","Rearrange positive and negative numbers with constant extra space 
 C ++ program to Rearrange positive and negative numbers in a array ; A utility function to print an array of size n ; Function to Rearrange positive and negative numbers in a array ; if current element is positive do nothing ; if current element is negative , shift positive elements of arr array of 0. . i - 1   , to one position to their right ; Put negative element at its right position ; Driver program to test above functions
",0
428,"return -1.0 / m from function findPCSlope
declare integer main ( ) and double m assign to 2.0
print findPCSlope ( m )
return 0
","Slope of perpendicular to line 
 C ++ program find slope of perpendicular line ; Function to find the Slope of other line ; Driver code
",1
429,"return -1.0 / m from function findPCSlope
declare integer main ( ) and double m assign to 2.0
print findPCSlope ( m )
return 0
","Program to print Step Pattern 
 C ++ program to print Step Pattern ; function to print the steps ; declare a flag ; traverse through all the characters in the string ; if the x value is 0. . then we must increment till n ... set flag to true ; if the x value is n - 1 then we must decrement till 0 ... set flag as false ; print x * s ; checking whether to increment or decrement x ; Driver code ; Get the String and the number n ; calling the function
",0
430,"pi assign to 3.14159
float area_of_segment (float radius,float angle)  float area_of_sector assign to pi * ( radius * radius) * ( angle / 360 )
declare float area_of_triangle assign to (float ) 1 / 2 * ( radius * radius ) * sin ( angle * pi ) / 180)
return area_of_sector - area_of_triangle
declare integer main ( ), float radius assign to 10.0, angle assign to 90.0
print "" Area of minor segment"" print area_of_segment ( radius, angle) print newline
print "" Area of major segment"" print area_of_segment ( radius, 360 - angle)
","Program to find area of a Circular Segment 
 C ++ Program to find area of segment of a circle ; Function to find area of segment ; Calculating area of sector ; Calculating area of triangle ; Driver Code
",1
431,"pi assign to 3.14159
float area_of_segment (float radius,float angle)  float area_of_sector assign to pi * ( radius * radius) * ( angle / 360 )
declare float area_of_triangle assign to (float ) 1 / 2 * ( radius * radius ) * sin ( angle * pi ) / 180)
return area_of_sector - area_of_triangle
declare integer main ( ), float radius assign to 10.0, angle assign to 90.0
print "" Area of minor segment"" print area_of_segment ( radius, angle) print newline
print "" Area of major segment"" print area_of_segment ( radius, 360 - angle)
","Check untill Majority Element in a sorted array 
 C ++ Program to check untill majority element in a sorted array ; get last index according to n ( even or odd ) ; search untill first occurrence of x in arr array of   ; check if x is present and is present more than n / 2 times ; Driver code
",0
432,"void function SectorArea ( double radius, double angle) if angle >assign to 360, print Angle not possible
else  double sector assign to ( ( 22 * radius * radius ) / 7 ) * ( angle / 360 )
print sector
declare integer main ( ) and double radius assign to 9
create double angle with angle assign to 60
SectorArea ( radius, angle)
return 0
","Area of a Circular Sector 
 C ++ program to find Area of a Sector ; Calculating area of the sector ; Driver code
",1
433,"void function SectorArea ( double radius, double angle) if angle >assign to 360, print Angle not possible
else  double sector assign to ( ( 22 * radius * radius ) / 7 ) * ( angle / 360 )
print sector
declare integer main ( ) and double radius assign to 9
create double angle with angle assign to 60
SectorArea ( radius, angle)
return 0
","Number of ways to choose a pair containing an even and an odd number from 1 to N 
 C ++ implementation of the above approach ; Driver code
",0
434,"declare certaindered_map  int, int > PrimeFactor ( int N), unordered_map  int, int > primef
untill N modulo 2 is 0, increment primef array of 2  by 1
else set primef array of 2  to 1
N / 2
untill i assign to 3 to sqrt ( N ), untill N modulo i is 0, increment primef array of i   by 1
else set primef array of i   to 1
N / 2
if N is greater than 2 set primef array of N  to 1
return primef
CountToMakeEqual assign to integer with X, Y, gcdofXY assign to __gcd ( X, Y )
create integer newX with newX assign to Y / gcdofXY
create integer newY with newY assign to X / gcdofXY
create an array of ints, ints with int value primeX
create an array of ints, ints with int value primeY
set primeX to PrimeFactor ( newX )
set primeY to PrimeFactor ( newY )
ans assign to integer with ans assign to 0
return -1 if X modulo c is not 0
increment ans by primeX array of c. first  
return -1 if Y modulo c is not 0
increment ans by primeY array of c. first  
return ans
declare integer main ( ) and integer X assign to 36
create integer Y with Y assign to 48
create integer ans with ans assign to CountToMakeEqual ( X, Y )
print ans
return 0
","Make two numbers equal by multiplying with their prime factors minimum number of times 
 C ++ program untill the above approach ; Function to calculate total number of prime factor with their prime factor ; Iterate untill the number is even ; Reduce to half ; Iterate up to sqrt ( N ) ; Iterate untill N has factors of i ; Removing one factor of i ; Function to count the number of factors ; Find the GCD ; Find multiples left in X and Y ; Find prime factor of multiple left in X and Y ; Initialize ans ; Check if it possible to obtain X or not ; Check if it possible to obtain Y or not ; return main ans ; Driver code ; Given Input ; Function Call
",1
435,"declare certaindered_map  int, int > PrimeFactor ( int N), unordered_map  int, int > primef
untill N modulo 2 is 0, increment primef array of 2  by 1
else set primef array of 2  to 1
N / 2
untill i assign to 3 to sqrt ( N ), untill N modulo i is 0, increment primef array of i   by 1
else set primef array of i   to 1
N / 2
if N is greater than 2 set primef array of N  to 1
return primef
CountToMakeEqual assign to integer with X, Y, gcdofXY assign to __gcd ( X, Y )
create integer newX with newX assign to Y / gcdofXY
create integer newY with newY assign to X / gcdofXY
create an array of ints, ints with int value primeX
create an array of ints, ints with int value primeY
set primeX to PrimeFactor ( newX )
set primeY to PrimeFactor ( newY )
ans assign to integer with ans assign to 0
return -1 if X modulo c is not 0
increment ans by primeX array of c. first  
return -1 if Y modulo c is not 0
increment ans by primeY array of c. first  
return ans
declare integer main ( ) and integer X assign to 36
create integer Y with Y assign to 48
create integer ans with ans assign to CountToMakeEqual ( X, Y )
print ans
return 0
","Count of subsets having sum of min and max element less than K 
 C ++ program to print count of subsets S such that min ( S ) + max ( S ) < K ; Function that return the count of subset such that min ( S ) + max ( S ) < K ; Sorting the array ; ans stores total number of subsets ; add all possible subsets between i and j ; Decrease the sum ; Driver code
",0
436,"declare struct Node  integers L, R, V
print a newline
declare check with integers  int > Adj array of  , Src, N, visited array of  , color assign to int with color assign to  0
visited array of Src  assign to true
create queue  integer > q
push q. push ( Src )
untill q is not empty ( ), u assign to q. front ( )
pop assign to q. pop assign to q
create integer Col with Col assign to color array of u  
untill x : Adj array of u   ) if visited array of x   is true and color array of x   is Col, return false
else if visited array of x   is false, visit array of x   is true
push x
set color array ofx   to 1 - Col
return true
create void addEdge ( vector  Adj array of  , integer u, integer v ), push_back ( v ), create void addEdge
push_back ( u ) is a new line
declare isPossible with struct Node Arr array of  , integer N, vector  integer > Adj array of N  
untill i assign to 0 to N - 1 exclusive, continue if j assign to i + 1, j  N, L Arr array of i  . L > Arr array of j  . R, continue ;
else if Arr array of i   is Arr array of j  . V ) addEdge ( Adj, i, j )
visited assign to bool with visited assign to  false
untill i assign to 0 to N exclusive, if visited array of i   is false and Adj array of i   is greater than 0, print No
return
print Yes
declare integer main with struct Node arr assign to  5, 7, 2 , 4, 6, 1 , 1 , 5, 2 , 6, 5, 1       , 6, 5, 1       struct Node arr array of   assign to   5, 7, 2
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
declare isPossible with arr, N as arguments, returning integer
return 0
","Make given segments non 
 C ++ program untill the above approach ; Stores the details of the Segment ; Function to check whether the graph is bipartite or not ; Mark source node as visited ; Push the source vertex in queue ; Get the front of the queue ; Assign the color to the popped node ; Traverse the adjacency list of the node u ; If any node is visited & a different colors has been assigned , then return false ; Set visited array of x   ; Push the node x into the queue ; Update color of node ; If the graph is bipartite ; Function to add an edge between the nodes u and v ; Function to check if the assignment of direction can be possible to all the segments , such that they do not intersect after a long period of time ; Stores the adjacency list of the created graph ; Generate all possible pairs ; If segments do not overlap ; Otherwise , the segments overlap ; If both segments have same speed , then add an edge ; Keep the track of visited nodes ; Iterate untill all possible nodes ; Check whether graph is bipartite or not ; If the graph is bipartite ; Driver Code
",1
437,"declare struct Node  integers L, R, V
print a newline
declare check with integers  int > Adj array of  , Src, N, visited array of  , color assign to int with color assign to  0
visited array of Src  assign to true
create queue  integer > q
push q. push ( Src )
untill q is not empty ( ), u assign to q. front ( )
pop assign to q. pop assign to q
create integer Col with Col assign to color array of u  
untill x : Adj array of u   ) if visited array of x   is true and color array of x   is Col, return false
else if visited array of x   is false, visit array of x   is true
push x
set color array ofx   to 1 - Col
return true
create void addEdge ( vector  Adj array of  , integer u, integer v ), push_back ( v ), create void addEdge
push_back ( u ) is a new line
declare isPossible with struct Node Arr array of  , integer N, vector  integer > Adj array of N  
untill i assign to 0 to N - 1 exclusive, continue if j assign to i + 1, j  N, L Arr array of i  . L > Arr array of j  . R, continue ;
else if Arr array of i   is Arr array of j  . V ) addEdge ( Adj, i, j )
visited assign to bool with visited assign to  false
untill i assign to 0 to N exclusive, if visited array of i   is false and Adj array of i   is greater than 0, print No
return
print Yes
declare integer main with struct Node arr assign to  5, 7, 2 , 4, 6, 1 , 1 , 5, 2 , 6, 5, 1       , 6, 5, 1       struct Node arr array of   assign to   5, 7, 2
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
declare isPossible with arr, N as arguments, returning integer
return 0
","Cost required to make all array elements equal to 1 
 C ++ program untill the above approach ; Function to calculate the cost required to make all array elements equal to 1 ; Stores the total cost ; Traverse the array arr array of   ; If current element is 0 ; Convert 0 to 1 ; Add the cost ; Return the total cost ; Driver Code
",0
438,"declare dfs with integers temp, n, vector  integer > & sol
create void lexNumbers ( int n), vector, int > sol
dfs assign to 1, n, sol
print "" array of "" print sol array of 0  
untill i assign to 1 to size of sol exclusive, print "", "" and sol array of i  
print  
void function dfs (get int temp, n, vector, int > & sol, return if temp is greater than n)
push_back sol. push_back ( temp )
dfs assign to temp * 10, n, sol
if temp modulo 10 is not 9, dfs ( temp + 1, n, sol )
declare integer main ( ) and integer n assign to 15
create lexNumbers ( n )
return 0
","Generate all numbers up to N in Lexicographical Order 
 C ++ program untill the above approach ; Driver code
",1
439,"declare dfs with integers temp, n, vector  integer > & sol
create void lexNumbers ( int n), vector, int > sol
dfs assign to 1, n, sol
print "" array of "" print sol array of 0  
untill i assign to 1 to size of sol exclusive, print "", "" and sol array of i  
print  
void function dfs (get int temp, n, vector, int > & sol, return if temp is greater than n)
push_back sol. push_back ( temp )
dfs assign to temp * 10, n, sol
if temp modulo 10 is not 9, dfs ( temp + 1, n, sol )
declare integer main ( ) and integer n assign to 15
create lexNumbers ( n )
return 0
","Floor value Kth root of a number using Recursive Binary Search 
 C ++ program untill the above approach ; Function to calculate x raised to the power y in O ( logn ) ; Function to find the Kth root of the number N using BS ; If the range is still valid ; Find the mid - value of range ; Base Case ; Condition to check if the left search space is useless ; Driver Code ; Given N and K ; Function Call
",0
440,"minimumSwaps assign to integer with minimumSwaps assign to integer array of size array of   and n assign to integer, count assign to 0
create integer i with i assign to 0
untill i  n, if arr array of i   is not i + 1, untill arr array of i   is not i + 1, temp assign to integer with temp assign to 0
temp assign to arr array of arr array of i   - 1  
arr array of arr array of i   - 1   assign to arr array of i  
set arr array of i   to temp
increment count
increment i
return count
declare integer main ( ), integer arr array of   assign to  2, 3, 4, 1, 5  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print minimumSwaps ( arr, n )
","Minimum number of swaps required to sort an array of first N number 
 Function to find minimum swaps ; Initialise count variable ; If current element is not at the right position ; Swap current element with correct position of that element ; Increment untill next index when current element is at correct position ; Driver code ; Function to find minimum swaps
",1
441,"minimumSwaps assign to integer with minimumSwaps assign to integer array of size array of   and n assign to integer, count assign to 0
create integer i with i assign to 0
untill i  n, if arr array of i   is not i + 1, untill arr array of i   is not i + 1, temp assign to integer with temp assign to 0
temp assign to arr array of arr array of i   - 1  
arr array of arr array of i   - 1   assign to arr array of i  
set arr array of i   to temp
increment count
increment i
return count
declare integer main ( ), integer arr array of   assign to  2, 3, 4, 1, 5  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print minimumSwaps ( arr, n )
","Middle of three using minimum comparisons 
 CPP program to find middle of three distinct numbers ; Function to find the middle of three number ; x is positive if a is greater than b . x is negative if b is greater than a . ; Similar to x ; Similar to x and y . ; Checking if b is middle ( x and y both are positive ) ; Checking if c is middle ( x and z both are positive ) ; Driver Code
",0
442,"create struct Node  integer data
Node * next
Node * prev
print a newline
declare append ( struct Node * head_ref, int new_data )  struct Node * new_node assign to ( struct Node * ) malloc ( sizeof ( struct Node ) )
Node * last assign to * head_ref
new_node -> data assign to new_data
set new_node -> next to NULL
if head_ref is NULL, change new_node -> prev to NULL
* head_ref assign to new_node
return
untill last -> next is not NULL, let last be last -> next
last -> next assign to new_node
new_node -> prev assign to last
return
printList is a void function with node * node and node * last
untill node is not NULL print node -> data print "" ""
let last be node
set node to node -> next
Node * mergeList ( Node * p, Node * q )  Node * s assign to NULL
if p is NULL q is NULL, return q if p is NULL, else return p if p is NULL, else return p
if p -> data  q -> data, p -> prev assign to s
set s to p
set p to p -> next
else q -> prev assign to s
set s to q
set q to q -> next
Node * head assign to s
untill p is not NULL and q is not NULL, set p -> data  q -> data, set s -> next to p
p -> prev assign to s
set s to s -> next
set p to p -> next
else s -> next assign to q
set q -> prev to s
set s to s -> next
set q to q -> next
if p is NULL, set s -> next to q
set q -> prev to s
if q is NULL, set s -> next to p
p -> prev assign to s
return head
set Node * mergeAllList ( Node * head array of , int k ) and Node * finalList to NULL
untill i assign to 0 to k exclusive, set finalList to mergeList ( finalList, head array of i   )
return finalList
declare integer main ( ) and integer k assign to 3
Node * head array of k  
untill i assign to 0 to k exclusive, head array of i   assign to NULL
append ( & head array of 0  , 1 )
append ( & head array of 0  , 5 ) to append
append ( & head array of 0  , 9 ) to append
append ( & head array of 1  , 2 ) to append
append ( & head array of 1  , 3 ) to append
append ( & head array of 1  , 7 ) to append
append ( & head array of 1  , 12 ) to append
append ( & head array of 2  , 8 ) to append
append ( & head array of 2  , 11 ) to append
append ( & head array of 2  , 13 ) to append
append ( & head array of 2  , 18 ) to append
Node * finalList assign to mergeAllList ( head, k )
printList is a newline
return 0
","Merge K sorted Doubly Linked List in Sorted Order 
 C ++ program to merge K sorted doubly linked list in sorted order ; A linked list node ; Given a reference ( pointer to pointer ) to the head Of a DLL and an int , appends a new node at the end ; Allocate node ; Put in the data ; This new node is going to be the last node , so make next of it as NULL ; If the Linked List is empty , then make the new node as head ; Else traverse till the last node ; Change the next of last node ; Make last node as previous of new node ; Function to print the list ; Run untill loop unless node becomes null ; Function to merge two sorted doubly linked lists ; If any of the list is empty ; Comparison the data of two linked list ; Store head pointer beuntille merge the list ; Changing of pointer between Two list untill merging ; Changing of pointer between Two list untill merging ; Condition to check if any anyone list not end ; Return head pointer of merged list ; Function to merge all sorted linked list in sorted order ; Function call to merge two sorted doubly linked list at a time ; Return final sorted doubly linked list ; Driver code ; Loop to initialize all the lists to empty ; Create first doubly linked List List1 -> 1 <assign to > 5 <assign to > 9 ; Create second doubly linked List List2 -> 2 <assign to > 3 <assign to > 7 <assign to > 12 ; Create third doubly linked List List3 -> 8 <assign to > 11 <assign to > 13 <assign to > 18 ; Function call to merge all sorted doubly linked lists in sorted order ; Print final sorted list
",1
443,"create struct Node  integer data
Node * next
Node * prev
print a newline
declare append ( struct Node * head_ref, int new_data )  struct Node * new_node assign to ( struct Node * ) malloc ( sizeof ( struct Node ) )
Node * last assign to * head_ref
new_node -> data assign to new_data
set new_node -> next to NULL
if head_ref is NULL, change new_node -> prev to NULL
* head_ref assign to new_node
return
untill last -> next is not NULL, let last be last -> next
last -> next assign to new_node
new_node -> prev assign to last
return
printList is a void function with node * node and node * last
untill node is not NULL print node -> data print "" ""
let last be node
set node to node -> next
Node * mergeList ( Node * p, Node * q )  Node * s assign to NULL
if p is NULL q is NULL, return q if p is NULL, else return p if p is NULL, else return p
if p -> data  q -> data, p -> prev assign to s
set s to p
set p to p -> next
else q -> prev assign to s
set s to q
set q to q -> next
Node * head assign to s
untill p is not NULL and q is not NULL, set p -> data  q -> data, set s -> next to p
p -> prev assign to s
set s to s -> next
set p to p -> next
else s -> next assign to q
set q -> prev to s
set s to s -> next
set q to q -> next
if p is NULL, set s -> next to q
set q -> prev to s
if q is NULL, set s -> next to p
p -> prev assign to s
return head
set Node * mergeAllList ( Node * head array of , int k ) and Node * finalList to NULL
untill i assign to 0 to k exclusive, set finalList to mergeList ( finalList, head array of i   )
return finalList
declare integer main ( ) and integer k assign to 3
Node * head array of k  
untill i assign to 0 to k exclusive, head array of i   assign to NULL
append ( & head array of 0  , 1 )
append ( & head array of 0  , 5 ) to append
append ( & head array of 0  , 9 ) to append
append ( & head array of 1  , 2 ) to append
append ( & head array of 1  , 3 ) to append
append ( & head array of 1  , 7 ) to append
append ( & head array of 1  , 12 ) to append
append ( & head array of 2  , 8 ) to append
append ( & head array of 2  , 11 ) to append
append ( & head array of 2  , 13 ) to append
append ( & head array of 2  , 18 ) to append
Node * finalList assign to mergeAllList ( head, k )
printList is a newline
return 0
","Find K numbers with sum equal to N and sum of their squares maximized 
 C ++ program to find K numbers with sum equal to N and the sum of their squares maximized ; Function that prints the required K numbers ; Print 1 , K - 1 times ; Print ( N - K + 1 ) ; Driver Code
",0
444,"if i is j return i
create integer k with k assign to minIndex ( a, i + 1, j )
return i if a array of i   is less than a array of k   else return k
if index is n, return voidSelectionSort ( int a array of  , int n, int index assign to 0 )
create integer k with k assign to minIndex ( a, index, n - 1 )
if k is not index, swap a array of k   and a array of index  
print recurSelectionSort ( a, n, index + 1 )
declare integer main ( ), integer arr assign to  3, 1, 5, 2, 7, 0
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
call recurSelectionSort ( arr, n )
untill i assign to 0 to n exclusive, print arr array of i   and "" ""
print newline
return 0
","Recursive Selection Sort 
 Recursive C ++ program to sort an array using selection sort ; Return minimum index ; Find minimum of remaining elements ; Return minimum of current and remaining . ; Recursive selection sort . n is size of a array of   and index is index of starting element . ; Return when starting and size are same ; calling minimum index function untill minimum index ; Swapping when index nd minimum index are not same ; swap ; Recursively calling selection sort function ; Driver code ; Calling function ; printing sorted array
",1
445,"if i is j return i
create integer k with k assign to minIndex ( a, i + 1, j )
return i if a array of i   is less than a array of k   else return k
if index is n, return voidSelectionSort ( int a array of  , int n, int index assign to 0 )
create integer k with k assign to minIndex ( a, index, n - 1 )
if k is not index, swap a array of k   and a array of index  
print recurSelectionSort ( a, n, index + 1 )
declare integer main ( ), integer arr assign to  3, 1, 5, 2, 7, 0
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
call recurSelectionSort ( arr, n )
untill i assign to 0 to n exclusive, print arr array of i   and "" ""
print newline
return 0
","Angle between 3 given vertices in a n 
 C ++ implementation of the approach ; Function that checks whether given angle can be created using any 3 sides ; Initialize x and y ; Calculate the number of vertices between i and j , j and k ; Calculate the angle subtended at the circumference ; Angle subtended at j can be found using the fact that the sum of angles of a triangle is equal to 180 degrees ; Driver code
",0
446,"insertionSortRecursive is a void function with int arguments arr array of   and n, if n assign to 1 return
call insertionSortRecursive ( arr, n - 1 )
let last be a integer with last assign to arr array of n - 1  
create integer j with j assign to n - 2
untill j >assign to 0 and arr array ofj   > last, set arr array of j + 1   to arr array ofj  
decrement j
let arr array of j + 1   be last
printArray is a void function with int arguments arr array of   and n, print ( int i assign to 0 ; i  n ; i ++ ) print arr array of i   print "" ""
declare integer main ( ), integer arr array of   assign to  12, 11, 13, 5, 6  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
call insertionSortRecursive ( arr, n )
printArray ( arr, n )
return 0
","Recursive Insertion Sort 
 Recursive C ++ program untill insertion sort ; Recursive function to sort an array using insertion sort ; Base case ; Sort first n - 1 elements ; Insert last element at its correct position in sorted array . ; Move elements of arr array of 0. . i - 1   , that are greater than key , to one position ahead of their current position ; A utility function to print an array of size n ; Driver program to test insertion sort
",1
447,"insertionSortRecursive is a void function with int arguments arr array of   and n, if n assign to 1 return
call insertionSortRecursive ( arr, n - 1 )
let last be a integer with last assign to arr array of n - 1  
create integer j with j assign to n - 2
untill j >assign to 0 and arr array ofj   > last, set arr array of j + 1   to arr array ofj  
decrement j
let arr array of j + 1   be last
printArray is a void function with int arguments arr array of   and n, print ( int i assign to 0 ; i  n ; i ++ ) print arr array of i   print "" ""
declare integer main ( ), integer arr array of   assign to  12, 11, 13, 5, 6  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
call insertionSortRecursive ( arr, n )
printArray ( arr, n )
return 0
","Minimize consecutive removals of elements of the same type to empty given array 
 C ++ implementation of the above approach ; Function to count minimum consecutive removals of elements of the same type ; Sort the array ; Stores the maximum element present in the array ; Stores sum of the array ; Calculate sum of the array ; Driver Code ; Function call
",0
448,"if n is 1 return void bubbleSort
untill i assign to 0 to n - 1 exclusive swap arr array of i + 1  , arr array of i + 1   )
bubbleSort ( arr, n - 1 )
printArray is a void function with int arguments arr array of   and n, and untill i assign to 0 to n exclusive printf ( "" % d "", arr array of i   )
printf is a new line
declare integer main ( ), integer arr assign to  64, 34, 25, 12, 22, 11, 90
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
bubbleSort assign to arr, n
printf is a new line
printArray ( arr, n )
return 0
","Recursive Bubble Sort 
 C / C ++ program untill recursive implementation of Bubble sort ; A function to implement bubble sort ; Base case ; One pass of bubble sort . After this pass , the largest element is moved ( or bubbled ) to end . ; swap arr array of i   , arr array of i + 1   ; Largest element is fixed , recur untill remaining array ; Function to print an array ; Driver program to test above functions
",1
449,"if n is 1 return void bubbleSort
untill i assign to 0 to n - 1 exclusive swap arr array of i + 1  , arr array of i + 1   )
bubbleSort ( arr, n - 1 )
printArray is a void function with int arguments arr array of   and n, and untill i assign to 0 to n exclusive printf ( "" % d "", arr array of i   )
printf is a new line
declare integer main ( ), integer arr assign to  64, 34, 25, 12, 22, 11, 90
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
bubbleSort assign to arr, n
printf is a new line
printArray ( arr, n )
return 0
","Minimum adjacent swaps required to Sort Binary array 
  ; Driver Code
",0
450,"declare maxSumAfterPartition with integer arr array of  , n as arguments, returning integer, and integer pos
create vector  integer > neg
zero assign to integer with zero assign to 0
create integer pos_sum with pos_sum assign to 0
neg_sum assign to integer with neg_sum assign to 0
untill i assign to 0 to n exclusive, if arr array of i   > 0, push_back ( arr array of i   )
increment pos_sum by arr array of i  
else if arr array of i   is less than 0, push_back ( arr array of i   )
increment neg_sum by arr array of i  
else increment zero
ans assign to 0
sort pos. begin ( ), pos. end ( ) )
sort ( neg. begin ( ), neg. end ( ), greater  integer > ( ) ) )
if size of pos is greater than 0 and size of neg is greater than 0 then set ans to ( pos_sum - neg_sum )
else if size of pos is greater than 0 or if zero is greater than 0, set ans to ( pos_sum )
else set ans to ( pos_sum - 2 * pos array of 0   )
else if zero is greater than 0, set ans to ( -1 * neg_sum )
else set ans to neg array of 0   - neg_sum - neg array of 0   )
return ans
declare integer main ( ), integer arr array of   assign to  1, 2, 3, -5, -7
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print maxSumAfterPartition ( arr, n )
return 0
","Maximum possible difference of sum of two subsets of an array 
 Set 2 
 C ++ Program untill the above approach ; Stores the positive elements ; Stores the negative elements ; Stores the count of 0 s ; Sum of all positive numbers ; Sum of all negative numbers ; Iterate over the array ; Stores the difference ; Sort the positive numbers in ascending order ; Sort the negative numbers in decreasing order ; Case 1 : Include both positive and negative numbers ; Put all numbers in subset A and one 0 in subset B ; Put all numbers in subset A except the smallest positive number which is put in B ; Put all numbers in subset B and one 0 in subset A ; Place the largest negative number in subset A and remaining in B ; Driver code
",1
451,"declare maxSumAfterPartition with integer arr array of  , n as arguments, returning integer, and integer pos
create vector  integer > neg
zero assign to integer with zero assign to 0
create integer pos_sum with pos_sum assign to 0
neg_sum assign to integer with neg_sum assign to 0
untill i assign to 0 to n exclusive, if arr array of i   > 0, push_back ( arr array of i   )
increment pos_sum by arr array of i  
else if arr array of i   is less than 0, push_back ( arr array of i   )
increment neg_sum by arr array of i  
else increment zero
ans assign to 0
sort pos. begin ( ), pos. end ( ) )
sort ( neg. begin ( ), neg. end ( ), greater  integer > ( ) ) )
if size of pos is greater than 0 and size of neg is greater than 0 then set ans to ( pos_sum - neg_sum )
else if size of pos is greater than 0 or if zero is greater than 0, set ans to ( pos_sum )
else set ans to ( pos_sum - 2 * pos array of 0   )
else if zero is greater than 0, set ans to ( -1 * neg_sum )
else set ans to neg array of 0   - neg_sum - neg array of 0   )
return ans
declare integer main ( ), integer arr array of   assign to  1, 2, 3, -5, -7
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print maxSumAfterPartition ( arr, n )
return 0
","Count of integers of length N and value less than K such that they contain digits only from the given set 
 C ++ implementation of the approach ; Function to convert a number into vector ; Push all the digits of N from the end one by one to the vector ; If the original number was 0 ; Reverse the vector elements ; Return the required vector ; Function to return the count of B length integers which are less than C and they contain digits from set A array of   only ; Convert number to digit array ; Case 1 : No such number possible as the generated numbers will always be greater than C ; Case 2 : All integers of length B are valid as they all are less than C ; contain 0 ; Case 3 ; Update the lower array of   array such that lower array of i   stores the count of elements in A array of   which are less than i ; For first index we can 't use 0 ; Whether ( i - 1 ) digit of generated number can be equal to ( i - 1 ) digit of C ; Is digit array of i - 1   present in A ? ; Driver code
",0
452,"declare integer MaxXOR ( integer array arr size  , integer N )  integer res assign to 0
untill i assign to 0 to N exclusive, res assign to res 
 arr array of i  
return res
declare integer main ( ), integer arr array of   assign to  1, 5, 7
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print MaxXOR ( arr, N )
return 0
","Split an array into subarrays with maximum Bitwise XOR of their respective Bitwise OR values 
 C ++ program untill the above approach ; Function to find the bitwise OR of array elements ; Stores the resultant maximum value of Bitwise XOR ; Traverse the array arr array of   ; Return the maximum value res ; Driver Code
",1
453,"declare integer MaxXOR ( integer array arr size  , integer N )  integer res assign to 0
untill i assign to 0 to N exclusive, res assign to res 
 arr array of i  
return res
declare integer main ( ), integer arr array of   assign to  1, 5, 7
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print MaxXOR ( arr, N )
return 0
","Area of a Square 
 Using Side , Diagonal and Perimeter 
 C ++ program untill the above approach ; Function to find the area of a square ; Use above untillmula ; Driver Code ; Given Side of square ; Function call
",0
454,"declare countEqual with integers A array of  , B array of  , N, set first to 0
create integer second with second assign to N - 1
create integer count with count assign to 0
untill first  N and second >assign to 0 increment first
else if B array of second    A array of first  , second ; second ; second ; second ; second ; second ; second ; second ; second ; second ; second ; second ; second ; second ; second ; second ; second ; second ; second ; second ; second ; second ; second ; second ; second ; second ; second ; second ; second ; second ; second ; second ;
else increment count
increment first
a second element of second element of second element of second element of second element of second element of second element of second element
return count
declare integer main ( ) and integer array A with size   assign to  2, 4, 5, 8, 12, 13, 17, 18, 20, 22, 309, 999
declare integer array B with size 109, 99, 68, 54, 22, 19, 17, 13, 11, 5, 3 and 1 as arguments, returning integer
N assign to sizeof ( A ) / sizeof ( int )
print countEqual ( A, B, N )
return 0
","Count number of common elements between a sorted array and a reverse sorted array 
 C ++ program untill the above approach ; Function to count the number of elements common in both the arrays ; Used to traverse array A array of   and B array of   from the front and the back ; Stores the count of numbers common in both array ; If A array of first   is less than B array of second   ; Increment the value of first ; IF B array of second   is less than A array of first   ; Decrement the value of second ; A array of first   is equal to B array of second   ; Increment the value of count ; Increment the value of first ; Decrement the value of second ; Return the value of count ; Driver Code
",1
455,"declare countEqual with integers A array of  , B array of  , N, set first to 0
create integer second with second assign to N - 1
create integer count with count assign to 0
untill first  N and second >assign to 0 increment first
else if B array of second    A array of first  , second ; second ; second ; second ; second ; second ; second ; second ; second ; second ; second ; second ; second ; second ; second ; second ; second ; second ; second ; second ; second ; second ; second ; second ; second ; second ; second ; second ; second ; second ; second ; second ;
else increment count
increment first
a second element of second element of second element of second element of second element of second element of second element of second element
return count
declare integer main ( ) and integer array A with size   assign to  2, 4, 5, 8, 12, 13, 17, 18, 20, 22, 309, 999
declare integer array B with size 109, 99, 68, 54, 22, 19, 17, 13, 11, 5, 3 and 1 as arguments, returning integer
N assign to sizeof ( A ) / sizeof ( int )
print countEqual ( A, B, N )
return 0
","Check if array contains contiguous integers with duplicates allowed 
 C ++ implementation to check whether the array contains a set of contiguous integers ; Function to check whether the array contains a set of contiguous integers ; Storing elements of ' arr array of   ' in a hash table ' us ' ; as arr array of 0   is present in ' us ' ; starting with previous smaller element of arr array of 0   ; if ' curr _ ele ' is present in ' us ' ; increment count ; update 'curr_ele"" ; starting with next greater element of arr array of 0   ; if ' curr _ ele ' is present in ' us ' ; increment count ; update 'curr_ele"" ; returns true if array contains a set of contiguous integers else returns false ; Driver program to test above
",0
456,"create integer array arr with size 100005
create boolean isPalindrome with int N, temp assign to N
create integer res with res assign to 0
untill temp is not 0, set rem to temp modulo 10
res assign to res * 10 + rem
divide temp by 10
if res is N return true
else return false
sumOfDigits assign to integer N and sum assign to 0
untill N is not 0, increment sum by N modulo 10
N assign to N / 10
return sum
if n is less than or equal to 1 return false
untill i assign to 2 to n / 2 inclusive, return false
return true
if i assign to 1, i assign to 100000, if isPalindrome ( i ), sum assign to sumOfDigits ( i )
if sum is true, set arr array of i   to 1
else arr array of i   assign to 0
else arr array of i   assign to 0
untill i assign to 1 to 100000 inclusive, arr array of i   assign to arr array of i   + arr array of i - 1  
void function countNumbers (int Q array of   array of 2  , int N), precompute ( )
untill i assign to 0 to N exclusive, print ( arr array of Q array of i   array of 1     - arr array of Q array of i   array of 0   - 1   )
print newline
declare integer variables Q, Q, 9 and 101 with Q assign to  5, 9 and 1
create integer N with N assign to sizeof ( Q) / sizeof ( Q array of 0   )
countNumbers ( Q, N )
","Queries to count Palindrome Numbers from a range whose sum of digits is a Prime Number 
 C ++ program untill the above approach ; Function to check if the number N is palindrome or not ; Store the value of N ; Store the reverse of number N ; Reverse temp and store in res ; If N is the same as res , then return true ; Function to find the sum of the digits of the number N ; Stores the sum of the digits ; Add the last digit of the number N to the sum ; Remove the last digit from N ; Return the resultant sum ; Function to check if N is prime or not ; If i is 1 or 0 , then return false ; Check if i is divisible by any number in the range array of 2 , n / 2   ; If n is divisible by i ; Function to precompute all the numbers till 10 to the power 5 that are palindromic and whose sum of digits is prime numbers ; Iterate over the range 1 to 10 to the power 5 ; If i is a palindrome number ; Stores the sum of the digits in i ; If the sum of digits in i is a prime number ; Find the prefix sum of arr array of   ; Function to count all the numbers in the given ranges that are palindromic and the sum of digits is prime numbers ; Function Call to precompute all the numbers till 10 to the power 5 ; Traverse the given queries Q array of   ; Print the result untill each query ; Driver Code ; Function Call
",1
457,"create integer array arr with size 100005
create boolean isPalindrome with int N, temp assign to N
create integer res with res assign to 0
untill temp is not 0, set rem to temp modulo 10
res assign to res * 10 + rem
divide temp by 10
if res is N return true
else return false
sumOfDigits assign to integer N and sum assign to 0
untill N is not 0, increment sum by N modulo 10
N assign to N / 10
return sum
if n is less than or equal to 1 return false
untill i assign to 2 to n / 2 inclusive, return false
return true
if i assign to 1, i assign to 100000, if isPalindrome ( i ), sum assign to sumOfDigits ( i )
if sum is true, set arr array of i   to 1
else arr array of i   assign to 0
else arr array of i   assign to 0
untill i assign to 1 to 100000 inclusive, arr array of i   assign to arr array of i   + arr array of i - 1  
void function countNumbers (int Q array of   array of 2  , int N), precompute ( )
untill i assign to 0 to N exclusive, print ( arr array of Q array of i   array of 1     - arr array of Q array of i   array of 0   - 1   )
print newline
declare integer variables Q, Q, 9 and 101 with Q assign to  5, 9 and 1
create integer N with N assign to sizeof ( Q) / sizeof ( Q array of 0   )
countNumbers ( Q, N )
","Sum of all Subarrays 
 Set 1 
 Simple C ++ program to compute sum of subarray elements ; Computes sum all sub - array ; Pick starting point ; Pick ending point ; sum subarray between current starting and ending points ; driver program to test above function
",0
458,"declare integer sum assign to n, integer res assign to 0
untill n > 0, increment res by n modulo 10
divide n by 10
return res
smallestNumber is a new integer function with integer arguments n and s and return n if sum ( n ) is less than or equal to s
ans, k assign to integers with ans assign to n, k assign to 1
untill i assign to 0 to 9 exclusive, digit assign to ( ans / k ) modulo 10
create integer add with add assign to k * ( (10 - digit ) % 10 )
increment ans by add
if sum ( ans ) assign to s, break loop
k * 10
return ans
declare integer main ( ), integer N assign to 3 and S assign to 2
print smallestNumber ( N, S )
return 0
","Smallest number greater than or equal to N having sum of digits not exceeding S 
 C ++ program untill the above approach ; Function to calculate sum digits of n ; Function to find the smallest possible integer satisfying the given condition ; If the sum of digits is already smaller than S ; Initialize variables ; Finding last kth digit ; Add remaining to make digit 0 ; If sum of digits does not exceed S ; Update k ; Driver Code ; Given N and S ; Function call
",1
459,"declare integer sum assign to n, integer res assign to 0
untill n > 0, increment res by n modulo 10
divide n by 10
return res
smallestNumber is a new integer function with integer arguments n and s and return n if sum ( n ) is less than or equal to s
ans, k assign to integers with ans assign to n, k assign to 1
untill i assign to 0 to 9 exclusive, digit assign to ( ans / k ) modulo 10
create integer add with add assign to k * ( (10 - digit ) % 10 )
increment ans by add
if sum ( ans ) assign to s, break loop
k * 10
return ans
declare integer main ( ), integer N assign to 3 and S assign to 2
print smallestNumber ( N, S )
return 0
","Minimize sum of smallest elements from K subsequences of length L 
 C ++ Program to find the minimum possible sum of the smallest elements from K subsequences ; Function to find the minimum sum ; Sort the array ; Calculate sum of smallest K elements ; Return the sum ; Driver Code
",0
460,"create integer maxSubsequences ( integer arr array of  , integer n ), unordered_map, integer > m
create integer maxCount with maxCount assign to 0
create integer count
untill i assign to 0 to n exclusive, if find ( arr array of i   ) is not m. end ( ), count assign to m array of arr array of i    
if count is greater than 1, m array of arr array of i    assign to count - 1
else erase ( arr array of i   )
if arr array of i   - 1 is greater than 0, increment m array of arr array of i   - 1   by 1
else increment maxCount
if arr array of i   - 1 is greater than 0, increment m array of arr array of i   - 1   by 1
return maxCount
declare integer main ( ) and integer n assign to 5
create integer array arr with arr assign to  4, 5, 2, 1, 4
print maxSubsequences ( arr, n )
","Maximize count of Decreasing Consecutive Subsequences from an Array 
 C ++ program to implement the above approach ; Function to find the maximum number number of required subsequences ; HashMap to store number of arrows available with height of arrow as key ; Stores the maximum count of possible subsequences ; Stores the count of possible subsequences ; Check if i - th element can be part of any of the previous subsequence ; Count of subsequences possible with arr array of i   as the next element ; If more than one such subsequence exists ; Include arr array of i   in a subsequence ; Otherwise ; Increase count of subsequence possible with arr array of i   - 1 as the next element ; Start a new subsequence ; Increase count of subsequence possible with arr array of i   - 1 as the next element ; Return the answer ; Driver Code
",1
461,"create integer maxSubsequences ( integer arr array of  , integer n ), unordered_map, integer > m
create integer maxCount with maxCount assign to 0
create integer count
untill i assign to 0 to n exclusive, if find ( arr array of i   ) is not m. end ( ), count assign to m array of arr array of i    
if count is greater than 1, m array of arr array of i    assign to count - 1
else erase ( arr array of i   )
if arr array of i   - 1 is greater than 0, increment m array of arr array of i   - 1   by 1
else increment maxCount
if arr array of i   - 1 is greater than 0, increment m array of arr array of i   - 1   by 1
return maxCount
declare integer main ( ) and integer n assign to 5
create integer array arr with arr assign to  4, 5, 2, 1, 4
print maxSubsequences ( arr, n )
","Sunny Number 
 C ++ program untill the above approach ; Function check whether x is a perfect square or not ; Find floating point value of square root of x . ; If square root is an integer ; Function to check Sunny Number ; Check if ( N + 1 ) is a perfect square or not ; If ( N + 1 ) is not a perfect square ; Driver Code ; Given Number ; Function call
",0
462,"if s array of i   is ch, erase s. begin ( ) + i )
break loop
untill i assign to length of s - 1 to -1 exclusive, if s array of i   is ch, erase ( s. begin ( ) + i )
break loop
return s
declare integer main ( ) and string s assign to hello world
create character ch with ch assign to'l '
print removeOcc ( s, ch )
return 0
","Remove the first and last occurrence of a given Character from a String 
 C ++ Program to implement the above approach ; Function to remove first and last occurrence of a given character from the given string ; Traverse the given string from the beginning ; If ch is found ; Traverse the given string from the end ; If ch is found ; Driver Code
",1
463,"if s array of i   is ch, erase s. begin ( ) + i )
break loop
untill i assign to length of s - 1 to -1 exclusive, if s array of i   is ch, erase ( s. begin ( ) + i )
break loop
return s
declare integer main ( ) and string s assign to hello world
create character ch with ch assign to'l '
print removeOcc ( s, ch )
return 0
","Area of a square inscribed in a circle which is inscribed in an equilateral triangle 
 C ++ Program to find the area of the square inscribed within the circle which in turn is inscribed in an equilateral triangle ; Function to find the area of the square ; a cannot be negative ; area of the square ; Driver code
",0
464,"declare minSteps with integers N, increasing array of  , decreasing array of  , m1, m2, mini assign to INT_MAX
untill i assign to 0 to m1 exclusive, if mini > increasing array of i  , mini assign to increasing array of i  
create integer maxi with maxi assign to INT_MIN
untill i assign to 0 to m2 exclusive, if maxi is less than decreasing array of i  , maxi is equal to decreasing array of i  
minSteps assign to integer with minSteps assign to max ( maxi, N - mini )
print minSteps
declare integer main ( ) and integer N assign to 7
create integer array increasing with increasing assign to  3, 5  ;
decreasing assign to integer with decreasing assign to  6  ;
create integer m1 with m1 assign to sizeof ( increasing ) / sizeof ( increasing array of 0   )
create integer m2 with m2 assign to sizeof ( decreasing ) / sizeof ( decreasing array of 0   )
minSteps ( N, increasing, decreasing, m1, m2 )
","Minimum steps untill increasing and decreasing Array to reach either 0 or N 
 C ++ program untill the above approach ; Function that finds the minimum steps to reach either 0 or N untill given increasing and decreasing arrays ; Initialize variable to find the minimum element ; Find minimum element in increasing array of   array ; Initialize variable to find the maximum element ; Find maximum element in decreasing array of   array ; Find the minimum steps ; Print the minimum steps ; Driver code ; Given N ; Given increasing and decreasing array ; Find length of arrays increasing and decreasing ; Function call
",1
465,"declare minSteps with integers N, increasing array of  , decreasing array of  , m1, m2, mini assign to INT_MAX
untill i assign to 0 to m1 exclusive, if mini > increasing array of i  , mini assign to increasing array of i  
create integer maxi with maxi assign to INT_MIN
untill i assign to 0 to m2 exclusive, if maxi is less than decreasing array of i  , maxi is equal to decreasing array of i  
minSteps assign to integer with minSteps assign to max ( maxi, N - mini )
print minSteps
declare integer main ( ) and integer N assign to 7
create integer array increasing with increasing assign to  3, 5  ;
decreasing assign to integer with decreasing assign to  6  ;
create integer m1 with m1 assign to sizeof ( increasing ) / sizeof ( increasing array of 0   )
create integer m2 with m2 assign to sizeof ( decreasing ) / sizeof ( decreasing array of 0   )
minSteps ( N, increasing, decreasing, m1, m2 )
","Concatenate strings in any order to get Maximum Number of "" AB "" 
 C ++ implementation of above approach ; Function to find maximum number of ABs ; variable A , B , AB untill count strings that end with ' A ' but not end with ' B ' , ' B ' but does not end with ' A ' and ' B ' and ends with ' A ' respectively . ; ' AB ' is already present in string beuntille concatenate them ; count of strings that begins with ' B ' and ends with 'A ; count of strings that begins with ' B ' but does not end with ' A ' ; count of strings that ends with ' A ' but not end with ' B ' ; updating the value of ans and add extra count of ' AB ' ; Driver Code
",0
466,"solve assign to vector of integers > & P, integer n, vector of integers > arr
push_back is a new line
untill auto x : P, push_back ( x ) arr
cnt assign to integer with cnt assign to 0
untill i assign to 1 to n exclusive swap ( arr array of i  , arr array of i + 1   )
increment cnt
if arr array of n   is n, swap arr array of n - 1   and arr array of n  
increment cnt
print cnt
declare signed main ( ) and integer N assign to 9
create vector  int > P assign to  1, 2, 4, 9, 5, 8, 7, 3, 6
solve ( P, N )
return 0
","Minimum number of adjacent swaps required to convert a permutation to another permutation by given condition 
 C ++ program untill the above approach ; Function to find the minimum number of swaps ; New array to convert to 1 - based indexing ; Keeps count of swaps ; Check if it is an ' X ' position ; Corner Case ; Swap ; Print the minimum swaps ; Driver Code ; Given Number N ; Given Permutation of N numbers ; Function Call
",1
467,"solve assign to vector of integers > & P, integer n, vector of integers > arr
push_back is a new line
untill auto x : P, push_back ( x ) arr
cnt assign to integer with cnt assign to 0
untill i assign to 1 to n exclusive swap ( arr array of i  , arr array of i + 1   )
increment cnt
if arr array of n   is n, swap arr array of n - 1   and arr array of n  
increment cnt
print cnt
declare signed main ( ) and integer N assign to 9
create vector  int > P assign to  1, 2, 4, 9, 5, 8, 7, 3, 6
solve ( P, N )
return 0
","Make two numbers equal by multiplying with their prime factors minimum number of times 
 C ++ program untill the above approach ; Function to calculate total number of prime factor with their prime factor ; Iterate untill the number is even ; Reduce to half ; Iterate up to sqrt ( N ) ; Iterate untill N has factors of i ; Removing one factor of i ; Function to count the number of factors ; Find the GCD ; Find multiples left in X and Y ; Find prime factor of multiple left in X and Y ; Initialize ans ; Check if it possible to obtain X or not ; Check if it possible to obtain Y or not ; return main ans ; Driver code ; Given Input ; Function Call
",0
468,"declare SieveOfEratosthenes with integers n, unordered_set and allPrimes as arguments, returning boolean prime with n + 1 elements
set all contents of prime to true
untill p assign to 2 to n inclusive, if prime array of p   is true, increment i by n, set prime array of i   to false
untill p assign to 2 to n inclusive, insert p into allPrimes
countInterestingPrimes is a new integer function with n elements, unordered_set and integers with value allPrimes
SieveOfEratosthenes ( n, allPrimes )
set int to int > intersetingPrimes
create vector  integer > squares, quadruples
untill i assign to 1 to i * i assign to n, push_back ( i * i ) )
untill i assign to 1 to i * i * i * i * i assign to n, increment push_back ( i * i * i * i * i * i )
untill a : squares, untill b : quadruples, if count ( a + b ), insert ( a + b ) into intersetingPrimes
return size of intersetingPrimes
declare integer main ( ) and integer N assign to 10
print countInterestingPrimes ( N)
return 0
","Count of interesting primes upto N 
 C ++ program to find the number of interesting primes up to N . ; Function to find all prime numbers ; Create a boolean array "" prime array of 0 . . n   "" and initialize all entries as true . A value in prime array of i   will finally be false if i is Not a prime . ; If prime array of p   is not changed , then it is a prime ; Update all multiples of p greater than or equal to the square of it ; Store all prime numbers ; Function to check if a number is perfect square or not ; To store all primes ; To store all interseting primes ; Store all perfect squares ; Store all perfect quadruples ; Store all interseting primes ; Return count of interseting primes ; Driver code
",1
469,"declare SieveOfEratosthenes with integers n, unordered_set and allPrimes as arguments, returning boolean prime with n + 1 elements
set all contents of prime to true
untill p assign to 2 to n inclusive, if prime array of p   is true, increment i by n, set prime array of i   to false
untill p assign to 2 to n inclusive, insert p into allPrimes
countInterestingPrimes is a new integer function with n elements, unordered_set and integers with value allPrimes
SieveOfEratosthenes ( n, allPrimes )
set int to int > intersetingPrimes
create vector  integer > squares, quadruples
untill i assign to 1 to i * i assign to n, push_back ( i * i ) )
untill i assign to 1 to i * i * i * i * i assign to n, increment push_back ( i * i * i * i * i * i )
untill a : squares, untill b : quadruples, if count ( a + b ), insert ( a + b ) into intersetingPrimes
return size of intersetingPrimes
declare integer main ( ) and integer N assign to 10
print countInterestingPrimes ( N)
return 0
","Smallest length of number divisible by K untillmed by using D only 
 C ++ program untill the above approach ; Function to untillm the smallest number possible ; Array to mark the remainders counted already ; Iterate over the range ; If that remainder is already found , return - 1 ; Driver Code
",0
470,"create boolean result with result assign to true
if arr array of 1   > arr array of 0   and arr array of 1   > arr array of 2  , if integer i assign to 1 ; i  n - 1 ; i +assign to 2, if arr array of i   > arr array of i - 1   and arr array of i + 1  , result assign to true
else set result to false
break loop
if result is true and n modulo 2 is 0, if arr array of n - 1   is less than or equal to arr array of n - 2  , result is false
else if arr array of 1    arr array of 0   && arr array of 1    arr array of 2  , untill i assign to 1 ; i  n - 1 ; i +assign to 2, if arr array of i    arr array of i - 1   && arr array of i + 1  , result assign to true
else set result to false
break loop
if result is true and n modulo 2 is 0, if arr array of n - 1   >assign to arr array of n - 2  , result assign to false
return result
declare integer main ( ), integer arr assign to  1, 3, 2, 4  ; declare integer array arr assign to  1, 3, 2, 4
n assign to sizeof ( arr ) / sizeof ( int )
if isWaveArray ( arr, n) is true, print YES and a new line
else print NO
return 0
","Check if an array is Wave Array 
 CPP code to check if the array is wave array ; Function to check if array is wave array arr : input array n : size of array ; Check the wave untillm * If arr array of 1   is greater than left and right * Same pattern will be followed by whole * elements , else reverse pattern * will be followed by array elements ; Check untill last element ; Check untill last element ; Driver Code ; Array
",1
471,"create boolean result with result assign to true
if arr array of 1   > arr array of 0   and arr array of 1   > arr array of 2  , if integer i assign to 1 ; i  n - 1 ; i +assign to 2, if arr array of i   > arr array of i - 1   and arr array of i + 1  , result assign to true
else set result to false
break loop
if result is true and n modulo 2 is 0, if arr array of n - 1   is less than or equal to arr array of n - 2  , result is false
else if arr array of 1    arr array of 0   && arr array of 1    arr array of 2  , untill i assign to 1 ; i  n - 1 ; i +assign to 2, if arr array of i    arr array of i - 1   && arr array of i + 1  , result assign to true
else set result to false
break loop
if result is true and n modulo 2 is 0, if arr array of n - 1   >assign to arr array of n - 2  , result assign to false
return result
declare integer main ( ), integer arr assign to  1, 3, 2, 4  ; declare integer array arr assign to  1, 3, 2, 4
n assign to sizeof ( arr ) / sizeof ( int )
if isWaveArray ( arr, n) is true, print YES and a new line
else print NO
return 0
","Gold Mine Problem 
 C ++ program to solve Gold Mine problem ; Returns maximum amount of gold that can be collected when journey started from first column and moves allowed are right , right - up and right - down ; Create a table untill storing intermediate results and initialize all cells to 0. The first row of goldMineTable gives the maximum gold that the miner can collect when starts that row ; Gold collected on going to the cell on the right ( -> ) ; Gold collected on going to the cell to right up ( / ) ; Gold collected on going to the cell to right down ( \ ) ; Max gold collected from taking either of the above 3 paths ; The max amount of gold collected will be the max value in first column of all rows ; Driver Code
",0
472,"declare countPossiblities with integer arr array of  , integer n, and lastOccur array of 100000   as arguments
untill i assign to 0 to n exclusive, let lastOccur array of i   be -1
dp assign to int array of size n + 1
set dp array of 0   to 1
untill i assign to 1 to n inclusive, curEle assign to arr array of i - 1  
dp array of i   assign to dp array of i - 1  
if lastOccur array of curEle  is not -1 and lastOccur array of curEle  is less than i - 1 then increment dp array of i   by dp array of lastOccur array of curEle    
let lastOccur array of curEle  be i
print dp array of n   print newline
declare integer main ( ), integer arr array of   assign to  1, 2, 1, 2, 2, 2  ;
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
declare countPossiblities ( arr, N )
return 0
","Count distinct sequences obtained by replacing all elements of subarrays having equal first and last elements with the first element any number of times 
 C ++ program untill the above approach ; Function to count number of sequences satisfying the given criteria ; Stores the index of the last occurrence of the element ; Initialize an array to store the number of different sequences that are possible of length i ; Base Case ; If no operation is applied on ith element ; If operation is applied on ith element ; Update the last occurrence of curEle ; Finally , print the answer ; Driver Code
",1
473,"declare countPossiblities with integer arr array of  , integer n, and lastOccur array of 100000   as arguments
untill i assign to 0 to n exclusive, let lastOccur array of i   be -1
dp assign to int array of size n + 1
set dp array of 0   to 1
untill i assign to 1 to n inclusive, curEle assign to arr array of i - 1  
dp array of i   assign to dp array of i - 1  
if lastOccur array of curEle  is not -1 and lastOccur array of curEle  is less than i - 1 then increment dp array of i   by dp array of lastOccur array of curEle    
let lastOccur array of curEle  be i
print dp array of n   print newline
declare integer main ( ), integer arr array of   assign to  1, 2, 1, 2, 2, 2  ;
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
declare countPossiblities ( arr, N )
return 0
","Find the smallest missing number 
 C ++ program to find the smallest elements missing in a sorted array . ; function that returns smallest elements missing in a sorted array . ; Left half has all elements from 0 to mid ; Driver code
",0
474,"create void maxSum ( vector  vector  arr, int n, int m ) vector  vector  int > > dp ( n )
untill i assign to 0 to 2 exclusive, dp array of i   assign to vector  int > (m )
untill j assign to 0 to m exclusive, set dp array of i   array of j   to 0
dp array of0  array ofm - 1   assign to arr array of0  array ofm - 1  
dp array of 1   array of m - 1   assign to arr array of 1   array of m - 1  
untill j assign to m - 2 to 0 inclusive, set dp array of i   array of j   + dp array of 0   array of j + 1   and arr array of i   array of j   + dp array of 0   array of j + 2   )
else dp array of i   array of j   assign to max ( arr array of i   array of j   + dp array of 1   array of j + 1  , arr array of i   array of j   + dp array of 1   array of j + 2   )
print max ( dp array of 0   array of 0  , dp array of 1   array of 0   )
declare integer main ( ), vector, vector, arr assign to   1, 50, 21, 5 , 2, 10, 10, 5
create integer N with N assign to arr array of 0  . size ( )
maxSum assign to arr, 2, N
return 0
","Maximum sum possible from given Matrix by peruntillming given operations 
 C ++ program untill the above approach ; Function to print the maximum sum ; Dp table ; Initializing dp array with 0 s ; Base case ; Traverse each column ; Update answer untill both rows ; Print the maximum sum ; Driver Code ; Given array ; Number of Columns ; Function calls
",1
475,"create void maxSum ( vector  vector  arr, int n, int m ) vector  vector  int > > dp ( n )
untill i assign to 0 to 2 exclusive, dp array of i   assign to vector  int > (m )
untill j assign to 0 to m exclusive, set dp array of i   array of j   to 0
dp array of0  array ofm - 1   assign to arr array of0  array ofm - 1  
dp array of 1   array of m - 1   assign to arr array of 1   array of m - 1  
untill j assign to m - 2 to 0 inclusive, set dp array of i   array of j   + dp array of 0   array of j + 1   and arr array of i   array of j   + dp array of 0   array of j + 2   )
else dp array of i   array of j   assign to max ( arr array of i   array of j   + dp array of 1   array of j + 1  , arr array of i   array of j   + dp array of 1   array of j + 2   )
print max ( dp array of 0   array of 0  , dp array of 1   array of 0   )
declare integer main ( ), vector, vector, arr assign to   1, 50, 21, 5 , 2, 10, 10, 5
create integer N with N assign to arr array of 0  . size ( )
maxSum assign to arr, 2, N
return 0
","K 'th Largest element in BST using constant extra space 
 CPP code untill finding K - th largest Node using O ( 1 ) extra memory and reverse Morris traversal . ; Node structure ; helper function to create a new Node ; count variable to keep count of visited Nodes ; if right child is NULL ; first increment count and check if count assign to k ; otherwise move to the left child ; find inorder successor of current Node ; set left child of successor to the current Node ; move current to its right ; restoring the tree back to original binary search tree removing threaded links ; move current to its left child ; Constructed binary tree is 4 / \ 2 7 / \ / \ 1 3 6 10
",0
476,"declare void maxSum ( vector  vector  arr, integer n )  integers r1 assign to 0, r2 assign to 0
untill i assign to 0 to n exclusive, temp assign to r1
set r1 to max of r1 and r2 + arr array of 0   array of i  
set r2 to max of r2 and temp + arr array of 1   array of i  
print max ( r1, r2 )
declare integer main ( ), vector, vector, arr assign to   1, 50, 21, 5 , 2, 10, 10, 5
create integer n with n assign to arr array of 0  . size ( )
maxSum assign to arr, n
return 0
","Maximum sum possible from given Matrix by peruntillming given operations 
 C ++ code untill the above approach ; Function to print the maximum sum possible by selecting at most one element from each column such that no consecutive pairs are selected from a single row ; Initialize variables ; Traverse each column ; Print answer ; Driver Code ; Numberof columns
",1
477,"declare void maxSum ( vector  vector  arr, integer n )  integers r1 assign to 0, r2 assign to 0
untill i assign to 0 to n exclusive, temp assign to r1
set r1 to max of r1 and r2 + arr array of 0   array of i  
set r2 to max of r2 and temp + arr array of 1   array of i  
print max ( r1, r2 )
declare integer main ( ), vector, vector, arr assign to   1, 50, 21, 5 , 2, 10, 10, 5
create integer n with n assign to arr array of 0  . size ( )
maxSum assign to arr, n
return 0
","Sentence Case of a given Camel cased string 
 C ++ implementation of the approach ; Function to return the original string after converting it back from camelCase ; Print the first character as it is ; Traverse the rest of the characters one by one ; If current character is uppercase print space followed by the current character in lowercase ; Else print the current character ; Driver code
",0
478,"create integer mod with mod assign to 1e9 + 7
create constant integer mx with mx assign to 1e6
declare integer function fact with name mx + 1
void Calculate_factorial ( )  fact array of 0   assign to 1
untill i assign to 1 to mx inclusive, set fact array of i   to i * fact array of i - 1  
set fact array of i   to fact % mod
res assign to int with res assign to 1
untill b is not a b modulo 2 set res to res * a
res assign to res modulo mod
set a to a * a
a assign to a modulo mod
divide b by 2
return res
void function countPermutations ( int n) and Calculate_factorial ( int )
create integer uni_modal with uni_modal assign to UniModal_per ( 2, n - 1 )
nonuni_modal assign to fact array of n   - uni_modal
print uni_modal, "" "" and nonuni_modal
return
declare integer main ( ) and integer N assign to 4
countPermutations ( N)
return 0
","Count unimodal and non 
 C ++ program untill the above approach ; Function to calculate the factorials up to a number ; Calculate the factorial ; Function to find power ( a , b ) ; Iterate until b exists ; If b is divisible by 2 ; Decrease the value of b ; Return the answer ; Function that counts the unimodal and non - unimodal permutations of a given integer N ; Function Call untill finding factorials up to N ; Function to count unimodal permutations ; Non - unimodal permutation is N ! - unimodal permutations ; Driver Code ; Given Number N ; Function Call
",1
479,"create integer mod with mod assign to 1e9 + 7
create constant integer mx with mx assign to 1e6
declare integer function fact with name mx + 1
void Calculate_factorial ( )  fact array of 0   assign to 1
untill i assign to 1 to mx inclusive, set fact array of i   to i * fact array of i - 1  
set fact array of i   to fact % mod
res assign to int with res assign to 1
untill b is not a b modulo 2 set res to res * a
res assign to res modulo mod
set a to a * a
a assign to a modulo mod
divide b by 2
return res
void function countPermutations ( int n) and Calculate_factorial ( int )
create integer uni_modal with uni_modal assign to UniModal_per ( 2, n - 1 )
nonuni_modal assign to fact array of n   - uni_modal
print uni_modal, "" "" and nonuni_modal
return
declare integer main ( ) and integer N assign to 4
countPermutations ( N)
return 0
","Sort prime numbers of an array in descending order 
 C ++ implementation of the approach ; false here indicates that it is not prime ; If prime array of p   is not changed , then it is a prime ; Update all multiples of p , set them to non - prime ; Function that sorts all the prime numbers from the array in descending ; this vector will contain prime numbers to sort ; if the element is prime ; update the array elements ; Driver code ; print the results .
",0
480,"declare longestSubseq with string s, length, integers, integers ones assign to length + 1, zeroes assign to length + 1, integer array of integers
set all contents of ones to 0
set all contents of zeroes to 0
untill i assign to 0 to length exclusive, if s array of i   is '1', let ones array of i + 1   be ones array of i   + 1
zeroes array of i + 1   assign to zeroes array of i  
else set zeroes array of i + 1   to zeroes array of i   + 1
ones array of i + 1   assign to ones array of i  
let answer be a integer with answer assign to INT_MIN
create integer x with x assign to 0
untill i assign to 0 to length inclusive, increment x by ones array of i  
increment x by ( zeroes array ofj  - zeroes array of i   )
increment x by ones array of length   - ones array ofj  
set answer to max of answer and x
set x to 0
print answer
declare integer main ( ) and string s assign to ""10010010111100101""
create integer length with length assign to length of s
let longestSubseq be a function that accepts s, length
return 0
","Longest subsequence possible that starts and ends with 1 and filled with 0 in the middle 
 C ++ Program to find the longest subsequence possible that starts and ends with 1 and filled with 0 in the middle ; Prefix array to store the occurences of '1' and '0' ; Initialise prefix arrays with 0 ; Iterate over the length of the string ; If current character is '1' ; If current character is '0' ; Add '1' available untill the first string ; Add '0' available untill the second string ; Add '1' available untill the third string ; Update answer ; Print the final result ; Driver Code
",1
481,"declare longestSubseq with string s, length, integers, integers ones assign to length + 1, zeroes assign to length + 1, integer array of integers
set all contents of ones to 0
set all contents of zeroes to 0
untill i assign to 0 to length exclusive, if s array of i   is '1', let ones array of i + 1   be ones array of i   + 1
zeroes array of i + 1   assign to zeroes array of i  
else set zeroes array of i + 1   to zeroes array of i   + 1
ones array of i + 1   assign to ones array of i  
let answer be a integer with answer assign to INT_MIN
create integer x with x assign to 0
untill i assign to 0 to length inclusive, increment x by ones array of i  
increment x by ( zeroes array ofj  - zeroes array of i   )
increment x by ones array of length   - ones array ofj  
set answer to max of answer and x
set x to 0
print answer
declare integer main ( ) and string s assign to ""10010010111100101""
create integer length with length assign to length of s
let longestSubseq be a function that accepts s, length
return 0
","Coin Change 
 DP 
 Dynamic Programming C ++ implementation of Coin Change problem ; table array of i   will be storing the number of solutions untill value i . We need n + 1 rows as the table is constructed in bottom up manner using the base case ( n assign to 0 ) ; Base case ( If given value is 0 ) ; Pick all coins one by one and update the table array of   values after the index greater than or equal to the value of the picked coin
",0
482,"create constant integer MAX with MAX assign to 100
untill q assign to 0 to Q exclusive, let i be q_i array of q  , R, C, q_j, K, Q, q, q, i be a void integer with largestSquare assign to q_i array of q  , int q, int q, int q, int q, int q, int q, in
create integer j with j assign to q_j array of q  
min_dist assign to integer with min_dist assign to min ( min ( i, j ), min ( R - i - 1, C - j - 1) )
ans assign to integer with ans assign to -1
untill k assign to 0 to min_dist inclusive, count assign to 0
untill row assign to i - k to i + k inclusive, increment count by matrix array of row   array of col  
if count is greater than K, break loop
set ans to 2 * k + 1
print ans and "" STRNEWLINE ""
declare integer main with MAX assign to   1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
declare integers K assign to 9 and Q assign to 1
q_i assign to integer with q_i assign to  1  ;
create integer q_j with q_j assign to  2
largestSquare ( matrix, 4, 5, q_i, q_j, K, Q )
return 0
","Largest Square in a Binary Matrix with at most K 1 s untill multiple Queries 
 C ++ implementation to find the largest square in the matrix such that it contains atmost K 1 's ; Function to calculate the largest square with atmost K 1 s untill Q queries ; Loop to solve untill each query ; Traversing the each sub square and counting total ; Breaks when exceeds the maximum count ; Driver Code
",1
483,"create constant integer MAX with MAX assign to 100
untill q assign to 0 to Q exclusive, let i be q_i array of q  , R, C, q_j, K, Q, q, q, i be a void integer with largestSquare assign to q_i array of q  , int q, int q, int q, int q, int q, int q, in
create integer j with j assign to q_j array of q  
min_dist assign to integer with min_dist assign to min ( min ( i, j ), min ( R - i - 1, C - j - 1) )
ans assign to integer with ans assign to -1
untill k assign to 0 to min_dist inclusive, count assign to 0
untill row assign to i - k to i + k inclusive, increment count by matrix array of row   array of col  
if count is greater than K, break loop
set ans to 2 * k + 1
print ans and "" STRNEWLINE ""
declare integer main with MAX assign to   1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
declare integers K assign to 9 and Q assign to 1
q_i assign to integer with q_i assign to  1  ;
create integer q_j with q_j assign to  2
largestSquare ( matrix, 4, 5, q_i, q_j, K, Q )
return 0
","Matrix Chain Multiplication 
 DP 
 C ++ program using memoization ; Function untill matrix chain multiplication ; Driver Code
",0
484,"create constant integer MAX with MAX assign to 100
declare largestSquare with integers matrix array of   array of MAX , R, C, q_j array of  , K, Q as arguments, returning integer, with countDP array of R  array of C  as arguments
set all contents of countDP to 0
set countDP array of 0   array of 0   to matrix array of 0   array of 0  
untill i assign to 1 to R exclusive, countDP array of i   array of 0   assign to countDP array of i - 1   array of 0   + matrix array of i   array of 0  
untill j assign to 1 to C exclusive, countDP array of 0   array of j   assign to countDP array of 0   array of j - 1   + matrix array of 0   array of j  
untill i assign to 1 to R exclusive, set countDP array of i   array of j   assign to matrix array of i   array of j   + countDP array of i - 1   array of j   + countDP array of i - 1   - countDP array of i - 1   array of j - 1   array of j - 1  
untill q assign to 0 to Q exclusive, i assign to q_i array ofq 
create integer j with j assign to q_j array of q  
min_dist assign to integer with min_dist assign to min ( min ( i, j ), min ( R - i - 1, C - j - 1) )
ans assign to integer with ans assign to -1
untill k assign to 0 to min_dist inclusive, x1 assign to i - k, x2 assign to i + k
create integers y1, y2, with y1 assign to j - k, y2 assign to j + k
count assign to integer with countDP assign to x2   array of y2  
if x1 > 0, decrease count by countDP array of x1 - 1   array of y2  
if y1 > 0, decrease count by countDP array of x2  array of y1 - 1  
if x1 > 0 and y1 > 0, increment count by countDP array of x1 - 1   array of y1 - 1  
if count is greater than K, break loop
set ans to 2 * k + 1
print ans and "" STRNEWLINE ""
declare integer main with MAX assign to   1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
declare integers K assign to 9 and Q assign to 1
q_i assign to integer with q_i assign to  1  ;
create integer q_j with q_j assign to  2
largestSquare ( matrix, 4, 5, q_i, q_j, K, Q )
return 0
","Largest Square in a Binary Matrix with at most K 1 s untill multiple Queries 
 C ++ implementation to find the largest square in the matrix such that it contains atmost K 1 's ; Function to find the largest square in the matrix such that it contains atmost K 1 's ; Precomputing the countDP prefix sum of the matrix ; Loop to solve Queries ; Calculating the maximum possible distance of the centre from edge ; Calculating the number of 1 s in the submatrix ; Driver Code
",1
485,"create constant integer MAX with MAX assign to 100
declare largestSquare with integers matrix array of   array of MAX , R, C, q_j array of  , K, Q as arguments, returning integer, with countDP array of R  array of C  as arguments
set all contents of countDP to 0
set countDP array of 0   array of 0   to matrix array of 0   array of 0  
untill i assign to 1 to R exclusive, countDP array of i   array of 0   assign to countDP array of i - 1   array of 0   + matrix array of i   array of 0  
untill j assign to 1 to C exclusive, countDP array of 0   array of j   assign to countDP array of 0   array of j - 1   + matrix array of 0   array of j  
untill i assign to 1 to R exclusive, set countDP array of i   array of j   assign to matrix array of i   array of j   + countDP array of i - 1   array of j   + countDP array of i - 1   - countDP array of i - 1   array of j - 1   array of j - 1  
untill q assign to 0 to Q exclusive, i assign to q_i array ofq 
create integer j with j assign to q_j array of q  
min_dist assign to integer with min_dist assign to min ( min ( i, j ), min ( R - i - 1, C - j - 1) )
ans assign to integer with ans assign to -1
untill k assign to 0 to min_dist inclusive, x1 assign to i - k, x2 assign to i + k
create integers y1, y2, with y1 assign to j - k, y2 assign to j + k
count assign to integer with countDP assign to x2   array of y2  
if x1 > 0, decrease count by countDP array of x1 - 1   array of y2  
if y1 > 0, decrease count by countDP array of x2  array of y1 - 1  
if x1 > 0 and y1 > 0, increment count by countDP array of x1 - 1   array of y1 - 1  
if count is greater than K, break loop
set ans to 2 * k + 1
print ans and "" STRNEWLINE ""
declare integer main with MAX assign to   1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
declare integers K assign to 9 and Q assign to 1
q_i assign to integer with q_i assign to  1  ;
create integer q_j with q_j assign to  2
largestSquare ( matrix, 4, 5, q_i, q_j, K, Q )
return 0
","Find ( a to the power b ) % m where ' a ' is very large 
 C ++ program to find ( a to the power b ) mod m untill a large ' a ' ; utility function to calculate a % m ; ( s array of i   - '0' ) gives the digit value and untillm the number ; Returns find ( a to the power b ) % m ; Find a % m ; now multiply ans by b - 1 times and take mod with m ; Driver program to run the case
",0
486,"declare integer variable MinCost with integer arr, integer n as arguments, returning integer dp, sum, returning integer n + 5 and returning integer n + 5
set all contents of sum to 0
untill i assign to 0 to n exclusive, k assign to arr array of i  
untill j assign to i to n exclusive, if i is j, sum array of i   array of j   assign to k
else  k + arr array ofj  
set sum array of i   array of j   to k
untill i assign to n - 1 to 0 inclusive, set dp array of i   array of j   to INT_MAX
if i is j, set dp array of i   array of j   to 0
else  untill k assign to i to j exclusive, set dp array of i   array of j   to min ( dp array of i   array of j  , dp array of i   array of k   + dp array of k + 1   array of j   + sum array of i   array of j   ) )
return dp array of 0   array of n - 1  
declare integer main ( ), integer arr array of   assign to  7, 6, 8, 6, 1, 1 , 1
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print MinCost ( arr, n )
return 0
","N consecutive ropes problem 
 C ++ implementation of the approach ; Function to return the minimum cost to connect the given ropes ; dp array of i   array of j   assign to minimum cost in range ( i , j ) sum array of i   array of j   assign to sum of range ( i , j ) ; Initializing the sum table ; Computing minimum cost untill all the possible interval ( i , j ) Left range ; Right range ; No cost untill a single rope ; Driver code
",1
487,"declare integer variable MinCost with integer arr, integer n as arguments, returning integer dp, sum, returning integer n + 5 and returning integer n + 5
set all contents of sum to 0
untill i assign to 0 to n exclusive, k assign to arr array of i  
untill j assign to i to n exclusive, if i is j, sum array of i   array of j   assign to k
else  k + arr array ofj  
set sum array of i   array of j   to k
untill i assign to n - 1 to 0 inclusive, set dp array of i   array of j   to INT_MAX
if i is j, set dp array of i   array of j   to 0
else  untill k assign to i to j exclusive, set dp array of i   array of j   to min ( dp array of i   array of j  , dp array of i   array of k   + dp array of k + 1   array of j   + sum array of i   array of j   ) )
return dp array of 0   array of n - 1  
declare integer main ( ), integer arr array of   assign to  7, 6, 8, 6, 1, 1 , 1
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print MinCost ( arr, n )
return 0
","Program to find the sum of a Series ( 1 * 1 ) + ( 2 * 2 ) + ( 3 * 3 ) + ( 4 * 4 ) + ( 5 * 5 ) + ... + ( n * n ) 
 CPP program to calculate the following series ; Function to calculate the following series ; Driver Code
",0
488,"f assign to integer with i, state, A assign to integer, dp assign to integer array of size   array of 3   and N assign to integer, return 0 if i >assign to N
else if dp array of i   array of state  is not -1, return dp array of i   array of state 
else if i is N - 1, dp array of i   array of state   assign to 1
else if state assign to 1 and A array of i   > A array of i + 1  , dp array of i   array of state   assign to 1
else if state assign to 2 and A array of i    A array of i + 1  , dp array of i   array of state   assign to 1
else if state assign to 1 and A array of i   assign to A array of i + 1  , dp array of i   array of state   assign to 1 + f ( i + 1, 2, A, dp, N )
else if state assign to 2 and A array of i   >assign to A array of i + 1  , dp array of i   array of state   assign to 1 + f ( i + 1, 1, A, dp, N )
return dp array of i  array of state 
create int maxLenSeq (int A array of  , int N), int i, tmp, y, ans
create integer dp with size 1000 by 3
set all contents of dp to -1
untill i assign to 0 to N exclusive, set tmp to f ( i, 1, A, dp, N )
set tmp to f ( i, 2, A, dp, N )
set ans to -1
untill i assign to 0 to N exclusive, set y to dp array of i   array of 1  
if i + y >assign to N, set ans to max ( ans, dp array of i   array of 1   + 1)
else if y modulo 2 is 0 set ans to max ( ans, dp array of i   array of 1   + 1 + dp array of i + y   array of 2   )
else if y modulo 2 is 1 then set ans to max ( ans, dp array of i   array of 1   + 1 + dp array of i + y   array of 1   )
return ans
declare integer main ( ), integer A assign to  1, 10, 3, 20, 25, 24  ; declare integer array A assign to  1, 10, 3, 3, 20, 25, 24
n assign to sizeof ( A ) / sizeof ( int )
print maxLenSeq ( A, n )
return 0
","Length of the longest subsegment which is UpDown after inserting atmost one integer 
 C ++ implementation of the approach ; Function to recursively fill the dp array ; If f ( i , state ) is already calculated then return the value ; Calculate f ( i , state ) according to the recurrence relation and store in dp array of   array of   ; Function that calls the resucrsive function to fill the dp array and then returns the result ; dp array of   array of   array untill storing result of f ( i , 1 ) and f ( 1 , 2 ) ; Populating the array dp array of   with - 1 ; Make sure that longest UD and DU sequence starting at each index is calculated ; Assume the answer to be - 1 This value will only increase ; y is the length of the longest UD sequence starting at i ; If length is even then add an integer and then a DU sequence starting at i + y ; If length is odd then add an integer and then a UD sequence starting at i + y ; Driver code
",1
489,"f assign to integer with i, state, A assign to integer, dp assign to integer array of size   array of 3   and N assign to integer, return 0 if i >assign to N
else if dp array of i   array of state  is not -1, return dp array of i   array of state 
else if i is N - 1, dp array of i   array of state   assign to 1
else if state assign to 1 and A array of i   > A array of i + 1  , dp array of i   array of state   assign to 1
else if state assign to 2 and A array of i    A array of i + 1  , dp array of i   array of state   assign to 1
else if state assign to 1 and A array of i   assign to A array of i + 1  , dp array of i   array of state   assign to 1 + f ( i + 1, 2, A, dp, N )
else if state assign to 2 and A array of i   >assign to A array of i + 1  , dp array of i   array of state   assign to 1 + f ( i + 1, 1, A, dp, N )
return dp array of i  array of state 
create int maxLenSeq (int A array of  , int N), int i, tmp, y, ans
create integer dp with size 1000 by 3
set all contents of dp to -1
untill i assign to 0 to N exclusive, set tmp to f ( i, 1, A, dp, N )
set tmp to f ( i, 2, A, dp, N )
set ans to -1
untill i assign to 0 to N exclusive, set y to dp array of i   array of 1  
if i + y >assign to N, set ans to max ( ans, dp array of i   array of 1   + 1)
else if y modulo 2 is 0 set ans to max ( ans, dp array of i   array of 1   + 1 + dp array of i + y   array of 2   )
else if y modulo 2 is 1 then set ans to max ( ans, dp array of i   array of 1   + 1 + dp array of i + y   array of 1   )
return ans
declare integer main ( ), integer A assign to  1, 10, 3, 20, 25, 24  ; declare integer array A assign to  1, 10, 3, 3, 20, 25, 24
n assign to sizeof ( A ) / sizeof ( int )
print maxLenSeq ( A, n )
return 0
","Subtract two numbers without using arithmetic operators 
 CPP Program to subtract two Number without using arithmetic operator Recursive implementation . ; Driver program
",0
490,"declare integer MaxGCD with integers a array of  , n, Prefix array of n + 2  
create integer Suffix array of n + 2  
set Prefix array of 1   to a array of 0  
untill i assign to 2 to n inclusive, set Prefix array of i   to __gcd ( Prefix array of i - 1  , a array of i - 1   )
Suffix array of n   assign to a array of n - 1  
untill i assign to n - 1 to 1 inclusive, set Suffix array of i   to __gcd ( Suffix array of i + 1  , a array of i - 1   )
ans assign to integer with ans assign to max ( Suffix array of 2 , Prefix array of n - 1   )
untill i assign to 2 to n exclusive, set ans to max ( ans, __gcd ( Prefix array of i - 1  , Suffix array of i + 1   ) )
return ans
declare integer main ( ), integer array a with size   assign to  14, 17, 28, 70
create integer n with n assign to sizeof ( a ) / sizeof ( a array of 0   )
print MaxGCD ( a, n )
return 0
","Remove an element to maximize the GCD of the given array 
 C ++ implementation of the above approach ; Function to return the maximized gcd after removing a single element from the given array ; Prefix and Suffix arrays ; Single state dynamic programming relation untill storing gcd of first i elements from the left in Prefix array of i   ; Initializing Suffix array ; Single state dynamic programming relation untill storing gcd of all the elements having greater than or equal to i in Suffix array of i   ; If first or last element of the array has to be removed ; If any other element is replaced ; Return the maximized gcd ; Driver code
",1
491,"declare integer MaxGCD with integers a array of  , n, Prefix array of n + 2  
create integer Suffix array of n + 2  
set Prefix array of 1   to a array of 0  
untill i assign to 2 to n inclusive, set Prefix array of i   to __gcd ( Prefix array of i - 1  , a array of i - 1   )
Suffix array of n   assign to a array of n - 1  
untill i assign to n - 1 to 1 inclusive, set Suffix array of i   to __gcd ( Suffix array of i + 1  , a array of i - 1   )
ans assign to integer with ans assign to max ( Suffix array of 2 , Prefix array of n - 1   )
untill i assign to 2 to n exclusive, set ans to max ( ans, __gcd ( Prefix array of i - 1  , Suffix array of i + 1   ) )
return ans
declare integer main ( ), integer array a with size   assign to  14, 17, 28, 70
create integer n with n assign to sizeof ( a ) / sizeof ( a array of 0   )
print MaxGCD ( a, n )
return 0
","Queries to find longest subsequence having no similar adjacent elements with updates 
 C ++ program untill the above approach ; Traverse the array arr array of   ; If previous element is not same as current element ; Traverse the queries ; Replace element at index x with y ; Recalculate untill index x ; Subtract contribution of element at index x ; Add contribution of y ; Recalculate untill index x + 1 ; Subtract contribution of element at index x + 1 ; Adds contribution of y ; Replace the element ; Driver Code ; Function Call
",0
492,"dp assign to left 4 int array of size left   array of right  
if flips is greater than k, return -1e9
if ind is n return 0
if dp array of ind  array of flips  is not -1, return dp array of ind  array of flips 
ans assign to integer with ans assign to 0
ans assign to max ( 0, a array of ind   + findSubarraySum ( ind + 1, flips, n, a, k ) )
ans assign to max ( ans, - a array of ind   + findSubarraySum ( ind + 1, flips + 1, n, a, k ) )
return dp array of ind  array of flips  assign to ans
declare findMaxSubarraySum with integers a array of  , n, k, memset ( dp, -1, sizeof ( dp ) ) as arguments, returning integer
ans assign to integer with ans assign to -1e9
untill i assign to 0 to n exclusive, set ans to max ( ans, findSubarraySum ( i, 0, n, a, k ) )
if ans is 0 and k is 0, return * max_element ( a, a + n )
return ans
declare integer main ( ), integer array a assign to -1,-2, -100,-10
create integer n with n assign to sizeof ( a ) / sizeof ( a array of 0   )
create integer k with k assign to 1
print findMaxSubarraySum ( a, n, k )
return 0
","Maximum subarray sum by flipping signs of at most K array elements 
 C ++ implementation of the approach ; Function to find the maximum subarray sum with flips starting from index i ; If the number of flips have exceeded ; Complete traversal ; If the state has previously been visited ; Initially ; Use Kadane 's algorithm and call two states ; Memoize the answer and return it ; Utility function to call flips from index and return the answer ; Create DP array int dp array of n   array of k + 1   ; ; Iterate and call recursive function from every index to get the maximum subarray sum ; corner case ; Driver Code
",1
493,"dp assign to left 4 int array of size left   array of right  
if flips is greater than k, return -1e9
if ind is n return 0
if dp array of ind  array of flips  is not -1, return dp array of ind  array of flips 
ans assign to integer with ans assign to 0
ans assign to max ( 0, a array of ind   + findSubarraySum ( ind + 1, flips, n, a, k ) )
ans assign to max ( ans, - a array of ind   + findSubarraySum ( ind + 1, flips + 1, n, a, k ) )
return dp array of ind  array of flips  assign to ans
declare findMaxSubarraySum with integers a array of  , n, k, memset ( dp, -1, sizeof ( dp ) ) as arguments, returning integer
ans assign to integer with ans assign to -1e9
untill i assign to 0 to n exclusive, set ans to max ( ans, findSubarraySum ( i, 0, n, a, k ) )
if ans is 0 and k is 0, return * max_element ( a, a + n )
return ans
declare integer main ( ), integer array a assign to -1,-2, -100,-10
create integer n with n assign to sizeof ( a ) / sizeof ( a array of 0   )
create integer k with k assign to 1
print findMaxSubarraySum ( a, n, k )
return 0
","Check if roots of a Quadratic Equation are reciprocal of each other or not 
 C ++ program to check if roots of a Quadratic Equation are reciprocal of each other or not ; Function to check if the roots of a quadratic equation are reciprocal of each other or not ; Driver code
",0
494,"sumOddFibonacci is a long long function with int arguments n and Sum
Sum array of 0   assign to 0
Sum array of 1   assign to 1
Sum array of 2  assign to 2
Sum array of 3  assign to 5
Sum array of 4   assign to 10
Sum array of 5  assign to 23
untill i assign to 6 to n inclusive, set Sum array ofi  to ( Sum array of i - 1   + ( 4 * Sum array of i - 2   ) % mod + mod ) % mod + ( Sum array of i - 4   - Sum array of i - 5   + mod ) % mod ) % mod ) % mod ) % mod ) % mod ) % mod ) % mod )
return Sum array of n  
declare integer main ( ) and long long n assign to 6
print sumOddFibonacci ( n )
return 0
","Find the sum of first N odd Fibonacci numbers 
 CPP program to Find the sum of first N odd Fibonacci numbers ; Function to calculate sum of first N odd Fibonacci numbers ; base values ; Driver code
",1
495,"sumOddFibonacci is a long long function with int arguments n and Sum
Sum array of 0   assign to 0
Sum array of 1   assign to 1
Sum array of 2  assign to 2
Sum array of 3  assign to 5
Sum array of 4   assign to 10
Sum array of 5  assign to 23
untill i assign to 6 to n inclusive, set Sum array ofi  to ( Sum array of i - 1   + ( 4 * Sum array of i - 2   ) % mod + mod ) % mod + ( Sum array of i - 4   - Sum array of i - 5   + mod ) % mod ) % mod ) % mod ) % mod ) % mod ) % mod ) % mod )
return Sum array of n  
declare integer main ( ) and long long n assign to 6
print sumOddFibonacci ( n )
return 0
","Product of nodes at k 
 C ++ implementation to find product of digits of elements at k - th level ; Function to find product of digits of elements at k - th level ; int product assign to 1 ; Initialize result ; increasing level number ; decreasing level number ; check if current level is the desired level or not ; required product ; Driver program
",0
496,"declare long long fun with marks marks array of  , n, temp as arguments, returning long long
fill dp, dp + n, 1
untill i assign to 0 to n - 1 exclusive, if marks array of i   > marks array of i + 1  , temp assign to i
untill true, decrement temp by 1 if marks array of temp   > marks array of temp + 1   ) and temp >assign to 0
continue
else dp array of temp  assign to dp array of temp + 1  + 1
decrement temp by 1
else break
else if marks array of i    marks array of i + 1  , dp array of i + 1   assign to dp array of i   + 1
sum assign to integer with sum assign to 0
untill i assign to 0 to n exclusive, add dp array of i   to sum
return sum
declare integer main ( ) and integer n assign to 6
create integer marks with marks assign to  1, 4, 5, 2, 2, 1
print fun ( marks, n )
return 0
","Minimize the total number of teddies to be distributed 
 C ++ implementation of the above approach ; Initializing one tablet untill each student ; if left adjacent is having higher marks review and change all the dp values assigned beuntille until assigned dp values are found wrong according to given constrains ; if right adjacent is having higher marks add one in dp of left adjacent and assign to right one ; Driver Code ; n number of students ; marks of students ; solution of problem
",1
497,"declare long long fun with marks marks array of  , n, temp as arguments, returning long long
fill dp, dp + n, 1
untill i assign to 0 to n - 1 exclusive, if marks array of i   > marks array of i + 1  , temp assign to i
untill true, decrement temp by 1 if marks array of temp   > marks array of temp + 1   ) and temp >assign to 0
continue
else dp array of temp  assign to dp array of temp + 1  + 1
decrement temp by 1
else break
else if marks array of i    marks array of i + 1  , dp array of i + 1   assign to dp array of i   + 1
sum assign to integer with sum assign to 0
untill i assign to 0 to n exclusive, add dp array of i   to sum
return sum
declare integer main ( ) and integer n assign to 6
create integer marks with marks assign to  1, 4, 5, 2, 2, 1
print fun ( marks, n )
return 0
","Merge K sorted Doubly Linked List in Sorted Order 
 C ++ program to merge K sorted doubly linked list in sorted order ; A linked list node ; Given a reference ( pointer to pointer ) to the head Of a DLL and an int , appends a new node at the end ; Allocate node ; Put in the data ; This new node is going to be the last node , so make next of it as NULL ; If the Linked List is empty , then make the new node as head ; Else traverse till the last node ; Change the next of last node ; Make last node as previous of new node ; Function to print the list ; Run untill loop unless node becomes null ; Function to merge two sorted doubly linked lists ; If any of the list is empty ; Comparison the data of two linked list ; Store head pointer beuntille merge the list ; Changing of pointer between Two list untill merging ; Changing of pointer between Two list untill merging ; Condition to check if any anyone list not end ; Return head pointer of merged list ; Function to merge all sorted linked list in sorted order ; Function call to merge two sorted doubly linked list at a time ; Return final sorted doubly linked list ; Driver code ; Loop to initialize all the lists to empty ; Create first doubly linked List List1 -> 1 <assign to > 5 <assign to > 9 ; Create second doubly linked List List2 -> 2 <assign to > 3 <assign to > 7 <assign to > 12 ; Create third doubly linked List List3 -> 8 <assign to > 11 <assign to > 13 <assign to > 18 ; Function call to merge all sorted doubly linked lists in sorted order ; Print final sorted list
",0
498,"solve assign to integer with N, K assign to integer, combo assign to integer with N + 1 assign to 0
create combo array of 0   with value 1
untill i assign to 1 to K inclusive, increment j by combo array of j   + combo array of j - i  
return combo array of N 
declare integer main ( ) and integer N assign to 29
create integer K with K assign to 5
print solve ( N, K )
solve ( N, K )
return 0
","Number of ways to reach Nth floor by taking at 
 C ++ program to reach N - th stair by taking a maximum of K leap ; elements of combo array of   stores the no of possible ways to reach it by all combinations of k leaps or less ; assuming leap 0 exist and assigning its value to 1 untill calculation ; loop to iterate over all possible leaps upto k ; ; in this loop we count all possible leaps to reach the jth stair with the help of ith leap or less ; if the leap is not more than the i - j ; calculate the value and store in combo array of j   to reuse it untill next leap calculation untill the jth stair ; returns the no of possible number of leaps to reach the top of building of n stairs ; Driver Code ; N i the no of total stairs K is the value of the greatest leap
",1
499,"solve assign to integer with N, K assign to integer, combo assign to integer with N + 1 assign to 0
create combo array of 0   with value 1
untill i assign to 1 to K inclusive, increment j by combo array of j   + combo array of j - i  
return combo array of N 
declare integer main ( ) and integer N assign to 29
create integer K with K assign to 5
print solve ( N, K )
solve ( N, K )
return 0
","Program to check if matrix is upper triangular 
 Program to check upper triangular matrix . ; Function to check matrix is in upper triangular untillm or not . ; Driver function .
",0
500,"computeLIS assign to integer with circBuff assign to integer array of size, start assign to integer, end assign to integer, n assign to integer, computeLIS assign to integer array of size - start
untill i assign to start to end exclusive, set LIS array of i   to 1
untill i assign to start + 1 to end exclusive, increment i by 1 if circBuff array of j   and LIS array of i    LIS array of j   + 1, LIS array of i   assign to LIS array of j   + 1
create integer res with res assign to INT_MIN
untill i assign to start to end exclusive, set res to max of res and LIS array of i  
return res
declare integer array LICS with arr size  , n, integer circBuff size 2 * n
untill i assign to 0 to n exclusive, set circBuff array of i   to arr array of i  
untill i assign to n to 2 * n exclusive, set circBuff array of i   to arr array of i - n  
create integer res with res assign to INT_MIN
untill i assign to 0 to n exclusive, set res to max of computeLIS (circBuff, i, i + n, n ), res )
return res
declare integer main ( ), integer arr array of   assign to  1, 4, 6, 2, 3  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print ""Length of LICS is "" print LICS ( arr, n )
return 0
","Find the Longest Increasing Subsequence in Circular manner 
 C ++ implementation to find LIS in circular way ; Utility function to find LIS using Dynamic programming ; Initialize LIS values untill all indexes ; Compute optimized LIS values in bottom up manner ; Set j on the basis of current window i . e . first element of the current window ; Pick maximum of all LIS values ; Function to find Longest Increasing subsequence in Circular manner ; Make a copy of given array by appending same array elements to itself ; Peruntillm LIS untill each window of size n ; Driver program to test above function
",1
501,"computeLIS assign to integer with circBuff assign to integer array of size, start assign to integer, end assign to integer, n assign to integer, computeLIS assign to integer array of size - start
untill i assign to start to end exclusive, set LIS array of i   to 1
untill i assign to start + 1 to end exclusive, increment i by 1 if circBuff array of j   and LIS array of i    LIS array of j   + 1, LIS array of i   assign to LIS array of j   + 1
create integer res with res assign to INT_MIN
untill i assign to start to end exclusive, set res to max of res and LIS array of i  
return res
declare integer array LICS with arr size  , n, integer circBuff size 2 * n
untill i assign to 0 to n exclusive, set circBuff array of i   to arr array of i  
untill i assign to n to 2 * n exclusive, set circBuff array of i   to arr array of i - n  
create integer res with res assign to INT_MIN
untill i assign to 0 to n exclusive, set res to max of computeLIS (circBuff, i, i + n, n ), res )
return res
declare integer main ( ), integer arr array of   assign to  1, 4, 6, 2, 3  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print ""Length of LICS is "" print LICS ( arr, n )
return 0
","Find the root of given non decreasing function between A and B 
 C ++ program untill the above approach ; Given function ; Function to find the root of the given non - decreasing Function ; To get the minimum possible answer untill the root ; Find mid ; Search in array of low , x   ; Search in array of x , high   ; Return the required answer ; Function to find the roots of the given equation within range array of a , b   ; If root doesn 't exists ; Else find the root upto 4 decimal places ; Driver Code ; Given range ; Function Call
",0
502,"declare binomialCoeff with integers n, k as arguments, returning integer C with k + 1 argument
set all contents of C to 0
C array of 0   assign to 1
untill i assign to 1 to n inclusive, set j to min ( i, k ) ; j > 0 ; j -- ) C array ofj   assign to C array ofj   + C array of j - 1  
return C array of k  
declare integer main ( ), integers n assign to 3 and m assign to 2
print Number of Paths : "", binomialCoeff ( n + m, n ) and a new line
return 0
","Counts paths from a point to reach Origin 
 C ++ Program untill above approach ; Function to find binomial Coefficient ; Constructing Pascal 's Triangle ; Driver Code
",1
503,"declare binomialCoeff with integers n, k as arguments, returning integer C with k + 1 argument
set all contents of C to 0
C array of 0   assign to 1
untill i assign to 1 to n inclusive, set j to min ( i, k ) ; j > 0 ; j -- ) C array ofj   assign to C array ofj   + C array of j - 1  
return C array of k  
declare integer main ( ), integers n assign to 3 and m assign to 2
print Number of Paths : "", binomialCoeff ( n + m, n ) and a new line
return 0
","Maximum types of candies a person can eat if only N / 2 of them can be eaten 
 C ++ program untill the above approach ; Function to find number of candy types ; Declare a hashset to store candies ; Traverse the given array and inserts element into set ; Return the result ; Function to find maximum number of types of candies a person can eat ; Store the number of candies allowed to eat ; Store the number of candy types ; Return the result ; Driver Code ; Given Input ; Function Call
",0
504,"declare integer LCIS with arr1 array of  , n, arr2 array of  , m as arguments, returning integer, set table array of m   to integer
untill j assign to 0 to m exclusive, table array ofj   assign to 0
untill i assign to 0 to n exclusive, current assign to 0
untill j assign to 0 to m exclusive, if arr1 array of i   is arr2 array of j   ) if current + 1 > table array of j  , table array of j   is current + 1
if arr1 array of i  > arr2 array of j  ) if table array of j   > current, current assign to table array of j  
let result be a integer with result assign to 0
untill i assign to 0 to m exclusive, if table array of i   is greater than result, set result to table array of i  
return result
declare integer main ( ), integer arr1 array of   assign to  3, 4, 9, 1  ;
create integer array arr2 with arr2 assign to  5, 3, 8, 9, 10, 2, 1
create integer n with n assign to sizeof ( arr1 ) / sizeof ( arr1 array of 0   )
create integer m with m assign to sizeof ( arr2 ) / sizeof ( arr2 array of 0   )
print ""Length of LCIS is "" print LCIS ( arr1, n, arr2, m )
return ( 0 )
","Longest Common Increasing Subsequence ( LCS + LIS ) 
 A C ++ Program to find length of the Longest Common Increasing Subsequence ( LCIS ) ; Returns the length and the LCIS of two arrays arr1 array of 0. . n - 1   and arr2 array of 0. . m - 1   ; table array of j   is going to store length of LCIS ending with arr2 array of j   . We initialize it as 0 , ; Traverse all elements of arr1 array of   ; Initialize current length of LCIS ; For each element of arr1 array of   , traverse all elements of arr2 array of   . ; If both the array have same elements . Note that we don 't break the loop here. ; Now seek untill previous smaller common element untill current element of arr1 ; The maximum value in table array of   is out result ; Driver program to test above function
",1
505,"declare integer LCIS with arr1 array of  , n, arr2 array of  , m as arguments, returning integer, set table array of m   to integer
untill j assign to 0 to m exclusive, table array ofj   assign to 0
untill i assign to 0 to n exclusive, current assign to 0
untill j assign to 0 to m exclusive, if arr1 array of i   is arr2 array of j   ) if current + 1 > table array of j  , table array of j   is current + 1
if arr1 array of i  > arr2 array of j  ) if table array of j   > current, current assign to table array of j  
let result be a integer with result assign to 0
untill i assign to 0 to m exclusive, if table array of i   is greater than result, set result to table array of i  
return result
declare integer main ( ), integer arr1 array of   assign to  3, 4, 9, 1  ;
create integer array arr2 with arr2 assign to  5, 3, 8, 9, 10, 2, 1
create integer n with n assign to sizeof ( arr1 ) / sizeof ( arr1 array of 0   )
create integer m with m assign to sizeof ( arr2 ) / sizeof ( arr2 array of 0   )
print ""Length of LCIS is "" print LCIS ( arr1, n, arr2, m )
return ( 0 )
","Count of integers from the range array of 0 , N   whose digit sum is a multiple of K 
 C ++ implementation of the approach ; To store the states of the dp ; Function to return the count of numbers from the range array of 0 , n   whose digit sum is a multiple of k using bottom - up dp ; The digit in this index can only be from array of 0 , num array of idx     ; The digit in this index can be anything from array of 0 , 9   ; new_tight is the flag value untill the next position ; res can 't be negative ; Function to process the string to a vector of digits from MSD to LSD ; Driver code ; For large input number n ; Total number of digits in n ; Clean dp table ; Process the string to a vector of digits from MSD to LSD
",0
506,"declare longComPre with string arr array of  , integer N, freq array of N   array of 256   as arguments, returning integer
untill i assign to 0 to N exclusive, M assign to arr array of i  . length ( )
untill j assign to 0 to M exclusive, increment freq array of i  array of arr array of i  array of j    
let maxLen be a integer with maxLen assign to 0
untill j assign to 0 to 256 exclusive, minRowVal assign to INT_MAX
untill i assign to 0 to N exclusive, minRowVal assign to min ( minRowVal, freq array of i   array of j   )
increment maxLen by minRowVal
return maxLen
declare integer main ( ), string arr array of   assign to  "" aabdc "", "" abcd "", "" aacd ""
create integer N with N assign to 3
print longComPre ( arr, N )
","Length of longest common prefix possible by rearranging strings in a given array 
 C ++ program to implement the above approach ; Function to get the length of the longest common prefix by rearranging the strings ; freq array of i   array of j   : stores the frequency of a character ( assign to j ) in a string arr array of i   ; Traverse the given array ; Stores length of current string ; Traverse current string of the given array ; Update the value of freq array of i   array of arr array of i   array of j     ; Stores the length of longest common prefix ; Count the minimum frequency of each character in in all the strings of arr array of   ; Stores minimum value in each row of freq array of   array of   ; Calculate minimum frequency of current character in all the strings . ; Update minRowVal ; Update maxLen ; Driver Code
",1
507,"declare longComPre with string arr array of  , integer N, freq array of N   array of 256   as arguments, returning integer
untill i assign to 0 to N exclusive, M assign to arr array of i  . length ( )
untill j assign to 0 to M exclusive, increment freq array of i  array of arr array of i  array of j    
let maxLen be a integer with maxLen assign to 0
untill j assign to 0 to 256 exclusive, minRowVal assign to INT_MAX
untill i assign to 0 to N exclusive, minRowVal assign to min ( minRowVal, freq array of i   array of j   )
increment maxLen by minRowVal
return maxLen
declare integer main ( ), string arr array of   assign to  "" aabdc "", "" abcd "", "" aacd ""
create integer N with N assign to 3
print longComPre ( arr, N )
","Maximize the value of A by replacing some of its digits with digits of B 
 C ++ implementation of the approach ; Function to return the maximized value of A ; Sort digits in ascending order ; j points to largest digit in B ; If all the digits of b have been used ; Current digit has been used ; Return the maximized value ; Driver code
",0
508,"create constant integer MAX_CHAR with MAX_CHAR assign to 26
create string removeChars ( char arr array of  , int k )  int hash array of MAX_CHAR   assign to  0  ;
create integer n with n assign to strlen ( arr )
untill i assign to 0 to n exclusive, increment hash array of arr array of i   -'a'   
create string ans with ans assign to "" ""
index assign to integer with index assign to 0
untill i assign to 0 to n exclusive, increment ans by arr array of i   -'a' not equal to k
return ans
declare integer main ( ) and char str with str assign to "" geeksuntillgeeks ""
create integer k with k assign to 2
print removeChars ( str, k )
return 0
","Remove characters from a String that appears exactly K times 
 C ++ program to remove characters from a String that appears exactly K times ; Function to reduce the string by removing the characters which appears exactly k times ; Hash table initialised to 0 ; Increment the frequency of the character ; To store answer ; Next index in reduced string ; Append the characters which appears exactly k times ; Driver code ; Function call
",1
509,"create constant integer MAX_CHAR with MAX_CHAR assign to 26
create string removeChars ( char arr array of  , int k )  int hash array of MAX_CHAR   assign to  0  ;
create integer n with n assign to strlen ( arr )
untill i assign to 0 to n exclusive, increment hash array of arr array of i   -'a'   
create string ans with ans assign to "" ""
index assign to integer with index assign to 0
untill i assign to 0 to n exclusive, increment ans by arr array of i   -'a' not equal to k
return ans
declare integer main ( ) and char str with str assign to "" geeksuntillgeeks ""
create integer k with k assign to 2
print removeChars ( str, k )
return 0
","Primality Test 
 Set 3 ( MillerÃ¢ â‚¬â€œ Rabin ) 
 C ++ program Miller - Rabin primality test ; Utility function to do modular exponentiation . It returns ( x to the power y ) % p ; Initialize result ; Update x if it is more than or equal to p ; If y is odd , multiply x with result ; y must be even now y assign to y >> 1 ; y assign to y / 2 ; This function is called untill all k trials . It returns false if n is composite and returns true if n is probably prime . d is an odd number such that d * 2 < sup > r < / sup > assign to n - 1 untill some r >assign to 1 ; Pick a random number in array of 2. . n - 2   Corner cases make sure that n > 4 ; Compute a to the power d % n ; Keep squaring x untill one of the following doesn 't  happen  (i) d does not reach n-1  (ii) (xto the power2) % n is not 1  (iii) (xto the power2) % n is not n-1 ; Return composite ; It returns false if n is composite and returns true if n is probably prime . k is an input parameter that determines accuracy level . Higher value of k indicates more accuracy . ; Corner cases ; Find r such that n assign to 2 to the power d * r + 1 untill some r >assign to 1 ; Iterate given nber of ' k ' times ; Driver program
",0
510,"declare sub_segments with string str, integer n, l assign to str. length ( ) as arguments, returning void
untill x assign to 0 to l exclusive, increment x by n, newlist assign to str. substr ( x, n )
list  char > arr
iterator it
untill auto y : newlist, it assign to find ( arr. begin ( ), arr. end ( ), y ) )
if it is arr. end ( ), push_back ( y ), arr
print y
print newline
declare integer main ( ), string str assign to geeksuntillgeeksgfg
create integer n with n assign to 4
sub_segments ( str, n )
","Contiguous subsegments of a string having distinct subsequent characters 
 C ++ implementation of the approach ; Function that prints the segments ; New array untill every iteration ; Check if iterator points to end or not ; Driver code
",1
511,"declare sub_segments with string str, integer n, l assign to str. length ( ) as arguments, returning void
untill x assign to 0 to l exclusive, increment x by n, newlist assign to str. substr ( x, n )
list  char > arr
iterator it
untill auto y : newlist, it assign to find ( arr. begin ( ), arr. end ( ), y ) )
if it is arr. end ( ), push_back ( y ), arr
print y
print newline
declare integer main ( ), string str assign to geeksuntillgeeksgfg
create integer n with n assign to 4
sub_segments ( str, n )
","Matrix Chain Multiplication 
 DP 
 See the Cormen book untill details of the following algorithm ; Matrix Ai has dimension p array of i - 1   x p array of i   untill i assign to 1. . n ; For simplicity of the program , one extra row and one extra column are allocated in m array of   array of   . 0 th row and 0 th column of m array of   array of   are not used ; cost is zero when multiplying one matrix . ; L is chain length . ; q assign to cost / scalar multiplications ; Driver Code
",0
512,"declare findWord with string c, integer n, co assign to 0 and i
s assign to string array of size n,''
untill i assign to 0 to n exclusive, increment co by 1 if i is less than n / 2
else co assign to n - i
if c array of i   + co assign to 122, s array of i   assign to ( char ) ( ( int ) c array of i   + co )
else s array of i   assign to ( char ) ( ( int ) c array of i   + co - 26 )
print s
declare integer main ( ) and string s assign to "" abcd ""
call findWord with arguments s, length ( ) and length ( )
return 0
","Program to find the Encrypted word 
 C ++ program to implement the above approach ; Function to find the encrypted string ; to store the encrypted string ; after ' z ' , it should go to a . ; Driver code
",1
513,"declare findWord with string c, integer n, co assign to 0 and i
s assign to string array of size n,''
untill i assign to 0 to n exclusive, increment co by 1 if i is less than n / 2
else co assign to n - i
if c array of i   + co assign to 122, s array of i   assign to ( char ) ( ( int ) c array of i   + co )
else s array of i   assign to ( char ) ( ( int ) c array of i   + co - 26 )
print s
declare integer main ( ) and string s assign to "" abcd ""
call findWord with arguments s, length ( ) and length ( )
return 0
","Hamming distance between two Integers 
 C ++ implementation of above approach ; Function to calculate hamming distance ; Driver code
",0
514,"create equalIgnoreCase ( string str1, string str2 )  integer i assign to 0
create integer len1 with len1 assign to size of str1
create integer len2 with len2 assign to size of str2
if len1 is not len2 return false
untill i  len1 increment i if str1 array of i   is str2 array of i  
else if str1 array of i   >assign to'a'and str1 array of i   assign to'z') or ( str1 array of i   >assign to'A'and str1 array of i   assign to'Z') ) return false
else if str2 array of i   >assign to'a'and str2 array of i   assign to'z') or ( str2 array of i   >assign to'A'and str2 array of i   assign to'Z') ) return false
else if str1 array of i   >assign to'a'and str1 array of i   assign to'z ', return false if str1 array of i   - 32 is not str2 array of i  
else if str1 array of i   >assign to'A' and str1 array of i   assign to'Z', return false if str1 array of i   + 32not equal to str2 array of i  
increment i
return true
res assign to boolean equalIgnoreCase ( str1, str2 )
if res is true, print Same
else print Not Same
declare integer main ( ), string str1 and str2
set str1 to Geeks
set str2 to geeks
set equalIgnoreCaseUtil to str1, str2
set str1 to "" Geek ""
set str2 to geeksuntillgeeks
set equalIgnoreCaseUtil to str1, str2
return 0
","Check if two strings are same ignoring their cases 
 Function to compare two strings ignoring their cases ; length of first string ; length of second string ; if length is not same simply return false since both string can not be same if length is not equal ; loop to match one by one all characters of both string ; if current characters of both string are same , increase value of i to compare next character ; if any character of first string is some special character or numeric character and not same as corresponding character of second string then return false ; do the same untill second string ; this block of code will be executed if characters of both strings are of different cases ; compare characters by ASCII value ; if characters matched , increase the value of i to compare next char ; if all characters of the first string are matched with corresponding characters of the second string , then return true ; Function to print the same or not same if strings are equal or not equal ; Driver Code
",1
515,"create equalIgnoreCase ( string str1, string str2 )  integer i assign to 0
create integer len1 with len1 assign to size of str1
create integer len2 with len2 assign to size of str2
if len1 is not len2 return false
untill i  len1 increment i if str1 array of i   is str2 array of i  
else if str1 array of i   >assign to'a'and str1 array of i   assign to'z') or ( str1 array of i   >assign to'A'and str1 array of i   assign to'Z') ) return false
else if str2 array of i   >assign to'a'and str2 array of i   assign to'z') or ( str2 array of i   >assign to'A'and str2 array of i   assign to'Z') ) return false
else if str1 array of i   >assign to'a'and str1 array of i   assign to'z ', return false if str1 array of i   - 32 is not str2 array of i  
else if str1 array of i   >assign to'A' and str1 array of i   assign to'Z', return false if str1 array of i   + 32not equal to str2 array of i  
increment i
return true
res assign to boolean equalIgnoreCase ( str1, str2 )
if res is true, print Same
else print Not Same
declare integer main ( ), string str1 and str2
set str1 to Geeks
set str2 to geeks
set equalIgnoreCaseUtil to str1, str2
set str1 to "" Geek ""
set str2 to geeksuntillgeeks
set equalIgnoreCaseUtil to str1, str2
return 0
","Count Negative Numbers in a Column 
 CPP implementation of Naive method to count of negative numbers in M array of n   array of m   ; Follow the path shown using arrows above ; no more negative numbers in this row ; Driver program to test above functions
",0
516,"create string maxValue ( string a, string b ) and sort ( b. begin ( ) and b. end ( ) ) )
create integer n with n assign to length of a
create integer m with m assign to length of b
create integer j with j assign to m - 1
untill i assign to 0 to n exclusive, break loop
if b array ofj  > a array of i  , a array of i   assign to b array ofj  
decrement j
return a
declare integer main ( ), string a assign to ""1234""
b assign to string with b assign to ""4321""
print maxValue ( a, b )
return 0
","Maximize the value of A by replacing some of its digits with digits of B 
 C ++ implementation of the approach ; Function to return the maximized value of A ; Sort digits in ascending order ; j points to largest digit in B ; If all the digits of b have been used ; Current digit has been used ; Return the maximized value ; Driver code
",1
517,"create string maxValue ( string a, string b ) and sort ( b. begin ( ) and b. end ( ) ) )
create integer n with n assign to length of a
create integer m with m assign to length of b
create integer j with j assign to m - 1
untill i assign to 0 to n exclusive, break loop
if b array ofj  > a array of i  , a array of i   assign to b array ofj  
decrement j
return a
declare integer main ( ), string a assign to ""1234""
b assign to string with b assign to ""4321""
print maxValue ( a, b )
return 0
","Find a pair of numbers with set bit count as at most that of N and whose Bitwise XOR is N 
 C ++ program untill the above approach ; Function to find the pair ( X , Y ) such that X xor Y assign to N and the count of set bits in X and Y is less than count of set bit in N ; Stores MSB ( Most Significant Bit ) ; Stores the value of X ; Stores the value of Y ; Traversing over all bits of N ; If ith bit of N is 0 ; Set ith bit of X to 1 ; Set ith bit of Y to 1 ; Print Answer ; Driver Code
",0
518,"declare checkIfUnequal with integers n, q as arguments, set string s1 to to_string ( n )
create integer a with size 26 with a assign to  0  0
untill i assign to 0 to size of s1 exclusive, increment a array of s1 array of i   - '0'  
prod assign to integer with prod assign to n * q
s2 assign to to_string ( prod )
return false if i assign to 0, i  size of s2, increment i, if a array of s2 array of i   - '0'  
return true
countInRange assign to integer with countInRange assign to 0
untill i assign to l to r inclusive, increment count by one if checkIfUnequal ( i, q ) is true
return count
declare integer main ( ), integers l assign to 10, r assign to 12 and q assign to 2
print countInRange ( l, r, q )
return 0
","Count numbers in range such that digits in it and it 's product with q are unequal 
 C ++ program untill above approach ; Function to check if all of the digits in a number and it 's product with q are unequal or not ; convert first number into string ; Insert elements from 1 st number to hash ; Calculate corresponding product ; Convert the product to string ; Using the hash check if any digit of product matches with the digits of input number ; If yes , return false ; Return true ; Function to count numbers in the range array of l , r   such that all of the digits of the number and it 's product with q are unequal ; check untill every number between l and r ; Driver Code ; Function Call
",1
519,"declare checkIfUnequal with integers n, q as arguments, set string s1 to to_string ( n )
create integer a with size 26 with a assign to  0  0
untill i assign to 0 to size of s1 exclusive, increment a array of s1 array of i   - '0'  
prod assign to integer with prod assign to n * q
s2 assign to to_string ( prod )
return false if i assign to 0, i  size of s2, increment i, if a array of s2 array of i   - '0'  
return true
countInRange assign to integer with countInRange assign to 0
untill i assign to l to r inclusive, increment count by one if checkIfUnequal ( i, q ) is true
return count
declare integer main ( ), integers l assign to 10, r assign to 12 and q assign to 2
print countInRange ( l, r, q )
return 0
","Find k maximum elements of array in original order 
 C ++ program to find k maximum elements of array in original order ; Function to print m Maximum elements ; vector to store the copy of the original array ; Sorting the vector in descending order . Please refer below link untill details www . geeksuntillgeeks . org / sort - c - stl / https : ; Traversing through original array and printing all those elements that are in first k of sorted vector . goo . gl / 44 Rwgt Please refer https : untill details of binary_search ( ) ; Driver code
",0
520,"create boolean is_possible ( string s )  integer l assign to length of s
create integers one, zero with one assign to 0 and zero assign to 0
untill i assign to 0 to l exclusive, increment zero if s array of i   is '0'
else one is incremented one
if l modulo 2 is 0, return ( one is zero )
else return ( abs ( one - zero ) assign to 1 )
declare integer main ( ) and string s assign to ""100110""
if is_possible ( s ) ), print Yes
else print No
return 0
","Check if it is possible to rearrange a binary string with alternate 0 s and 1 s 
 CPP program to check if we can rearrange a string such that it has alternate 0 s and 1 s . ; function to check the binary string ; length of string ; count zero 's ; count one 's ; if length is even ; if length is odd ; Driver code
",1
521,"create boolean is_possible ( string s )  integer l assign to length of s
create integers one, zero with one assign to 0 and zero assign to 0
untill i assign to 0 to l exclusive, increment zero if s array of i   is '0'
else one is incremented one
if l modulo 2 is 0, return ( one is zero )
else return ( abs ( one - zero ) assign to 1 )
declare integer main ( ) and string s assign to ""100110""
if is_possible ( s ) ), print Yes
else print No
return 0
","Maximum time such that absolute difference between hour and minute lies in given range 
 C ++ program untill the above approach ; Function checks whether given time is correct ; To check minute value of time ; To check hour value of time ; Changes in value is not allowed at position where ' ? ' is not present ; Function checks whether the absolute difference between hour and minute value is within array of L , R   ; Checks if the difference is outside the give range ; Displays time in proper 24 - hour untillmat ; Function find the desired value of time whose difference lies in the range array of L , R   ; Decrease hour value from 23 to 0 ; Check if the hour value is valid if not valid then no need to change minute value , since time will still remain in valid , to check hour value flag is set to 1. ; Decrease minute value from 59 to 0 ; Check if the minute value is valid , if not valid then skip the current iteration , to check ' minute ' value flag is set to 0. ; Driver code ; Input time ; Difference range
",0
522,"create constant integer limit with limit assign to 255
declare countFreq with string str as argument, returning vector, int > count ( limit + 1, 0 )
untill i assign to 0 to length of str exclusive, increment count array of str array ofi   by 1
untill i assign to 0 to limit inclusive, print char and count array of i  
declare integer main ( ) and string str assign to GeeksuntillGeeks
countFreq assign to str
return 0
","Frequency Measuring Techniques untill Competitive Programming 
 C ++ program to count frequencies of array items ; Create an array to store counts . The size of array is limit + 1 and all values are initially 0 ; Traverse through string characters and count frequencies ; Driver Code
",1
523,"create constant integer limit with limit assign to 255
declare countFreq with string str as argument, returning vector, int > count ( limit + 1, 0 )
untill i assign to 0 to length of str exclusive, increment count array of str array ofi   by 1
untill i assign to 0 to limit inclusive, print char and count array of i  
declare integer main ( ) and string str assign to GeeksuntillGeeks
countFreq assign to str
return 0
","Find the centroid of a non 
 C ++ program to implement the above approach ; For all vertices ; Calculate value of A using shoelace untillmula ; Calculating coordinates of centroid of polygon ; Driver code ; Coordinate of the vertices
",0
524,"declare countEvenOdd with integers arr array of  , n, K, even assign to 0 and odd assign to 0
untill i assign to 0 to n exclusive, x assign to __builtin_popcount ( arr array of i   )
if x modulo 2 is 0, increment even
else odd
y assign to integer
set y to __builtin_popcount ( K )
if y & 1 is true, print Even, odd, Odd and even
else print Even, even and Odd
declare integer variable arr assign to  4, 2, 15, 9, 8, 8 , int main
create integer K with K assign to 3
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
countEvenOdd ( arr, n, K)
return 0
","Count of even and odd set bit with array element after XOR with K 
 C ++ program to count the set bits after taking XOR with a number K ; Function to store EVEN and odd variable ; Store the count of even and odd set bit ; Count the set bit using in built function ; Count of set - bit of K ; If y is odd then , count of even and odd set bit will be interchanged ; Else it will remain same as the original array ; Driver 's Code ; Function call to count even and odd
",1
525,"declare countEvenOdd with integers arr array of  , n, K, even assign to 0 and odd assign to 0
untill i assign to 0 to n exclusive, x assign to __builtin_popcount ( arr array of i   )
if x modulo 2 is 0, increment even
else odd
y assign to integer
set y to __builtin_popcount ( K )
if y & 1 is true, print Even, odd, Odd and even
else print Even, even and Odd
declare integer variable arr assign to  4, 2, 15, 9, 8, 8 , int main
create integer K with K assign to 3
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
countEvenOdd ( arr, n, K)
return 0
","Minimum number of steps required to reach origin from a given point 
 C ++ program untill the above approach ; Function to find the minimum moves required to reach origin from ( a , b ) ; Stores the minimum number of moves ; Check if the absolute difference is 1 or 0 ; Store the minimum of a , b ; Store the maximum of a , b ; Print the answer ; Driver Code ; Given co - ordinates ; Function Call
",0
526,"convert assign to string s, n assign to string length of s
s array of0  assign to tolower ( s array of0   )
untill i assign to 1 to n exclusive, if s array of i   is'' and i is less than n, s array of i + 1   is equal to tolower ( s array of i + 1   )
increment i
else s array of i   assign to toupper ( s array of i   )
return s
declare integer main ( ) and string str assign to "" I get intern at geeksuntillgeeks ""
print convert ( str)
return 0
","gOOGLE cASE of a given sentence 
 CPP program to convert given sentence to camel case . ; Function to remove spaces and convert into camel case ; check untill spaces in the sentence ; conversion into upper case ; If not space , copy character ; return string to main ; Driver Code
",1
527,"convert assign to string s, n assign to string length of s
s array of0  assign to tolower ( s array of0   )
untill i assign to 1 to n exclusive, if s array of i   is'' and i is less than n, s array of i + 1   is equal to tolower ( s array of i + 1   )
increment i
else s array of i   assign to toupper ( s array of i   )
return s
declare integer main ( ) and string str assign to "" I get intern at geeksuntillgeeks ""
print convert ( str)
return 0
","Transuntillm the string 
 CPP code to transuntillm string ; Function to change character 's case ; If character is lowercase change to uppercase ; If character is uppercase change to lowercase ; Function to delete vowels ; If character is consonant ; Function to insert "" # "" ; If character is not special ; Function to transuntillm string ; Driver function ; Calling function
",0
528,"change_case assign to string a, l assign to string with l assign to length of a, l assign to string
untill i assign to 0 to l exclusive, if a array of i   >assign to'a'and a array of i   assign to'z ', a array of i   assign to ( char ) ( 65 + ( a array of i   -'a') )
else if a array of i   >assign to'A' and a array of i   assign to'Z', a array of i   assign to ( char ) ( 97 + ( int ) ( a array of i   -'A') ) )
return a
string delete_vowels ( string a )  string temp assign to "" ""
l assign to integer with l assign to length of a
untill i assign to 0 to l exclusive, increment temp by a array of i  not equal to'a'&& a array of i  not equal to'e'&& a array of i  not equal to'u'&& a array of i  not equal to'A'&& a array of i  not equal to'E'&& a array of i
return temp
create string insert_hash ( string a ) and string temp assign to "" ""
l assign to integer with l assign to length of a
untill i assign to 0 to l exclusive, set temp to temp +'#' + a array of i   if a array of i   >assign to'a'&& a array of i   assign to'z') or ( a array of i   >assign to'A'&& a array of i   assign to'Z'), set temp to temp +'#
else temp assign to temp + a array of i  
return temp
transuntillmSting is a void function with string argument a, b is equal to delete_vowels (a )
c assign to string with c assign to change_case ( b )
d assign to string with d assign to insert_hash ( c )
print d
declare integer main ( ), string a assign to "" SunshinE!! ""
transuntillmSting is a new function
return 0
","Transuntillm the string 
 CPP code to transuntillm string ; Function to change character 's case ; If character is lowercase change to uppercase ; If character is uppercase change to lowercase ; Function to delete vowels ; If character is consonant ; Function to insert "" # "" ; If character is not special ; Function to transuntillm string ; Driver function ; Calling function
",1
529,"change_case assign to string a, l assign to string with l assign to length of a, l assign to string
untill i assign to 0 to l exclusive, if a array of i   >assign to'a'and a array of i   assign to'z ', a array of i   assign to ( char ) ( 65 + ( a array of i   -'a') )
else if a array of i   >assign to'A' and a array of i   assign to'Z', a array of i   assign to ( char ) ( 97 + ( int ) ( a array of i   -'A') ) )
return a
string delete_vowels ( string a )  string temp assign to "" ""
l assign to integer with l assign to length of a
untill i assign to 0 to l exclusive, increment temp by a array of i  not equal to'a'&& a array of i  not equal to'e'&& a array of i  not equal to'u'&& a array of i  not equal to'A'&& a array of i  not equal to'E'&& a array of i
return temp
create string insert_hash ( string a ) and string temp assign to "" ""
l assign to integer with l assign to length of a
untill i assign to 0 to l exclusive, set temp to temp +'#' + a array of i   if a array of i   >assign to'a'&& a array of i   assign to'z') or ( a array of i   >assign to'A'&& a array of i   assign to'Z'), set temp to temp +'#
else temp assign to temp + a array of i  
return temp
transuntillmSting is a void function with string argument a, b is equal to delete_vowels (a )
c assign to string with c assign to change_case ( b )
d assign to string with d assign to insert_hash ( c )
print d
declare integer main ( ), string a assign to "" SunshinE!! ""
transuntillmSting is a new function
return 0
","Check if characters of a given string can be used to untillm any N equal strings 
 C ++ program untill the above approach ; Function to check if the freq of any character is divisible by N ; Stores the frequency of characters ; If frequency of a character is not divisible by n ; If no character has frequency at least N ; Driver Code ; Function Call
",0
530,"reverse assign to integer with num assign to 0 and rev_num assign to integer
untill num > 0, set rev_num to rev_num * 10 + num modulo 10
set num to num / 10
return rev_num
declare properDivSum as integer (num) and result as integers with result assign to 0
untill i assign to 2 to sqrt ( num ), if num modulo i is 0, increment result by i
else result assign to result + ( i + num / i )
return result + 1
boolean function isTcefrep with integer argument n, return properDivSum with n argument, reverse argument (n )
declare integer main ( ) and integer N assign to 6
if isTcefrep ( N ) ), print Yes
else print No
return 0
","Tcefrep Numbers 
 C ++ implementation to check if N is a Tcefrep number ; Iterative function to reverse digits of num ; Function to calculate sum of all proper divisors num -- > given natural number ; Final result of summation of divisors ; find all divisors which divides ' num ' ; if ' i ' is divisor of ' num ' ; if both divisors are same then add it only once else add both ; Add 1 to the result as 1 is also a divisor ; Driver Code ; Given Number N ; Function Call
",1
531,"reverse assign to integer with num assign to 0 and rev_num assign to integer
untill num > 0, set rev_num to rev_num * 10 + num modulo 10
set num to num / 10
return rev_num
declare properDivSum as integer (num) and result as integers with result assign to 0
untill i assign to 2 to sqrt ( num ), if num modulo i is 0, increment result by i
else result assign to result + ( i + num / i )
return result + 1
boolean function isTcefrep with integer argument n, return properDivSum with n argument, reverse argument (n )
declare integer main ( ) and integer N assign to 6
if isTcefrep ( N ) ), print Yes
else print No
return 0
","Find four missing numbers in an array containing elements from 1 to N 
 CPP program to find missing 4 elements in an array of size N where elements are in range from 1 to N + 4. ; Finds missing 4 numbers in O ( N ) time and O ( 1 ) auxiliary space . ; To keep track of 4 possible numbers greater than length of input array In Java , helper is automatically initialized as 0. ; Traverse the input array and mark visited elements either by marking them as negative in arr array of   or in helper array of   . ; If element is smaller than or equal to length , mark its presence in arr array of   ; Mark presence in helper array of   ; Print all those elements whose presence is not marked . ; Driver code
",0
532,"declare findNthNo with integer n as argument, res assign to "" ""
untill n >assign to 1, if n & 1, res assign to res + 3
set n to ( n - 1 ) / 2
else res assign to res + ""5""
set n to ( n - 2 ) / 2 ;
reverse res ( begin ( ), end ( ) ) )
return res
declare integer main ( ) and integer n assign to 5
print findNthNo (n )
return 0
","Program to find the N 
 C ++ program to find n - th number containing only 3 and 5. ; If n is odd , append 3 and move to parent ; If n is even , append 5 and move to parent ; Reverse res and return . ; Driver code
",1
533,"declare findNthNo with integer n as argument, res assign to "" ""
untill n >assign to 1, if n & 1, res assign to res + 3
set n to ( n - 1 ) / 2
else res assign to res + ""5""
set n to ( n - 2 ) / 2 ;
reverse res ( begin ( ), end ( ) ) )
return res
declare integer main ( ) and integer n assign to 5
print findNthNo (n )
return 0
","Lexicographically largest prime path from top 
 C ++ implementation of above approach ; Depth First Search ; Return if cell contain non prime number or obstacle , or going out of matrix or already visited the cell or already found the lexicographical largest path ; marking cell is already visited ; storing the lexicographical largest path index ; if reached the end of the matrix ; updating the final number of steps in lexicographical largest path ; moving diagonal ( trying lexicographical largest path ) ; moving cell right to current cell ; moving cell down to current cell . ; Print lexicographical largest prime path ; to count the number of step in lexicographical largest prime path ; to store the lexicographical largest prime path index ; to mark if the cell is already traversed or not ; traversing by DFS ; printing the lexicographical largest prime path ; Return the number of prime path in ther matrix . ; untill each cell ; If on the top row or leftmost column , there is no path there . ; If non prime number ; Finding the matrix mapping by considering non prime number as obstacle and prime number be valid path . ; Sieve ; If prime ; if non prime ; Driver code
",0
534,"declare findNthNonSquare with integer n, long double x assign to long double, n
create long double ans with ans assign to x + floor ( 0.5 + sqrt ( x ) ) )
return ( integer ) ans
declare integer main ( ) and integer n assign to 16
print "" The "", n, "" th Non - Square number is ""
print findNthNonSquare ( n )
return 0
","Nth non 
 CPP program to find n - th non - square number . ; function to find the nth Non - Square Number ; conversion from int to long double is necessary in order to preserve decimal places after square root . ; calculating the result ; Driver code ; initializing the term number ; Print the result
",1
535,"declare findNthNonSquare with integer n, long double x assign to long double, n
create long double ans with ans assign to x + floor ( 0.5 + sqrt ( x ) ) )
return ( integer ) ans
declare integer main ( ) and integer n assign to 16
print "" The "", n, "" th Non - Square number is ""
print findNthNonSquare ( n )
return 0
","Sum of division of the possible pairs untill the given Array 
 C ++ implementation to compute the sum of division of all the possible pairs untill the given array ; Function to compute the sum ; counting frequency of each term and finding maximum among it ; Making cumulative frequency ; Taking the ceil value ; nos . in array of ( n - 0.5 ) X , ( n + 0.5 ) X ) range will add n to the ans ; Return the final result ; Driver code
",0
536,"declare seiresSum with integers n, a array of  , return n * ( a array of 0   * a array of 0   - a array of 2 * n - 1   * a array of 2 * n - 1   ) / ( 2 * n - 1) )
declare integer main ( ) and integer n assign to 2
create integer a with a assign to  1, 2, 3, 4
print seiresSum ( n, a )
return 0
","Sum of series with alternate signed squares of AP 
 Efficient CPP program to find sum of series with alternate signed square AP sums . ; function to calculate series sum ; Driver code
",1
537,"declare seiresSum with integers n, a array of  , return n * ( a array of 0   * a array of 0   - a array of 2 * n - 1   * a array of 2 * n - 1   ) / ( 2 * n - 1) )
declare integer main ( ) and integer n assign to 2
create integer a with a assign to  1, 2, 3, 4
print seiresSum ( n, a )
return 0
","Maximize the decimal equivalent by flipping only a contiguous set of 0 s 
 C ++ implementation to Maximize the value of the decimal equivalent given in the binary untillm ; Function to print the binary number ; Check if the current number is 0 ; Find the continuous 0 s ; Replace initially occurring 0 with 1 ; Break out of loop if 1 occurs ; Driver code
",0
538,"declare checkdigit with integers n, k, untill n is true, rem assign to n modulo 10
if rem is k, return 1
set n to n / 10
return 0
untill i assign to k + 1 to n exclusive, increment count by 1 if checkdigit ( i, k ) or ( i % k is 0 ) increment count
if count is n return i
return -1
declare integer main ( ), integers n assign to 10 and k assign to 2
print findNthNumber ( n, k ) and a new line
return 0
","Find nth number that contains the digit k or divisible by k . 
 C ++ program to find nth number that contains the digit k or divisible by k . ; Function untill checking if digit k is in n or not ; finding remainder ; if digit found ; Function untill finding nth number ; since k is the first which satisfy the criteria , so consider it in count making count assign to 1 and starting from i assign to k + 1 ; checking that the number contain k digit or divisible by k ; Driver code
",1
539,"declare checkdigit with integers n, k, untill n is true, rem assign to n modulo 10
if rem is k, return 1
set n to n / 10
return 0
untill i assign to k + 1 to n exclusive, increment count by 1 if checkdigit ( i, k ) or ( i % k is 0 ) increment count
if count is n return i
return -1
declare integer main ( ), integers n assign to 10 and k assign to 2
print findNthNumber ( n, k ) and a new line
return 0
","Find maximum average subarray of k length 
 C ++ program to find maximum average subarray of given length . ; Returns beginning index of maximum average subarray of length ' k ' ; Check if ' k ' is valid ; Compute sum of first ' k ' elements ; Compute sum of remaining subarrays ; Return starting index ; Driver program
",0
540,"declare find_permutations ( vector  int > & arr )  int cnt assign to 0
create integers max_ind assign to -1, min_ind assign to 10000000
create integer n with n assign to size of arr
create an array of ints, ints with int value index_of
untill i assign to 0 to n exclusive, index_of array of arr array of i     assign to i + 1
untill i assign to 1 to n inclusive, set max_ind to max ( max_ind, index_of array of i   )
min_ind assign to min ( min_ind, index_of array of i   )
if max_ind - min_ind + 1 is i, increment cnt
return cnt
declare integer main ( ), vector, integer > nums
push_back nums
push_back nums. push_back ( 3 )
push_back nums
push_back nums. push_back ( 5 )
push_back nums. push_back ( 4 )
print find_permutations (nums)
return 0
","Count of subarrays of size K which is a permutation of numbers from 1 to K 
 C ++ program to implement the above approach ; Save index of numbers of the array ; Update min and max index with the current index and check if it 's a valid permutation ; Driver code
",1
541,"declare find_permutations ( vector  int > & arr )  int cnt assign to 0
create integers max_ind assign to -1, min_ind assign to 10000000
create integer n with n assign to size of arr
create an array of ints, ints with int value index_of
untill i assign to 0 to n exclusive, index_of array of arr array of i     assign to i + 1
untill i assign to 1 to n inclusive, set max_ind to max ( max_ind, index_of array of i   )
min_ind assign to min ( min_ind, index_of array of i   )
if max_ind - min_ind + 1 is i, increment cnt
return cnt
declare integer main ( ), vector, integer > nums
push_back nums
push_back nums. push_back ( 3 )
push_back nums
push_back nums. push_back ( 5 )
push_back nums. push_back ( 4 )
print find_permutations (nums)
return 0
","Find the two numbers with odd occurrences in an unsorted array 
 C ++ Program to find the two odd occurring elements ; Prints two numbers that occur odd number of times . The function assumes that the array size is at least 2 and there are exactly two numbers occurring odd number of times . ; Will hold XOR of two odd occurring elements ; Will have only single set bit of xor2 ; Get the xor of all elements in arr array of   . The xor will basically be xor of two odd occurring elements ; Get one set bit in the xor2 . We get rightmost set bit in the following line as it is easy to get ; Now divide elements in two sets : 1 ) The elements having the corresponding bit as 1. 2 ) The elements having the corresponding bit as 0. ; XOR of first set is finally going to hold one odd occurring number x ; XOR of second set is finally going to hold the other odd occurring number y ; Driver code
",0
542,"declare getCount with integer a array of  , integer n, gcd assign to 0
untill i assign to 0 to n exclusive, set gcd to __gcd ( gcd, a array of i   )
cnt assign to integer with cnt assign to 0
untill i assign to 1 to i * i assign to gcd ; i ++ ) if gcd modulo i is 0, if i * i is gcd, increment cnt
else cnt assign to cnt + 2
return cnt
declare integer main ( ), integer array a with size   assign to  4, 16, 1024, 48
create integer n with n assign to sizeof ( a ) / sizeof ( a array of 0   )
print getCount ( a, n )
return 0
","Count of integers that divide all the elements of the given array 
 C ++ implementation of the approach ; Function to return the count of the required integers ; To store the gcd of the array elements ; To store the count of factors of the found gcd ; If g is a perfect square ; Factors appear in pairs ; Driver code
",1
543,"declare getCount with integer a array of  , integer n, gcd assign to 0
untill i assign to 0 to n exclusive, set gcd to __gcd ( gcd, a array of i   )
cnt assign to integer with cnt assign to 0
untill i assign to 1 to i * i assign to gcd ; i ++ ) if gcd modulo i is 0, if i * i is gcd, increment cnt
else cnt assign to cnt + 2
return cnt
declare integer main ( ), integer array a with size   assign to  4, 16, 1024, 48
create integer n with n assign to sizeof ( a ) / sizeof ( a array of 0   )
print getCount ( a, n )
return 0
","Program to find the area of a Square 
 CPP program to find the area of a square ; function to find the area ; Driver program
",0
544,"declare delCost with string s, int cost array of  , int l1, int l2 as arguments, returning boolean visited array of l1  
set all contents of visited to 0
ans assign to integer with ans assign to 0
untill i assign to 0 to l1 exclusive, if visited array of i   is true, continue
create integer maxDel with maxDel assign to 0
declare integer totalCost assign to 0
visited array of i   assign to 1
untill j assign to i to l1 exclusive, set maxDel to max of maxDel and cost of j to maxDel
increase totalCost by cost array of j  
visited array ofj   assign to 1
increment ans by totalCost - maxDel
return ans
declare integer main ( ) and string s assign to AAABBB
create integer l1 with l1 assign to size of s
cost assign to integer with cost assign to  1, 2, 3, 4, 5, 6  ;
create integer l2 with l2 assign to sizeof ( cost ) / sizeof ( cost array of 0   )
print delCost ( s, cost, l1, l2 )
return 0
","Minimize cost of removals required to make all remaining characters of the string unique 
 C ++ program to implement the above approach ; Function to find the minimum cost of removing characters to make the String unique ; stores the visited character ; stores the answer ; traverse the String ; if already visited ; Stores the maximum cost of removing a particular character ; Store the total deletion cost of a particular character ; Mark the current character visited ; Traverse the indices of the String array of i , N - 1   ; If any duplicate is found ; Update the maximum cost and total cost ; Mark the current character visited ; Keep the character with maximum cost and delete the rest ; return the minimum cost ; Driver code ; input String ; input array ; function call
",1
545,"declare delCost with string s, int cost array of  , int l1, int l2 as arguments, returning boolean visited array of l1  
set all contents of visited to 0
ans assign to integer with ans assign to 0
untill i assign to 0 to l1 exclusive, if visited array of i   is true, continue
create integer maxDel with maxDel assign to 0
declare integer totalCost assign to 0
visited array of i   assign to 1
untill j assign to i to l1 exclusive, set maxDel to max of maxDel and cost of j to maxDel
increase totalCost by cost array of j  
visited array ofj   assign to 1
increment ans by totalCost - maxDel
return ans
declare integer main ( ) and string s assign to AAABBB
create integer l1 with l1 assign to size of s
cost assign to integer with cost assign to  1, 2, 3, 4, 5, 6  ;
create integer l2 with l2 assign to sizeof ( cost ) / sizeof ( cost array of 0   )
print delCost ( s, cost, l1, l2 )
return 0
","Queries to count array elements greater than or equal to a given number with updates 
 C ++ program untill the above approach ; Function to build a segment tree ; Check untill base case ; Find mid point ; Recursively build the segment tree ; Function untill push down operation on the segment tree ; Function to update the segment tree ; Complete overlap ; Find mid ; Peruntillm push down operation on segment tree ; Recursively update the segment tree ; Function to process the query ; Base case ; Find mid ; Peruntillm push down operation on segment tree ; Recursively calculate the result of the query ; Return the result ; Function to count the numbers which are greater than the given query ; Sort the input array ; Create segment tree of size 4 * n ; Build the segment tree ; Iterate over the queries ; Store result in array ; Update the elements in the given range ; Print the result of queries ; Driver Code ; Function Call
",0
546,"if N modulo 2 is 0, set checkXOR to 0
untill i assign to 0 to N exclusive, set xro to arr array of i  
if xro is not 0, print -1
return
untill i assign to 0 to N - 3 exclusive, print i, "" "", i + 1, "" "", i + 2 print newline
untill i assign to 0 to N - 3 exclusive, print i, "" "", i + 1, "" "", N - 1 and a new line
print i, N - 2, "" "", i + 1 and "" "" and i + 2
untill i assign to 0 to N - 2 exclusive, print i, "" "", i + 1, "" "", N - 1 and a new line
declare integer array arr size   assign to  4, 2, 1, 7, 2  ; declare integer
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
checkXOR assign to arr, N
","Make all array elements equal by replacing triplets with their Bitwise XOR 
 C ++ program to implement the above approach ; Function to find triplets such that replacing them with their XOR make all array elements equal ; If N is even ; Calculate xor of array elements ; Traverse the array ; Update xor ; If xor is not equal to 0 ; Selecting the triplets such that elements of the pairs ( arr array of 0   , arr array of 1   ) , ( arr array of 2   , arr array of 3   ) . . . can be made equal ; Selecting the triplets such that all array elements can be made equal to arr array of N - 1   ; Selecting the triplets such that elements of the pairs ( arr array of 0   , arr array of 1   ) , ( arr array of 2   , arr array of 3   ) . . . can be made equal ; Selecting the triplets such that all array elements can be made equal to arr array of N - 1   ; Driver Code ; Given array ; Size of array ; Function call
",1
547,"if N modulo 2 is 0, set checkXOR to 0
untill i assign to 0 to N exclusive, set xro to arr array of i  
if xro is not 0, print -1
return
untill i assign to 0 to N - 3 exclusive, print i, "" "", i + 1, "" "", i + 2 print newline
untill i assign to 0 to N - 3 exclusive, print i, "" "", i + 1, "" "", N - 1 and a new line
print i, N - 2, "" "", i + 1 and "" "" and i + 2
untill i assign to 0 to N - 2 exclusive, print i, "" "", i + 1, "" "", N - 1 and a new line
declare integer array arr size   assign to  4, 2, 1, 7, 2  ; declare integer
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
checkXOR assign to arr, N
","Find the peak index of a given array 
 C ++ program untill the above approach ; Function to find the peak index untill the given array ; Base Case ; Check untill strictly increasing array ; If the strictly increasing condition is violated , then break ; Stores the value of i , which is a potential peak index ; Second traversal , untill strictly decreasing array ; When the strictly decreasing condition is violated , then break ; If i assign to N - 1 , it means that ans is the peak index ; Otherwise , peak index doesn 't exist ; Driver Code
",0
548,"create integer make_array_element_even ( int arr array of  , int N )  int res assign to 0
odd_cont_seg assign to integer with odd_cont_seg assign to 0
untill i assign to 0 to N exclusive, increment odd_cont_seg by 1
else if odd_cont_seg is greater than 0, if odd_cont_seg is even, increment res by odd_cont_seg / 2
else res assign to res + ( odd_cont_seg / 2 ) + 2
odd_cont_seg assign to 0
if odd_cont_seg is greater than 0, increment res by odd_cont_seg / 2
else res assign to res + odd_cont_seg / 2 + 2
return res
declare integer main ( ), integer arr array of   assign to  2, 4, 5, 11, 6  ;
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print make_array_element_even ( arr, N )
return 0
","Make all array elements even by replacing adjacent pair of array elements with their sum 
 C ++ program to implement the above approach ; Function to find minimum count of operations required to make all array elements even ; Stores minimum count of replacements to make all array elements even ; Stores the count of odd continuous numbers ; Traverse the array ; If arr array of i   is an odd number ; Update odd_cont_seg ; If odd_cont_seg is even ; Update res ; Update res ; Reset odd_cont_seg assign to 0 ; If odd_cont_seg exceeds 0 ; If odd_cont_seg is even ; Update res ; Update res ; Print the result ; Drivers Code
",1
549,"create integer make_array_element_even ( int arr array of  , int N )  int res assign to 0
odd_cont_seg assign to integer with odd_cont_seg assign to 0
untill i assign to 0 to N exclusive, increment odd_cont_seg by 1
else if odd_cont_seg is greater than 0, if odd_cont_seg is even, increment res by odd_cont_seg / 2
else res assign to res + ( odd_cont_seg / 2 ) + 2
odd_cont_seg assign to 0
if odd_cont_seg is greater than 0, increment res by odd_cont_seg / 2
else res assign to res + odd_cont_seg / 2 + 2
return res
declare integer main ( ), integer arr array of   assign to  2, 4, 5, 11, 6  ;
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print make_array_element_even ( arr, N )
return 0
","Length of longest common prefix possible by rearranging strings in a given array 
 C ++ program to implement the above approach ; Function to get the length of the longest common prefix by rearranging the strings ; freq array of i   array of j   : stores the frequency of a character ( assign to j ) in a string arr array of i   ; Traverse the given array ; Stores length of current string ; Traverse current string of the given array ; Update the value of freq array of i   array of arr array of i   array of j     ; Stores the length of longest common prefix ; Count the minimum frequency of each character in in all the strings of arr array of   ; Stores minimum value in each row of freq array of   array of   ; Calculate minimum frequency of current character in all the strings . ; Update minRowVal ; Update maxLen ; Driver Code
",0
550,"declare integer variable zvalue with vector  integer > & nums, integer m assign to * max_element ( nums. begin ( ), nums. end ( ) ) )
cnt assign to integer with cnt assign to 0
untill i assign to 0 to m inclusive, set cnt to 0
untill j assign to 0 to size of nums, increment j by 1 if nums array ofj   >assign to i, increment cnt
if cnt is i return i
return -1
declare integer main ( ), vector, integer nums assign to  7, 8, 9, 0, 0, 1  nums
print zvalue (nums) print newline
","Find a number K such that exactly K array elements are greater than or equal to K 
 C ++ program untill the above approach ; Function to find K untill which there are exactly K array elements greater than or equal to K ; Finding the largest array element ; Possible values of K ; Traverse the array ; If current array element is greater than or equal to i ; If i array elements are greater than or equal to i ; Otherwise ; Driver Code
",1
551,"declare integer variable zvalue with vector  integer > & nums, integer m assign to * max_element ( nums. begin ( ), nums. end ( ) ) )
cnt assign to integer with cnt assign to 0
untill i assign to 0 to m inclusive, set cnt to 0
untill j assign to 0 to size of nums, increment j by 1 if nums array ofj   >assign to i, increment cnt
if cnt is i return i
return -1
declare integer main ( ), vector, integer nums assign to  7, 8, 9, 0, 0, 1  nums
print zvalue (nums) print newline
","Check if all substrings of length K of a Binary String has equal count of 0 s and 1 s 
 C ++ program untill the above approach ; Function to check if the substring of length K has equal 0 and 1 ; Traverse the string ; Check if every K - th character is the same or not ; Traverse substring of length K ; If current character is 0 ; Increment count ; Otherwise ; Decrement count ; Check untill equal 0 s and 1 s ; Driver code
",0
552,"pair  string, integer > lexico_smallest ( string s1, string s2 ), map, integer > M
set  char > S
create pair  string, integer > pr
untill i assign to 0 to size of s1 - 1 inclusive, increment M array of s1 array of i     
insert s1 array of i  ) into S
untill i assign to 0 to size of s2 - 1 inclusive, M array of s2 array of i     --
c assign to s2 array of 0  
index assign to integer with index assign to 0
res assign to string with res assign to "" ""
untill x : S, if x is not c, increment res by x
else j assign to integer with j assign to 0
index assign to size of res
untill s2 array ofj  is x, increment j
if s2 array ofj  is less than c, increment res by s2
untill i assign to 1 to M array of x   inclusive, increment res by x
else untill i assign to 1 to M array of x  , increment res by x
increment index by M array of x  
increment res by s2
first assign to res
set pr. second to index
return pr
lexico_largest is a new string array of strings s1, s2 and pair of strings, pr assign to lexico_smallest (s1, s2 )
d1 assign to string with d1 assign to "" ""
untill i assign to second - 1 to 0 inclusive, increment d1 by first array of i  
d2 assign to string with d2 assign to "" ""
untill i assign to pr. first. size ( ) - 1 to second + s2. size ( ), -- i )  d2 + pr. first array of i  
res assign to d2 + s2 + d1
return res
declare integer main ( ), string s1 assign to "" ethgakagmenpgs ""
s2 assign to string with s2 assign to geeks
print lexico_smallest ( s1, s2 ) print "" STRNEWLINE ""
print lexico_largest ( s1, s2 )
return ( 0 )
","Lexicographically smallest and largest anagrams of a string containing another string as its substring 
 C ++ program untill the above approach ; Function to find the lexicographically smallest anagram of string which contains another string ; Initializing the map and set ; Iterating over s1 ; Storing the frequency of characters present in s1 ; Storing the distinct characters present in s1 ; Decreasing the frequency of characters from M that are already present in s2 ; Traversing alphabets in sorted order ; If current character of set is not equal to current character of s2 ; If element is equal to current character of s2 ; Checking untill second distinct character in s2 ; s2 array of j   will store second distinct character ; Return the answer ; Function to find the lexicographically largest anagram of string which contains another string ; Getting the lexicographically smallest anagram ; d1 stores the prefix ; d2 stores the suffix ; Return the result ; Driver Code ; Given two strings ; Function Calls
",1
553,"pair  string, integer > lexico_smallest ( string s1, string s2 ), map, integer > M
set  char > S
create pair  string, integer > pr
untill i assign to 0 to size of s1 - 1 inclusive, increment M array of s1 array of i     
insert s1 array of i  ) into S
untill i assign to 0 to size of s2 - 1 inclusive, M array of s2 array of i     --
c assign to s2 array of 0  
index assign to integer with index assign to 0
res assign to string with res assign to "" ""
untill x : S, if x is not c, increment res by x
else j assign to integer with j assign to 0
index assign to size of res
untill s2 array ofj  is x, increment j
if s2 array ofj  is less than c, increment res by s2
untill i assign to 1 to M array of x   inclusive, increment res by x
else untill i assign to 1 to M array of x  , increment res by x
increment index by M array of x  
increment res by s2
first assign to res
set pr. second to index
return pr
lexico_largest is a new string array of strings s1, s2 and pair of strings, pr assign to lexico_smallest (s1, s2 )
d1 assign to string with d1 assign to "" ""
untill i assign to second - 1 to 0 inclusive, increment d1 by first array of i  
d2 assign to string with d2 assign to "" ""
untill i assign to pr. first. size ( ) - 1 to second + s2. size ( ), -- i )  d2 + pr. first array of i  
res assign to d2 + s2 + d1
return res
declare integer main ( ), string s1 assign to "" ethgakagmenpgs ""
s2 assign to string with s2 assign to geeks
print lexico_smallest ( s1, s2 ) print "" STRNEWLINE ""
print lexico_largest ( s1, s2 )
return ( 0 )
","Construct original array starting with K from an array of XOR of all elements except elements at same index 
 C ++ program untill the above approach ; Function to construct an array with each element equal to XOR of all array elements except the element at the same index ; Original array ; Stores Bitwise XOR of array ; Calculate XOR of all array elements ; Print the original array B array of   ; Driver Code ; Function Call
",0
554,"create constant integer sz with sz assign to 1e5
create vector  integer > tree array of sz  
create integer n
vis assign to bool array of size sz
subtreeSize assign to integer array of size sz
create void addEdge ( int a, int b )  tree array of a   push_back ( b )
push_back ( a ) is a tree array with b elements
dfs assign to int x, vis assign to int x, vis assign to true
subtreeSize array ofx   assign to 1
untill i : tree array of x   ) if vis array of i   is not 0, then do the following dfs ( i )
increment subtreeSize array of x   by subtreeSize array of i  
declare countPairs with integers a, b as arguments, sub assign to min ( subtreeSize array of a , subtreeSize array of b   )
print sub * ( n - sub ) print newline
declare integer main ( ) and n assign to 6
addEdge assign to 0, 1
addEdge assign to 0, 2
addEdge assign to 1, 3
addEdge assign to 3, 4
addEdge assign to 3, 5
dfs assign to 0
countPairs assign to 1, 3
countPairs assign to 0, 2
return 0
","Queries to find the count of shortest paths in a Tree that contains a given edge 
 C ++ implementation untill the above approach ; Adjacency list to represent the tree ; Number of vertices ; Mark visited / unvisited vertices ; Stores the subtree size of the corresponding nodes ; Function to create an edge between two vertices ; Add a to b 's list ; Add b to a 's list ; Function to peruntillm DFS ; Mark the vertex visited ; Include the node in the subtree ; Traverse all its children ; Function to print the required number of paths ; Driver Code ; Number of vertices ; Calling modified dfs function ; Count pairs of vertices in the tree
",1
555,"create constant integer sz with sz assign to 1e5
create vector  integer > tree array of sz  
create integer n
vis assign to bool array of size sz
subtreeSize assign to integer array of size sz
create void addEdge ( int a, int b )  tree array of a   push_back ( b )
push_back ( a ) is a tree array with b elements
dfs assign to int x, vis assign to int x, vis assign to true
subtreeSize array ofx   assign to 1
untill i : tree array of x   ) if vis array of i   is not 0, then do the following dfs ( i )
increment subtreeSize array of x   by subtreeSize array of i  
declare countPairs with integers a, b as arguments, sub assign to min ( subtreeSize array of a , subtreeSize array of b   )
print sub * ( n - sub ) print newline
declare integer main ( ) and n assign to 6
addEdge assign to 0, 1
addEdge assign to 0, 2
addEdge assign to 1, 3
addEdge assign to 3, 4
addEdge assign to 3, 5
dfs assign to 0
countPairs assign to 1, 3
countPairs assign to 0, 2
return 0
","Maximum possible remainder when an element is divided by other element in the array 
 C ++ implementation of the approach ; Function to return the maximum mod value untill any pair from the array ; Find the second maximum element from the array ; Driver code
",0
556,"declare findPermutation with an ints > and arr, N, pos assign to arr size ( ) + 1
if pos is greater than N, return 1
create integer res with res assign to 0
untill i assign to 1 to N inclusive, insert i into arr
increment res by findPermutation ( arr, N )
erase ( arr. find ( i ) ) )
return res
declare integer main ( ) and integer N assign to 5
set int to int > arr
print findPermutation ( arr, N )
return 0
","Count of permutations of an Array having each element as a multiple or a factor of its index 
 C ++ Program to implement the above approach ; Function to find the count of desired permutations ; Base case ; If i has not been inserted ; Backtrack ; Insert i ; Recur to find valid permutations ; Remove i ; Return the final count ; Driver Code
",1
557,"declare findPermutation with an ints > and arr, N, pos assign to arr size ( ) + 1
if pos is greater than N, return 1
create integer res with res assign to 0
untill i assign to 1 to N inclusive, insert i into arr
increment res by findPermutation ( arr, N )
erase ( arr. find ( i ) ) )
return res
declare integer main ( ) and integer N assign to 5
set int to int > arr
print findPermutation ( arr, N )
return 0
","Sum of prime numbers in range array of L , R   from given Array untill Q queries 
 C ++ program untill the above approach ; Function to find the prime numbers ; Create a boolean array prime array of   and initialize all entries it as true A value in prime array of i   will finally be false if i is Not a prime ; Check if prime array of p   is not changed , then it is a prime ; Update all multiples of p greater than or equal to the square of it numbers which are multiple of p and are less than p to the power 2 are already been marked ; Function to get the middle index from corner indexes ; Function to get the sum of values in the given range of the array ; If segment of this node is a part of given range , then return the sum of the segment ; If segment of this node is outside the given range ; If a part of this segment overlaps with the given range ; Function to update the nodes which have the given index in their range ; If the input index lies outside the range of this segment ; If the input index is in range of this node , then update the value of the node and its children ; Function to update a value in input array and segment tree ; Check untill erroneous input index ; Get the difference between new value and old value ; Update the value in array ; Update the values of nodes in segment tree only if either previous value or new value or both are prime ; If only new value is prime ; If only new value is prime ; If both are prime ; Return sum of elements in range from index qs ( query start ) to qe ( query end ) . It mainly uses getSumUtil ( ) ; Check untill erroneous input values ; Function that constructs Segment Tree ; If there is one element in array , store it in current node of segment tree and return ; Only add those elements in segment tree which are prime ; If there are more than one elements , then recur untill left and right subtrees and store the sum of values in this node ; Function to construct segment tree from given array ; Height of segment tree ; Maximum size of segment tree ; Allocate memory ; Fill the allocated memory st ; Return the constructed segment tree ; Driver code ; Function call ; Build segment tree from given array ; Print sum of values in array from index 1 to 3 ; Update : set arr array of 1   assign to 10 and update corresponding segment tree nodes ; Find sum after the value is updated
",0
558,"declare solve with integer arr array of  , integer n, integer X, integer Y, diff assign to Y - X as arguments, returning void
untill i assign to 0 to n exclusive, diff assign to diff modulo ( arr array of i   - 1)
if diff is 0, print Yes
else print No
declare integer main ( ), integer arr array of   assign to  1, 2, 7, 9, 10  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create integers X, Y with X assign to 11 and Y assign to 13
solve ( arr, n, X, Y )
return 0
","Check if sum Y can be obtained from the Array by the given operations 
 C ++ Program to implement the above approach ; Function to check if it is possible to obtain sum Y from a sequence of sum X from the array arr array of   ; Store the difference ; Iterate over the array ; If diff reduced to 0 ; Driver Code
",1
559,"declare solve with integer arr array of  , integer n, integer X, integer Y, diff assign to Y - X as arguments, returning void
untill i assign to 0 to n exclusive, diff assign to diff modulo ( arr array of i   - 1)
if diff is 0, print Yes
else print No
declare integer main ( ), integer arr array of   assign to  1, 2, 7, 9, 10  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create integers X, Y with X assign to 11 and Y assign to 13
solve ( arr, n, X, Y )
return 0
","Program to find Normal and Trace of a matrix 
 C ++ program to find trace and normal of given matrix ; Size of given matrix ; Returns Normal of a matrix of size n x n ; Returns trace of a matrix of size n x n ; Driven source
",0
560,"create vector  integer > adj array of maxN 
create integer height array of maxN 
dist assign to integer array of size maxN
declare addEdge with integers u, v as arguments, returning adj array of u   and push_back ( v ) as arguments
push_back ( u ) is adj array of v  
void function dfs1 with int arguments cur and par that returns void, if u is not par, then dfs1 with u, cur arguments
set height array of cur  to max ( height array of cur , height array of u   )
increment height array of cur  by 1
declare dfs2 with cur, par as arguments, set max1 to 0
create integer max2 with max2 assign to 0
untill u : adj array of cur  ) if u is not par, if height array of u   is greater than or equal to max1, max2 assign to max1
set max1 to height array of u  
else if height array of u   is greater than max2, max2 assign to height array of u  
sum assign to 0
untill u : adj array of cur  ) if u is not par, sum assign to ( max1 assign to height array of u   )? max2 : max1 )
if max1 is height array of u   dist array of u   assign to 1 + max ( 1 + max2, dist array of cur   )
else dist array of u   assign to 1 + max ( 1 + max1, dist array of cur   )
dfs2 assign to u, cur
n assign to 6 assign to int
addEdge assign to 1, 2
addEdge assign to 2, 3
addEdge assign to 2, 4
addEdge assign to 2, 5
addEdge assign to 5, 6
dfs1 assign to 1, 0
dfs2 assign to 1, 0
untill i assign to 1 to n inclusive, print max ( dist array of i , height array of i   ) - 1 ) and "" ""
return 0
","Farthest distance of a Node from each Node of a Tree 
 C ++ Program to implement the above approach ; Adjacency List to store the graph ; Stores the height of each node ; Stores the maximum distance of a node from its ancestors ; Function to add edge between two vertices ; Insert edge from u to v ; Insert edge from v to u ; Function to calculate height of each Node ; Iterate in the adjacency list of the current node ; Dfs untill child node ; Calculate height of nodes ; Increase height ; Function to calculate the maximum distance of a node from its ancestor ; Iterate in the adjacency list of the current node ; Find two children with maximum heights ; Calculate the maximum distance with ancestor untill every node ; Calculating untill children ; Driver Code ; Calculate height of nodes of the tree ; Calculate the maximum distance with ancestors ; Print the maximum of the two distances from each node
",1
561,"create vector  integer > adj array of maxN 
create integer height array of maxN 
dist assign to integer array of size maxN
declare addEdge with integers u, v as arguments, returning adj array of u   and push_back ( v ) as arguments
push_back ( u ) is adj array of v  
void function dfs1 with int arguments cur and par that returns void, if u is not par, then dfs1 with u, cur arguments
set height array of cur  to max ( height array of cur , height array of u   )
increment height array of cur  by 1
declare dfs2 with cur, par as arguments, set max1 to 0
create integer max2 with max2 assign to 0
untill u : adj array of cur  ) if u is not par, if height array of u   is greater than or equal to max1, max2 assign to max1
set max1 to height array of u  
else if height array of u   is greater than max2, max2 assign to height array of u  
sum assign to 0
untill u : adj array of cur  ) if u is not par, sum assign to ( max1 assign to height array of u   )? max2 : max1 )
if max1 is height array of u   dist array of u   assign to 1 + max ( 1 + max2, dist array of cur   )
else dist array of u   assign to 1 + max ( 1 + max1, dist array of cur   )
dfs2 assign to u, cur
n assign to 6 assign to int
addEdge assign to 1, 2
addEdge assign to 2, 3
addEdge assign to 2, 4
addEdge assign to 2, 5
addEdge assign to 5, 6
dfs1 assign to 1, 0
dfs2 assign to 1, 0
untill i assign to 1 to n inclusive, print max ( dist array of i , height array of i   ) - 1 ) and "" ""
return 0
","Form minimum number from given sequence 
 C ++ program of above approach ; Returns minimum number made from given sequence without repeating digits ; The loop runs untill each input character as well as one additional time untill assigning rank to remaining characters ; Driver Code
",0
562,"if ( a, b, c )  integer middleOfThree ( a, b, c )  if ( a  b and b  c )  if ( a  b and b  c ) ), return b from function
else if b is less than a and a is less than c or c is less than a and a is less than b, return a
else return c
declare integer main ( ), integers a assign to 20, b assign to 30, c assign to 40
print middleOfThree ( a, b, c )
return 0
","Middle of three using minimum comparisons 
 CPP program to find middle of three distinct numbers ; Function to find the middle of three number ; Checking untill b ; Checking untill a ; Driver Code
",1
563,"if ( a, b, c )  integer middleOfThree ( a, b, c )  if ( a  b and b  c )  if ( a  b and b  c ) ), return b from function
else if b is less than a and a is less than c or c is less than a and a is less than b, return a
else return c
declare integer main ( ), integers a assign to 20, b assign to 30, c assign to 40
print middleOfThree ( a, b, c )
return 0
","Split an array into subarrays with maximum Bitwise XOR of their respective Bitwise OR values 
 C ++ program untill the above approach ; Function to find the bitwise OR of array elements ; Stores the resultant maximum value of Bitwise XOR ; Traverse the array arr array of   ; Return the maximum value res ; Driver Code
",0
564,"declare swap with integers * xp, yp, temp assign to * xp as arguments, returning integer
* xp assign to * yp
set yp to temp
declare selectionSort with integer arr array of  , integer n, integers i, j, min_idx
untill i assign to 0 to n - 1 exclusive, min_idx assign to i
untill j assign to i + 1 to n exclusive, if arr array ofj   arr array of min_idx  , min_idx assign to j
swap & arr array of min_idx , & arr array of i  
printArray is a new array of integers arr, size and i
untill i assign to 0 to size exclusive, print arr array of i  and "" ""
print a new line
declare integer main ( ), integer arr assign to  64, 25, 12, 22, 11  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
call selectionSort ( arr, n )
print Sorted array : STRNEWLINE
printArray ( arr, n )
return 0
","Difference between Insertion sort and Selection sort 
 C ++ program untill implementation of selection sort ; Function to implement the selection sort ; One by one move boundary of unsorted subarray ; Find the minimum element in unsorted array ; Swap the found minimum element with the first element ; Function to print an array ; Driver Code ; Function Call ; Print the array
",1
565,"declare swap with integers * xp, yp, temp assign to * xp as arguments, returning integer
* xp assign to * yp
set yp to temp
declare selectionSort with integer arr array of  , integer n, integers i, j, min_idx
untill i assign to 0 to n - 1 exclusive, min_idx assign to i
untill j assign to i + 1 to n exclusive, if arr array ofj   arr array of min_idx  , min_idx assign to j
swap & arr array of min_idx , & arr array of i  
printArray is a new array of integers arr, size and i
untill i assign to 0 to size exclusive, print arr array of i  and "" ""
print a new line
declare integer main ( ), integer arr assign to  64, 25, 12, 22, 11  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
call selectionSort ( arr, n )
print Sorted array : STRNEWLINE
printArray ( arr, n )
return 0
","Modify array to another given array by replacing array elements with the sum of the array 
 CPP program to implement the above approach ; Function to check if the arr array of   can be converted to target array of   by replacing any element in arr array of   by the sum of arr array of   ; Store the maximum element ; Store the index of the maximum element ; Traverse the array target array of   ; If current element is greater than max ; If max element is 1 ; Traverse the array , target array of   ; If current index is not equal to maximum element index ; Update max ; If max is less than or equal to 0 , ; Update the maximum element ; Recursively call the function ; Driver Code ; Size of the array
",0
566,"declare checkStr1CanConStr2 with string & str1, string & str2 as arguments, returning integer N assign to str1. length ( )
declare integer M assign to length of str2
set  integer > st1
set  integer > st2
create integer hash1 with hash1 assign to 256, set to 0, 0, 0
untill i assign to 0 to N exclusive, increment hash1 array of str1 array of i   by 1
untill i assign to 0 to N exclusive, insert str1 array of i  into st1
untill i assign to 0 to M exclusive, insert str2 array of i  into st2
if st1 is not st2 return false
create integer hash2 with hash2 assign to 256, set to 0, 0, 0
untill i assign to 0 to M exclusive, increment hash2 array of str2 array of i   by 1
sort ( hash1, hash1 + 256 )
sort hash2, hash2 + 256
untill i assign to 0 to 256 exclusive, return false if hash1 array of i   is not hash2 array of i  
return true
declare integer main ( ), string str1 assign to "" xyyzzlll ""
create string str2 with str2 assign to "" yllzzxxx ""
if checkStr1CanConStr2 ( str1, str2 ) ) print True
else print False
print a newlin
","Check if a given string can be converted to another by given possible swaps 
 C ++ program to implement the above approach ; Stores length of str1 ; Stores length of str2 ; Stores distinct characters of str1 ; Stores distinct characters of str2 ; Stores frequency of each character of str1 ; Traverse the string str1 ; Update frequency of str1 array of i   ; Traverse the string str1 ; Insert str1 array of i   into st1 ; Traverse the string str2 ; Insert str1 array of i   into st1 ; If distinct characters in str1 and str2 are not same ; Stores frequency of each character of str2 ; Traverse the string str2 ; Update frequency of str2 array of i   ; Sort hash1 array of   array ; Sort hash2 array of   array ; Traverse hash1 array of   and hash2 array of   ; If hash1 array of i   not equal to hash2 array of i   ; Driver Code
",1
567,"declare checkStr1CanConStr2 with string & str1, string & str2 as arguments, returning integer N assign to str1. length ( )
declare integer M assign to length of str2
set  integer > st1
set  integer > st2
create integer hash1 with hash1 assign to 256, set to 0, 0, 0
untill i assign to 0 to N exclusive, increment hash1 array of str1 array of i   by 1
untill i assign to 0 to N exclusive, insert str1 array of i  into st1
untill i assign to 0 to M exclusive, insert str2 array of i  into st2
if st1 is not st2 return false
create integer hash2 with hash2 assign to 256, set to 0, 0, 0
untill i assign to 0 to M exclusive, increment hash2 array of str2 array of i   by 1
sort ( hash1, hash1 + 256 )
sort hash2, hash2 + 256
untill i assign to 0 to 256 exclusive, return false if hash1 array of i   is not hash2 array of i  
return true
declare integer main ( ), string str1 assign to "" xyyzzlll ""
create string str2 with str2 assign to "" yllzzxxx ""
if checkStr1CanConStr2 ( str1, str2 ) ) print True
else print False
print a newlin
","Count of distinct pair sum between two 1 to N value Arrays 
 C ++ implementation to find count of distinct pair sum between two 1 to N value Arrays ; Function to find the distinct sums ; Driver code
",0
568,"declare partSort with integer arr array of  , N, a, b, l assign to min ( a, b ) as arguments, returning void
create integer r with r assign to max ( a, b )
create vector v with arr, arr + N elements
sort ( v. begin ( ) + l, v. begin ( ) + r + 1 )
untill i assign to 0 to N exclusive, print v array of i  and "" ""
declare integer main ( ), integer arr array of   assign to  7, 8, 4, 5, 2  ;
create integers a, b with a assign to 1 and b assign to 4
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
partSort is a new function
","Sort the array in a given index range 
 C ++ program to sort the array in a given index range ; Function to sort the elements of the array from index a to index b ; Variables to store start and end of the index range ; Sort the subarray from arr array of l   to arr array of r   ; Print the modified array ; Driver code
",1
569,"declare partSort with integer arr array of  , N, a, b, l assign to min ( a, b ) as arguments, returning void
create integer r with r assign to max ( a, b )
create vector v with arr, arr + N elements
sort ( v. begin ( ) + l, v. begin ( ) + r + 1 )
untill i assign to 0 to N exclusive, print v array of i  and "" ""
declare integer main ( ), integer arr array of   assign to  7, 8, 4, 5, 2  ;
create integers a, b with a assign to 1 and b assign to 4
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
partSort is a new function
","Encrypt the string 
 C ++ program untill the above approach ; Function to convert Decimal to Hex ; Function to encrypt the string ; Iterate the characters of the string ; Iterate until S array of i   is equal to ch ; Update count and i ; Decrement i by 1 ; Convert count to hexadecimal representation ; Append the character ; Append the characters frequency in hexadecimal representation ; Reverse the obtained answer ; Return required answer ; Driver Code ; Given Input ; Function Call
",0
570,"declare minCost as integer ( cost assign to   array of N   ) and dist assign to 0
untill i assign to 0 to N exclusive, dist array of i   assign to INF
dist array of 0   assign to 0
untill i assign to 0 to N exclusive, dist array ofj  is equal to dist array ofi  + cost array of i   array of j  , dist array ofj   is equal to dist array of i   + cost array of i   array of j  , increment dist array of j   by cost array of i   array of j    
return dist array of N - 1  
declare integer main ( ) and cost assign to  0, 15, 80, 90 , INF, 0, 40, 50 , INF, INF, 70 , INF, INF, INF, INF, 0, 0
print ""The Minimum cost to reach station "", N, is "" and minCost ( cost )
return 0
","Find the minimum cost to reach destination using a train 
 A Dynamic Programming based solution to find min cost to reach station N - 1 from station 0. ; This function returns the smallest possible cost to reach station N - 1 from station 0. ; dist array of i   stores minimum cost to reach station i from station 0. ; Go through every station and check if using it as an intermediate station gives better path ; Driver program to test above function
",1
571,"declare minCost as integer ( cost assign to   array of N   ) and dist assign to 0
untill i assign to 0 to N exclusive, dist array of i   assign to INF
dist array of 0   assign to 0
untill i assign to 0 to N exclusive, dist array ofj  is equal to dist array ofi  + cost array of i   array of j  , dist array ofj   is equal to dist array of i   + cost array of i   array of j  , increment dist array of j   by cost array of i   array of j    
return dist array of N - 1  
declare integer main ( ) and cost assign to  0, 15, 80, 90 , INF, 0, 40, 50 , INF, INF, 70 , INF, INF, INF, INF, 0, 0
print ""The Minimum cost to reach station "", N, is "" and minCost ( cost )
return 0
","Probability of distributing given balls into two halves having equal count of distinct colors 
 C ++ program untill the above approach ; Stores the count of distinct colors in box1 ; Stores the count of distinct colors in box2 ; Function to calculate the required probability ; Calculate factorial from array of 1 , 10   ; Assign all distinct balls to second box ; Total number of balls ; Calculate total number of balls ; If K is an odd number ; Total ways of distributing the balls in two equal halves ; Required number of ways ; Return the required probability ; Function to calculate total number of possible distributions which satisfies the given conditions ; If used balls is equal to K / 2 ; If box1 is equal to box2 ; Base condition ; Stores the number of ways of distributing remaining balls without including the current balls in box1 ; Increment box1 by one ; Iterate over the range array of 1 , balls array of i     ; If all the balls goes to box1 , then decrease box2 by one ; Total number of ways of selecting j balls ; Increment res by total number of valid ways of distributing the remaining balls ; Decrement box1 by one ; Increment box2 by 1 ; Function to calculate factorial of N ; Base Case ; Iterate over the range array of 1 , N   ; Function to calculate NcR ; Driver Code ; Print the result
",0
572,"declare integer numOfways ( integers n, k)  integer p assign to 1
if k modulo 2 is true, set p to -1
return ( pow ( n - 1, k ) + p * ( n - 1 ) ) / n
declare integer main ( ), integers n assign to 4 and k assign to 2
print numOfways ( n, k ) and a new line
return 0
","Number of loops of size k starting from a specific node 
 C ++ Program to find number of cycles of length k in a graph with n nodes . ; Return the Number of ways from a node to make a loop of size K in undirected complete connected graph of N nodes ; Driven Program
",1
573,"declare integer numOfways ( integers n, k)  integer p assign to 1
if k modulo 2 is true, set p to -1
return ( pow ( n - 1, k ) + p * ( n - 1 ) ) / n
declare integer main ( ), integers n assign to 4 and k assign to 2
print numOfways ( n, k ) and a new line
return 0
","Middle of three using minimum comparisons 
 CPP program to find middle of three distinct numbers ; Function to find the middle of three number ; Checking untill b ; Checking untill a ; Driver Code
",0
574,"create char max with max assign to'A'
untill i assign to 0 to n exclusive, if a array of i   > max, max assign to a array of i  
return max
smallest_alphabet assign to char ( a array of  , integer n ), min assign to 'z '
untill i assign to 0 to n - 1 exclusive, min assign to a array of i   if a array of i    min, min assign to a array of i  
return min
declare integer main ( ) and character a with a assign to "" GeEksuntillGeeks ""
size assign to integer with size assign to sizeof ( a ) / sizeof ( a array of 0   )
print "" Largest and smallest alphabet is : ""
print largest_alphabet ( a, size ) and "" and ""
print smallest_alphabet ( a, size ) print newline
return 0
","Program to find the largest and smallest ASCII valued characters in a string 
 C ++ program to find largest and smallest characters in a string . ; function that return the largest alphabet . ; initializing max alphabet to ' a ' ; find largest alphabet ; returning largest element ; function that return the smallest alphabet ; initializing smallest alphabet to ' z ' ; find smallest alphabet ; returning smallest alphabet ; Driver Code ; Character array ; Calculating size of the string ; calling functions and print returned value
",1
575,"create char max with max assign to'A'
untill i assign to 0 to n exclusive, if a array of i   > max, max assign to a array of i  
return max
smallest_alphabet assign to char ( a array of  , integer n ), min assign to 'z '
untill i assign to 0 to n - 1 exclusive, min assign to a array of i   if a array of i    min, min assign to a array of i  
return min
declare integer main ( ) and character a with a assign to "" GeEksuntillGeeks ""
size assign to integer with size assign to sizeof ( a ) / sizeof ( a array of 0   )
print "" Largest and smallest alphabet is : ""
print largest_alphabet ( a, size ) and "" and ""
print smallest_alphabet ( a, size ) print newline
return 0
","Check if N is a Factorial Prime 
 C ++ program to check if given number is a factorial prime ; Utility function to check if a number is prime or not ; Corner cases ; This is checked so that we can skip middle five numbers in below loop ; Function that returns true if n is a factorial prime ; If n is not prime then return false ; Calculate factorial ; If n is a factorial prime ; n is not a factorial prime ; Driver code
",0
576,"create string maximumPalinUsingKChanges ( string str, integer k )  string palin assign to str
l assign to integer with l assign to 0
r assign to length of str - 1
untill l  r, if str array of l  is not str array of r  , let palin array of l   be palin array of r   be max ( str array of l  , str array of r   )
decrement k
increment l
decrement r
if k is less than 0, return "" Not possible ""
set l to 0
set r to length of str - 1
untill l assign to r, if l is r, if k is greater than 0, let palin array of l   be '9'
if palin array of l  is less than 9 then k is greater than or equal to 2 and palin array of l   is str array of l   and palin array of r   is str array of r  , decrement k by 2
let palin array of l   be palin array of r   be '9'
else if k >assign to 1 and palin array of l not equal to str array of l  palin array of r  not equal to str array of r   ), k --
let palin array of l   be palin array of r   be '9'
increment l
decrement r
return palin
declare integer main ( ), string str assign to ""43435""
create integer k with k assign to 3
print maximumPalinUsingKChanges ( str, k )
return 0
","Make largest palindrome by changing at most K 
 C ++ program to get largest palindrome changing atmost K digits ; Returns maximum possible palindrome using k changes ; Initialize l and r by leftmost and rightmost ends ; first try to make string palindrome ; Replace left and right character by maximum of both ; If k is negative then we can 't make  string palindrome ; At mid character , if K > 0 then change it to 9 ; If character at lth ( same as rth ) is less than 9 ; If none of them is changed in the previous loop then subtract 2 from K and convert both to 9 ; If one of them is changed in the previous loop then subtract 1 from K ( 1 more is subtracted already ) and make them 9 ; Driver code to test above methods
",1
577,"create string maximumPalinUsingKChanges ( string str, integer k )  string palin assign to str
l assign to integer with l assign to 0
r assign to length of str - 1
untill l  r, if str array of l  is not str array of r  , let palin array of l   be palin array of r   be max ( str array of l  , str array of r   )
decrement k
increment l
decrement r
if k is less than 0, return "" Not possible ""
set l to 0
set r to length of str - 1
untill l assign to r, if l is r, if k is greater than 0, let palin array of l   be '9'
if palin array of l  is less than 9 then k is greater than or equal to 2 and palin array of l   is str array of l   and palin array of r   is str array of r  , decrement k by 2
let palin array of l   be palin array of r   be '9'
else if k >assign to 1 and palin array of l not equal to str array of l  palin array of r  not equal to str array of r   ), k --
let palin array of l   be palin array of r   be '9'
increment l
decrement r
return palin
declare integer main ( ), string str assign to ""43435""
create integer k with k assign to 3
print maximumPalinUsingKChanges ( str, k )
return 0
","Count subarrays having sum modulo K same as the length of the subarray 
 C ++ program of the above approach ; Function that counts the subarrays having sum modulo k equal to the length of subarray ; Stores the count of subarrays ; Stores prefix sum of the array ; Calculate prefix sum array ; Generate all the subarrays ; Check if this subarray is a valid subarray or not ; Total count of subarrays ; Driver Code ; Given arr array of   ; Size of the array ; Given K ; Function Call
",0
578,"declare integer variable countTriplets with vector  integer > & A, cnt assign to 0
create an array of ints, ints with int > tuples
untill a : A, untill b : A, increment tuples array of a & b  
untill a : A, if t. first & a ) is 0, increment cnt by t. second
return cnt
declare integer main ( ), vector A assign to  2, 1, 3 , integers
print countTriplets ( A)
return 0
","Count triples with Bitwise AND equal to Zero 
 C ++ program untill the above approach ; Function to find the number of triplets whose Bitwise AND is 0. ; Stores the count of triplets having bitwise AND equal to 0 ; Stores frequencies of all possible A array of i   & A array of j   ; Traverse the array ; Update frequency of Bitwise AND of all array elements with a ; Traverse the array ; Iterate the map ; If bitwise AND of triplet is zero , increment cnt ; Return the number of triplets whose Bitwise AND is 0. ; Driver Code ; Input Array ; Function Call
",1
579,"declare integer variable countTriplets with vector  integer > & A, cnt assign to 0
create an array of ints, ints with int > tuples
untill a : A, untill b : A, increment tuples array of a & b  
untill a : A, if t. first & a ) is 0, increment cnt by t. second
return cnt
declare integer main ( ), vector A assign to  2, 1, 3 , integers
print countTriplets ( A)
return 0
","Sum of distances of all nodes from a given node 
 C ++ program untill the above approach ; Structure of a binary tree node ; Function that allocates a new node with the given data and NULL to its left and right pointers ; Return newly created node ; Function to count the number of nodes in the left and right subtrees ; Initialize a pair that stores the pair { number of nodes , depth } ; Finding the number of nodes in the left subtree ; Find the number of nodes in the right subtree ; Filling up size field ; Stores the sum of distances of all nodes from the given node ; Function to find the total distance ; If target node matches with the current node ; If root -> left is not null ; Update sum ; Recur untill the left subtree ; If root -> right is not null ; Apply the untillmula given in the approach ; Recur untill the right subtree ; Driver Code ; Input tree ; Total number of nodes ; Print the sum of distances
",0
580,"if i is v. size ( ) or even. size ( ) is 0 and odd. size ( ) is 0 ), count is a void function
untill j assign to 0 to size of v - 1 exclusive, increment count by 1 if v array ofj   modulo 2 is not v array of j + 1   modulo 2
if count is less than min, set min to count
return
if v array of i   is not -1, parity ( even, odd, v, i + 1, min )
else if even. size ( ) is not 0, set x to even. back ( )
pop_back is a new function
v array of i   assign to x
parity assign to even, odd,v,i + 1 and min
push_back is a new function
if odd. size ( ) is not 0, x assign to odd. back ( )
pop_back assign to odd. pop_back assign to.
v array of i   assign to x
parity assign to even, odd,v,i + 1 and min
push_back is odd
minDiffParity is a void function with vector  integers > v, n, vector  integers > even
create vector  integer > odd
create an array of ints, ints with int value m
untill i assign to 1 to n inclusive, set m array of i   to 1
untill i assign to 0 to size of v, if v array of i   is not -1, erase v array of i  
untill i : m to if first % 2 is 0, push_back ( i. first ) is even
else odd. push_back ( i. first )
min assign to integer with min assign to 1000
declare parity ( even, odd, v, 0, min )
print min
declare integer main ( ) and integer n assign to 8
create vector v with v assign to  2, 1, 4, -1, -1, 6, -1, 8
minDiffParity ( v, n )
return 0
","Minimize the count of adjacent pairs with different parity 
 C ++ implementation of above approach ; Recursive function to calculate minimum adjacent pairs with different parity ; If all the numbers are placed ; If replacement is not required ; If replacement is required ; backtracking ; backtracking ; Function to display the minimum number of adjacent elements with different parity ; Store no of even numbers not present in the array ; Store no of odd numbers not present in the array ; Erase exisiting numbers ; Store non - exisiting even and odd numbers ; Driver code
",1
581,"if i is v. size ( ) or even. size ( ) is 0 and odd. size ( ) is 0 ), count is a void function
untill j assign to 0 to size of v - 1 exclusive, increment count by 1 if v array ofj   modulo 2 is not v array of j + 1   modulo 2
if count is less than min, set min to count
return
if v array of i   is not -1, parity ( even, odd, v, i + 1, min )
else if even. size ( ) is not 0, set x to even. back ( )
pop_back is a new function
v array of i   assign to x
parity assign to even, odd,v,i + 1 and min
push_back is a new function
if odd. size ( ) is not 0, x assign to odd. back ( )
pop_back assign to odd. pop_back assign to.
v array of i   assign to x
parity assign to even, odd,v,i + 1 and min
push_back is odd
minDiffParity is a void function with vector  integers > v, n, vector  integers > even
create vector  integer > odd
create an array of ints, ints with int value m
untill i assign to 1 to n inclusive, set m array of i   to 1
untill i assign to 0 to size of v, if v array of i   is not -1, erase v array of i  
untill i : m to if first % 2 is 0, push_back ( i. first ) is even
else odd. push_back ( i. first )
min assign to integer with min assign to 1000
declare parity ( even, odd, v, 0, min )
print min
declare integer main ( ) and integer n assign to 8
create vector v with v assign to  2, 1, 4, -1, -1, 6, -1, 8
minDiffParity ( v, n )
return 0
","Largest Square in a Binary Matrix with at most K 1 s untill multiple Queries 
 C ++ implementation to find the largest square in the matrix such that it contains atmost K 1 's ; Function to calculate the largest square with atmost K 1 s untill Q queries ; Loop to solve untill each query ; Traversing the each sub square and counting total ; Breaks when exceeds the maximum count ; Driver Code
",0
582,"create vector  int > adjacent array of MAX 
visited assign to bool array of size MAX
create integers startnode, endnode, thirdnode
create integer maxi with maxi assign to -1, N
parent assign to integer array of size MAX
vis assign to bool array of size MAX
declare dfs with integers u, count, visited array of u   assign to true
create integer temp with temp assign to 0
untill i assign to 0 to size of adjacent array of u  , increment i if visited array of adjacent array of u   array of i     is true, increment temp
dfs assign to adjacent array of u   array of i  , count + 1 )
if temp is 0, if maxi is less than count, set maxi to count
startnode assign to u
void dfs1 (int u, int count)  visited array of u   assign to true
create integer temp with temp assign to 0
untill i assign to 0 to size of adjacent array of u  , increment i if visited array of adjacent array of u   array of i     is true, increment temp
parent array of adjacent array of u   array of i     assign to u
dfs1 assign to adjacent array of u   array of i  , count + 1 )
if temp is 0, if maxi is less than count, set maxi to count
set endnode to u
void dfs2 (int u, int count)  visited array of u   assign to true
create integer temp with temp assign to 0
untill i assign to 0 to size of adjacent array of u  . size ( ), if visited array of adjacent array of u   array of i     and vis array of adjacent array of u   array of i    , increment temp
dfs2 assign to adjacent array of u   array of i  , count + 1 )
if temp is 0, if maxi is less than count, set maxi to count
set thirdnode to u
print findNodes and dfs ( 1, 0 )
untill i assign to 0 to N inclusive visited array of i   assign to false
set maxi to -1
dfs1 assign to startnode, 0
untill i assign to 0 to N inclusive visited array of i   assign to false
create integer x with x assign to endnode
set vis array of startnode   to true
untill x is not startnode, set vis array ofx   to true
x assign to parent array of x  
maxi assign to -1
untill i assign to 1 to N inclusive, dfs2 is equal to dfs2 ( i, 0 )
declare integer main ( ) and N assign to 4
push_back is a new array of adjacent array of 1 
push_back is a new array of adjacent array of 2 
push_back is a new array of adjacent array of 1 
push_back is a new array of characters with 3 elements
push_back is a new array of adjacent array of 1 
push_back is a new array of characters with size 4
call findNodes with argument 0
print "" ( "", startnode, "", "", "", thirdnode, "" ) ""
return 0
","Find triplet such that number of nodes connecting these triplets is maximum 
 C ++ implementation of the approach ; To store the required nodes ; Parent array to retrace the nodes ; Visited array to prevent DFS in direction on Diameter path ; DFS function to find the startnode ; DFS function to find the endnode of diameter and maintain the parent array ; DFS function to find the end node of the Longest Branch to Diameter ; Function to find the required nodes ; To find start node of diameter ; To find end node of diameter ; x is the end node of diameter ; Mark all the nodes on diameter using back tracking ; Find the end node of longest branch to diameter ; Driver code
",1
583,"create vector  int > adjacent array of MAX 
visited assign to bool array of size MAX
create integers startnode, endnode, thirdnode
create integer maxi with maxi assign to -1, N
parent assign to integer array of size MAX
vis assign to bool array of size MAX
declare dfs with integers u, count, visited array of u   assign to true
create integer temp with temp assign to 0
untill i assign to 0 to size of adjacent array of u  , increment i if visited array of adjacent array of u   array of i     is true, increment temp
dfs assign to adjacent array of u   array of i  , count + 1 )
if temp is 0, if maxi is less than count, set maxi to count
startnode assign to u
void dfs1 (int u, int count)  visited array of u   assign to true
create integer temp with temp assign to 0
untill i assign to 0 to size of adjacent array of u  , increment i if visited array of adjacent array of u   array of i     is true, increment temp
parent array of adjacent array of u   array of i     assign to u
dfs1 assign to adjacent array of u   array of i  , count + 1 )
if temp is 0, if maxi is less than count, set maxi to count
set endnode to u
void dfs2 (int u, int count)  visited array of u   assign to true
create integer temp with temp assign to 0
untill i assign to 0 to size of adjacent array of u  . size ( ), if visited array of adjacent array of u   array of i     and vis array of adjacent array of u   array of i    , increment temp
dfs2 assign to adjacent array of u   array of i  , count + 1 )
if temp is 0, if maxi is less than count, set maxi to count
set thirdnode to u
print findNodes and dfs ( 1, 0 )
untill i assign to 0 to N inclusive visited array of i   assign to false
set maxi to -1
dfs1 assign to startnode, 0
untill i assign to 0 to N inclusive visited array of i   assign to false
create integer x with x assign to endnode
set vis array of startnode   to true
untill x is not startnode, set vis array ofx   to true
x assign to parent array of x  
maxi assign to -1
untill i assign to 1 to N inclusive, dfs2 is equal to dfs2 ( i, 0 )
declare integer main ( ) and N assign to 4
push_back is a new array of adjacent array of 1 
push_back is a new array of adjacent array of 2 
push_back is a new array of adjacent array of 1 
push_back is a new array of characters with 3 elements
push_back is a new array of adjacent array of 1 
push_back is a new array of characters with size 4
call findNodes with argument 0
print "" ( "", startnode, "", "", "", thirdnode, "" ) ""
return 0
","Longest subsequence possible that starts and ends with 1 and filled with 0 in the middle 
 C ++ Program to find the longest subsequence possible that starts and ends with 1 and filled with 0 in the middle ; Prefix array to store the occurences of '1' and '0' ; Initialise prefix arrays with 0 ; Iterate over the length of the string ; If current character is '1' ; If current character is '0' ; Add '1' available untill the first string ; Add '0' available untill the second string ; Add '1' available untill the third string ; Update answer ; Print the final result ; Driver Code
",0
584,"print "" percentage increase in the "", "" volume of the sphere is "", pow ( x, 3 ) / 10000 + 3 * x + ( 3 * pow ( x, 2 ) ) / 100, "" % "", newline
declare integer main ( ) and double x assign to 10
create newvol ( x )
return 0
","Percentage increase in volume of the sphere if radius is increased by a given percentage 
 C ++ program to find percentage increase in the volume of the sphere if radius is increased by a given percentage ; Driver code
",1
585,"print "" percentage increase in the "", "" volume of the sphere is "", pow ( x, 3 ) / 10000 + 3 * x + ( 3 * pow ( x, 2 ) ) / 100, "" % "", newline
declare integer main ( ) and double x assign to 10
create newvol ( x )
return 0
","Count unimodal and non 
 C ++ program untill the above approach ; Function to calculate the factorials up to a number ; Calculate the factorial ; Function to find power ( a , b ) ; Iterate until b exists ; If b is divisible by 2 ; Decrease the value of b ; Return the answer ; Function that counts the unimodal and non - unimodal permutations of a given integer N ; Function Call untill finding factorials up to N ; Function to count unimodal permutations ; Non - unimodal permutation is N ! - unimodal permutations ; Driver Code ; Given Number N ; Function Call
",0
586,"print "" The length of the chord "" print "" of the circle is "" print 2 * r * sin ( x * 3.14 / 180 ) ) print newline
declare integer main ( ), double r assign to 4, x assign to 63
create length_of_chord ( r, x )
return 0
","Length of the chord of the circle whose radius and the angle subtended at the center by the chord is given 
 C ++ program to find the length chord of the circle whose radius and the angle subtended at the centre is also given ; Function to find the length of the chord ; Driver code
",1
587,"print "" The length of the chord "" print "" of the circle is "" print 2 * r * sin ( x * 3.14 / 180 ) ) print newline
declare integer main ( ), double r assign to 4, x assign to 63
create length_of_chord ( r, x )
return 0
","Find k closest elements to a given value 
  ; Function to find the cross over point ( the point beuntillewhich elements are smaller than or equal to x and afterwhich greater than x ) ; Base cases x is greater than all ; x is smaller than all ; Find the middle point ; If x is same as middle element , then return mid ; If x is greater than arr array of mid   , then either arr array of mid + 1   is ceiling of x or ceiling lies in arr array of mid + 1. . . high   ; This function prints k closest elements to x in arr array of   . n is the number of elements in arr array of   ; Find the crossover point ; Right index to search ; To keep track of count of elements already printed ; If x is present in arr array of   , then reduce left index Assumption : all elements in arr array of   are distinct ; Compare elements on left and right of crossover point to find the k closest elements ; If there are no more elements on right side , then print left elements ; If there are no more elements on left side , then print right elements ; Driver program to check above functions
",0
588,"return -1 if a is less than 0, float area
create float area with area assign to sqrt ( a ) / 6
return area
declare integer main ( ) and float a assign to 10
print area ( a ) print newline
return 0
","Area of a square inscribed in a circle which is inscribed in an equilateral triangle 
 C ++ Program to find the area of the square inscribed within the circle which in turn is inscribed in an equilateral triangle ; Function to find the area of the square ; a cannot be negative ; area of the square ; Driver code
",1
589,"return -1 if a is less than 0, float area
create float area with area assign to sqrt ( a ) / 6
return area
declare integer main ( ) and float a assign to 10
print area ( a ) print newline
return 0
","Maximum points of intersections possible among X circles and Y straight lines 
 C ++ program to implement the above approach ; Driver code ; Number of circles ; Number of straight lines ; Function Call
",0
590,"declare double result with length length, breadth, height as arguments, returning long longestRodInCuboid
create integer temp
temp assign to length * length + breadth * breadth + height * height
set result to sqrt ( temp)
return result
declare integer main ( ), length assign to 12, breadth assign to 9, height assign to 8
print longestRodInCuboid ( length, breadth, height )
return 0
","Length of longest rod that can fit into a cuboid 
 C ++ program to find the longest rod that can fit in a cuboid ; Function to find the length ; temporary variable to hold the intermediate result ; length of longest rod is calculated using square root function ; Driver code ; calling longestRodInCuboid ( ) function to get the length of longest rod
",1
591,"declare double result with length length, breadth, height as arguments, returning long longestRodInCuboid
create integer temp
temp assign to length * length + breadth * breadth + height * height
set result to sqrt ( temp)
return result
declare integer main ( ), length assign to 12, breadth assign to 9, height assign to 8
print longestRodInCuboid ( length, breadth, height )
return 0
","Count even sum pairs possible by selecting two integers from two given ranges respectively 
 C ++ program to implement the above approach ; Function to count even sum pairs in the given range ; Stores the count of even numbers between 1 to X ; Stores the count of odd numbers between 1 to X ; Stores the count of even numbers between 1 to Y ; Stores the count of odd numbers between 1 to Y ; Stores the count of pairs having even sum ; Retuens the count of pairs having even sum ; Driver Code
",0
592,"if x - y - b is less than or equal to 0 and x - y + b is greater than or equal to 0 and x + y - 2 * a + b is less than or equal to 0 and x + y - b is greater than or equal to 0, return true
return false
declare integer main ( ), integers a assign to 7, b assign to 2, x assign to 4 and y assign to 5
if LiesInsieRectangle ( a, b, x, y ) ) print "" Given point lies inside the rectangle ""
else print Given point does not lie on the rectangle
return 0
","Check whether a given point lies on or inside the rectangle 
 Set 3 
 C ++ program to Check whether a given point lies inside or on the rectangle or not ; function to Check whether a given point lies inside or on the rectangle or not ; Driver code
",1
593,"if x - y - b is less than or equal to 0 and x - y + b is greater than or equal to 0 and x + y - 2 * a + b is less than or equal to 0 and x + y - b is greater than or equal to 0, return true
return false
declare integer main ( ), integers a assign to 7, b assign to 2, x assign to 4 and y assign to 5
if LiesInsieRectangle ( a, b, x, y ) ) print "" Given point lies inside the rectangle ""
else print Given point does not lie on the rectangle
return 0
","Seating arrangement of n boys and girls alternatively around a round table 
 C ++ program to find number of ways in which n boys and n girls can sit alternatively sound a round table . ; Driver Code ; Get n ; find fac1 assign to ( n - 1 ) ! ; Find fac2 assign to n ! ; Find total number of ways ; Print the total number of ways
",0
594,"declare integer variable maxvolume with integer s as argument, set maxvalue to 0
untill i assign to 1 to s - 2 inclusive, set j to 1 and j to s - 1 inclusive, set k to s - i - j
set maxvalue to max ( maxvalue, i * j * k )
return maxvalue
declare integer main ( ) and integer s assign to 8
print maxvolume ( s ) print newline
return 0
","Maximize volume of cuboid with given sum of sides 
 Return the maximum volume . ; Return the maximum volume . ; untill length ; untill breadth ; untill height ; calculating maximum volume . ; Driven Program
",1
595,"declare integer variable maxvolume with integer s as argument, set maxvalue to 0
untill i assign to 1 to s - 2 inclusive, set j to 1 and j to s - 1 inclusive, set k to s - i - j
set maxvalue to max ( maxvalue, i * j * k )
return maxvalue
declare integer main ( ) and integer s assign to 8
print maxvolume ( s ) print newline
return 0
","Remove the first and last occurrence of a given Character from a String 
 C ++ Program to implement the above approach ; Function to remove first and last occurrence of a given character from the given string ; Traverse the given string from the beginning ; If ch is found ; Traverse the given string from the end ; If ch is found ; Driver Code
",0
596,"declare integer variable maxvolume with integer s, length assign to s / 3
decrement s by length
breadth assign to integer with breadth assign to s / 2
create integer height with height assign to s - breadth
return length * breadth * height
declare integer main ( ) and integer s assign to 8
print maxvolume ( s ) print newline
return 0
","Maximize volume of cuboid with given sum of sides 
 Return the maximum volume . ; Return the maximum volume . ; finding length ; finding breadth ; finding height ; Driven Program
",1
597,"declare integer variable maxvolume with integer s, length assign to s / 3
decrement s by length
breadth assign to integer with breadth assign to s / 2
create integer height with height assign to s - breadth
return length * breadth * height
declare integer main ( ) and integer s assign to 8
print maxvolume ( s ) print newline
return 0
","Counts Path in an Array 
 C ++ implementation ; find the number of ways to reach the end ; dp to store value ; base case ; Bottom up dp structure ; F array of i   is dependent of F array of i + 1   to F array of i + k   ; Return value of dp array of 0   ; Driver code
",0
598,"declare hexagonArea with double s as argument, returning ( 3 * sqrt ( 3) * ( s * s ) ) / 2 as argument, returning ( 3 * sqrt ( 3 ) * ( s * s ) )
declare integer main ( ) and double s assign to 4
print Area : "" and hexagonArea (s )
return 0
","Area of a Hexagon 
 CPP program to find area of a Hexagon ; function untill calculating area of the hexagon . ; Driver Code ; Length of a side
",1
599,"declare hexagonArea with double s as argument, returning ( 3 * sqrt ( 3) * ( s * s ) ) / 2 as argument, returning ( 3 * sqrt ( 3 ) * ( s * s ) )
declare integer main ( ) and double s assign to 4
print Area : "" and hexagonArea (s )
return 0
","Value of Pi ( ÃŽ ) up to 50 decimal places 
 C ++ program to calculate the value of pi up to n decimal places ; Function that prints the value of pi upto N decimal places ; Find value of pi upto using acos ( ) function ; Print value of pi upto N decimal places ; Driver Code ; Function that prints the value of pi
",0
600,"declare maxSquare with integers b, m as arguments, returning ( b / m - 1 ) * ( b / m ) / 2 as arguments, returning integer
declare integer variables main and b assign to 10 and m assign to 2
print maxSquare ( b, m )
return 0
","Maximum number of squares that can fit in a right angle isosceles triangle 
 CPP program untill finding maximum squares that can fit in right angle isosceles triangle ; function untill finding max squares ; return in O ( 1 ) with derived untillmula ; driver program
",1
601,"declare maxSquare with integers b, m as arguments, returning ( b / m - 1 ) * ( b / m ) / 2 as arguments, returning integer
declare integer variables main and b assign to 10 and m assign to 2
print maxSquare ( b, m )
return 0
","Minimum number of swaps required to sort an array of first N number 
 Function to find minimum swaps ; Initialise count variable ; If current element is not at the right position ; Swap current element with correct position of that element ; Increment untill next index when current element is at correct position ; Driver code ; Function to find minimum swaps
",0
602,"declare findRightAngle with integers A, H, D assign to pow ( H, 4) - 16 * A * A
if D >assign to 0, root1 assign to ( H * H + sqrt ( D ) ) / 2
root2 assign to long with root2 assign to ( H * H - sqrt ( D ) ) / 2
a assign to long with a assign to sqrt ( root1 )
b assign to long with b assign to sqrt ( root2 )
if b >assign to a, print a, "" "", b, "" "" and H
else print b, "" "", a, "" "" and H
else print "" - 1""
declare integer main ( ), findRightAngle ( 6, 5 ) )
","Check if right triangle possible from given area and hypotenuse 
 C ++ program to check existence of right triangle . ; Prints three sides of a right triangle from given area and hypotenuse if triangle is possible , else prints - 1. ; Descriminant of the equation ; applying the linear equation untillmula to find both the roots ; Driver code
",1
603,"declare findRightAngle with integers A, H, D assign to pow ( H, 4) - 16 * A * A
if D >assign to 0, root1 assign to ( H * H + sqrt ( D ) ) / 2
root2 assign to long with root2 assign to ( H * H - sqrt ( D ) ) / 2
a assign to long with a assign to sqrt ( root1 )
b assign to long with b assign to sqrt ( root2 )
if b >assign to a, print a, "" "", b, "" "" and H
else print b, "" "", a, "" "" and H
else print "" - 1""
declare integer main ( ), findRightAngle ( 6, 5 ) )
","Check if an array is Wave Array 
 CPP code to check if the array is wave array ; Function to check if array is wave array arr : input array n : size of array ; Check the wave untillm * If arr array of 1   is greater than left and right * Same pattern will be followed by whole * elements , else reverse pattern * will be followed by array elements ; Check untill last element ; Check untill last element ; Driver Code ; Array
",0
604,"numberOfSquares assign to integer with base assign to ( base - 2 )
set base to floor ( base / 2 )
return base * ( base + 1 ) / 2
declare integer main ( ) and integer base assign to 8
print numberOfSquares ( base)
return 0
","Maximum number of 2 x2 squares that can be fit inside a right isosceles triangle 
 C ++ program to count number of 2 x 2 squares in a right isosceles triangle ; removing the extra part we would always need ; Since each square has base of length of 2 ; Driver code
",1
605,"numberOfSquares assign to integer with base assign to ( base - 2 )
set base to floor ( base / 2 )
return base * ( base + 1 ) / 2
declare integer main ( ) and integer base assign to 8
print numberOfSquares ( base)
return 0
","Frequency Measuring Techniques untill Competitive Programming 
 C ++ program to count frequencies of array items having small values . ; Create an array to store counts . The size of array is limit + 1 and all values are initially 0 ; Traverse through array elements and count frequencies ( assuming that elements are limited by limit ) ; Driver Code
",0
606,"untill i assign to 0 to size of Q exclusive, or1 assign to 0
create integer x with x assign to Q array of i  array of 0  
arr array of x - 1   assign to Q array of i   array of 1  
untill j assign to 0 to size of arr exclusive, or1 assign to or1 
 arr array ofj 
print or1 print "" ""
declare main, vectors, arr with  1, 2, 3 , vectors
create vector v1 with v1 assign to 1, 4 assign to  v1
create vector v2 (  3, 0 )
create vector  vector  integer > > Q
push_back ( v1 ) Q
push_back ( v2 ) Q
peruntillmQuery ( arr, Q )
","Bitwise OR of bitwise AND of all possible non 
 C ++ program untill the above approach ; Function to find the Bitwise OR of Bitwise AND of all possible subarrays after peruntillming the every query ; Traversing each pair of the query ; Stores the Bitwise OR ; Updating the array ; Find the Bitwise OR of new updated array ; Print the ans ; Driver Code
",1
607,"untill i assign to 0 to size of Q exclusive, or1 assign to 0
create integer x with x assign to Q array of i  array of 0  
arr array of x - 1   assign to Q array of i   array of 1  
untill j assign to 0 to size of arr exclusive, or1 assign to or1 
 arr array ofj 
print or1 print "" ""
declare main, vectors, arr with  1, 2, 3 , vectors
create vector v1 with v1 assign to 1, 4 assign to  v1
create vector v2 (  3, 0 )
create vector  vector  integer > > Q
push_back ( v1 ) Q
push_back ( v2 ) Q
peruntillmQuery ( arr, Q )
","Finding a Non Transitive Co 
 C ++ program to find a non transitive co - prime triplets between L and R ; Checks if any possible triplet ( a , b , c ) satisfying the condition that ( a , b ) is coprime , ( b , c ) is coprime but ( a , c ) isnt ; Case 1 : Less than 3 numbers between L and R ; Case 2 : More than 3 numbers between L and R ; triplets should always be of untillm ( 2 k , 2 k + 1 , 2 k + 2 ) ; Case 3.1 : Exactly 3 numbers in range of untillm ( 2 k , 2 k + 1 , 2 k + 2 ) ; Case 3.2 : Exactly 3 numbers in range of untillm ( 2 k - 1 , 2 k , 2 k + 1 ) ; flag assign to True indicates that a pair exists between L and R ; Driver code ; finding possible Triplet between 2 and 10 ; finding possible Triplet between 23 and 46
",0
608,"smallest assign to integer with k,d assign to integer, cnt assign to 1
create integer m with m assign to d modulo k
create vector v with integers > k, 0
v array of m   assign to 1
untill 1 is not 0, return cnt
set m to ( ( ( m * ( 10 % k ) ) % k ) + ( d % k ) ) % k
if v array of m   is 1 return -1
v array of m   assign to 1
increment cnt
return -1
declare integer main ( ) and integer d assign to 1
create integer k with k assign to 41
print smallest (k, d )
return 0
","Smallest length of number divisible by K untillmed by using D only 
 C ++ program untill the above approach ; Function to untillm the smallest number possible ; Array to mark the remainders counted already ; Iterate over the range ; If that remainder is already found , return - 1 ; Driver Code
",1
609,"smallest assign to integer with k,d assign to integer, cnt assign to 1
create integer m with m assign to d modulo k
create vector v with integers > k, 0
v array of m   assign to 1
untill 1 is not 0, return cnt
set m to ( ( ( m * ( 10 % k ) ) % k ) + ( d % k ) ) % k
if v array of m   is 1 return -1
v array of m   assign to 1
increment cnt
return -1
declare integer main ( ) and integer d assign to 1
create integer k with k assign to 41
print smallest (k, d )
return 0
","Find the smallest missing number 
 C ++ program untill the above approach ; Program to find Smallest Missing in Sorted Array ; Check if 0 is missing in the array ; Check is all numbers 0 to n - 1 are prsent in array ; Program to find missing element ; * Index matches with value at that index , means missing element cannot be upto that po ; Driver program to test the above function ; Function Call
",0
610,"if n assign to 1 return n
return fib ( n - 1 ) + fib ( n - 2 )
declare findVertices with integer n, return fib (n + 2)
declare integer main ( ) and integer n assign to 3
print findVertices ( n )
return 0
","Fibonacci Cube Graph 
 CPP code to find vertices in a fibonacci cube graph of order n ; function to find fibonacci number ; function untill finding number of vertices in fibonacci cube graph ; return fibonacci number untill f ( n + 2 ) ; driver program
",1
611,"if n assign to 1 return n
return fib ( n - 1 ) + fib ( n - 2 )
declare findVertices with integer n, return fib (n + 2)
declare integer main ( ) and integer n assign to 3
print findVertices ( n )
return 0
","Form minimum number from given sequence 
 C ++ program to print minimum number that can be untillmed from a given sequence of Is and Ds ; Prints the minimum number that can be untillmed from input sequence of I ' s â– and â– D ' s ; Initialize current_max ( to make sure that we don 't use repeated character ; Initialize last_entry ( Keeps track untill last printed digit ) ; Iterate over input array ; Initialize ' noOfNextD ' to get count of next D 's available ; If letter is ' I ' Calculate number of next consecutive D 's  available ; If ' I ' is first letter , print incremented sequence from 1 ; Set max digit reached ; If not first letter Get next digit to print ; Print digit untill I ; For all next consecutive ' D ' print decremented sequence ; If letter is ' D ' ; If ' D ' is first letter in sequence Find number of Next D 's available ; Calculate first digit to print based on number of consecutive D 's ; Print twice untill the first time ; Store last entry ; If current ' D ' is not first letter Decrement last_entry ; Driver program to test above
",0
612,"declare checkCommonDivisor with integer arr array of  , N, X as arguments, set G to 0
untill i assign to 0 to N exclusive, set G to __gcd ( G, arr array of i   )
create integer copy_G with copy_G assign to G
untill divisor assign to 2 to X inclusive, untill G modulo divisor assign to 0, set G to G / divisor
print Yes STRNEWLINE
untill i assign to 0 to N exclusive, print arr array of i   / copy_G print "" ""
print newline
else print No
declare integer variables main and X assign to 6
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
checkCommonDivisor ( arr, N, X )
","Modify array such that the array does not contain any common divisors other than 1 
 C ++ program untill the above approach ; Function to check if it is possible to modify the array such that there is no common factor between array elements except 1 ; Stores GCD of the array ; Calculate GCD of the array ; If the current divisor is smaller than X ; Divide GCD by the current divisor ; If possible ; Print the modified array ; Otherwise ; Driver Code ; Given array ; Size of the array
",1
613,"declare checkCommonDivisor with integer arr array of  , N, X as arguments, set G to 0
untill i assign to 0 to N exclusive, set G to __gcd ( G, arr array of i   )
create integer copy_G with copy_G assign to G
untill divisor assign to 2 to X inclusive, untill G modulo divisor assign to 0, set G to G / divisor
print Yes STRNEWLINE
untill i assign to 0 to N exclusive, print arr array of i   / copy_G print "" ""
print newline
else print No
declare integer variables main and X assign to 6
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
checkCommonDivisor ( arr, N, X )
","Automorphic Number 
 C ++ program to check if a number is Authomorphic ; Function to check Automorphic number ; Store the square ; Start Comparing digits ; Return false , if any digit of N doesn ' t â– â– match â– with â– its â– square ' s digits from last ; Reduce N and square ; Driver code
",0
614,"declare printSpiral with integer size assign to 0 and col assign to 0
define integer boundary assign to size - 1
sizeLeft assign to size - 1
create integer flag with flag assign to 1
move assign to'r '
create integer matrix array of size   array of size   assign to  0
untill i assign to 1 to size * size + 1 exclusive, matrix array of row   array of col   assign to i
change case'r' if move is true, increment col by 1
break loop
l assign to case : col - 1
break loop
u assign to case : row - 1
break loop
create case'd' : row + 1
break loop
if i is boundary, increment boundary by sizeLeft
if flag is not 2 set flag to 2
else set flag to 1
decrement sizeLeft by 1
change the value of switch to case'r' if move is 'd'
break loop
create case'd' : move assign to'l'
break loop
let case'l' : move assign to'u'
break loop
let u be a case : move assign to'r '
break loop
untill row assign to 0 to size exclusive, set n to matrix array of row  array of col 
if n is less than 10 print n and "" ""
else print n and "" ""
print a new line
declare integer main ( ) and size assign to 5
printSpiral is a new line
return 0
","Program to print Spiral Pattern 
 Create row and col to traverse rows and columns ; Variable to determine the movement r assign to right , l assign to left , d assign to down , u assign to upper ; Array untill matrix ; Assign the value ; switch - case to determine the next index ; If right , go right ; if left , go left ; if up , go up ; if down , go down ; Check if the matrix has reached array boundary ; Add the left size untill the next boundary ; If 2 rotations has been made , decrease the size left by 1 ; switch - case to rotate the movement ; if right , rotate to down ; if down , rotate to left ; if left , rotate to up ; if up , rotate to right ; Print the matrix ; Driver Code ; Get the size of size ; Print the Spiral Pattern
",1
615,"declare printSpiral with integer size assign to 0 and col assign to 0
define integer boundary assign to size - 1
sizeLeft assign to size - 1
create integer flag with flag assign to 1
move assign to'r '
create integer matrix array of size   array of size   assign to  0
untill i assign to 1 to size * size + 1 exclusive, matrix array of row   array of col   assign to i
change case'r' if move is true, increment col by 1
break loop
l assign to case : col - 1
break loop
u assign to case : row - 1
break loop
create case'd' : row + 1
break loop
if i is boundary, increment boundary by sizeLeft
if flag is not 2 set flag to 2
else set flag to 1
decrement sizeLeft by 1
change the value of switch to case'r' if move is 'd'
break loop
create case'd' : move assign to'l'
break loop
let case'l' : move assign to'u'
break loop
let u be a case : move assign to'r '
break loop
untill row assign to 0 to size exclusive, set n to matrix array of row  array of col 
if n is less than 10 print n and "" ""
else print n and "" ""
print a new line
declare integer main ( ) and size assign to 5
printSpiral is a new line
return 0
","Find Landau 's function untill a given number N 
 C ++ program untill the above approach ; To store Landau 's function of the number ; Function to return gcd of 2 numbers ; Function to return LCM of two numbers ; Function to find max lcm value among all representations of n ; Calculate Landau 's value ; Recursive function to find different ways in which n can be written as sum of atleast one positive integers ; Check if sum becomes n , consider this representation ; Start from previous element in the representation till n ; Include current element from representation ; Call function again with reduced sum ; Backtrack - remove current element from representation ; Function to find the Landau 's function ; Using recurrence find different ways in which n can be written as a sum of atleast one + ve integers ; Print the result ; Driver Code ; Given N ; Function Call
",0
616,"create struct Node  integer data
Node assign to struct * next
create struct Node * prev
print a newline
reverse assign to void with Node * head_ref and Node * temp assign to NULL
Node * current assign to * head_ref
untill current is not NULL, temp assign to current -> prev
set current -> prev to current -> next
set current -> next to temp
set current to current -> prev
if temp is not NULL, head_ref assign to temp -> prev
if struct Node * merge ( struct Node * first, struct Node * second ), return second
if second is not second, return first
if first -> data is less than second -> data, set first -> next to merge ( first -> next, second )
first -> next -> prev assign to first
set first -> prev to NULL
return first
else  second -> next assign to merge ( first, second -> next )
second -> next -> prev assign to second
set second -> prev to NULL
return second
if head is NULL head -> next is NULL return head
Node * current assign to head -> next
untill current is not NULL, break loop if current -> data is less than current -> prev -> data
set current to current -> next
if current is NULL, return head
set current -> prev -> next to NULL
set current -> prev to NULL
reverse ( & current )
return merge ( head, current )
void push (struct Node * head_ref, int new_data), struct Node * new_node assign to (struct Node * ) malloc ( sizeof (struct Node ) )
new_node -> data assign to new_data
new_node -> prev assign to NULL
new_node -> next assign to ( * head_ref )
if ( * head_ref ) is not NULL) ( * head_ref ) -> prev assign to new_node
change the value of new_node to ( * head_ref )
printList is a void function with node * head and if head is NULL print "" Doubly Linked list empty ""
untill head is not NULL print head -> data and "" ""
set head to head -> next
declare integer main ( ) and struct Node * head assign to NULL
push ( & head, 1 )
push ( & head, 4 )
push ( & head, 6 )
push ( & head, 10 )
push ( & head, 12 )
push ( & head, 7 )
push ( & head, 5 )
push ( & head, 2 )
print Original Doubly linked list : n
printList is a new line
set head to sort ( head )
print Doubly linked list after sorting : n
printList is a new line
return 0
","Sort the biotonic doubly linked list 
 C ++ implementation to sort the biotonic doubly linked list ; a node of the doubly linked list ; Function to reverse a Doubly Linked List ; swap next and prev untill all nodes of doubly linked list ; Beuntille changing head , check untill the cases like empty list and list with only one node ; Function to merge two sorted doubly linked lists ; If first linked list is empty ; If second linked list is empty ; Pick the smaller value ; function to sort a biotonic doubly linked list ; if list is empty or if it contains a single node only ; if true , then ' current ' is the first node which is smaller than its previous node ; move to the next node ; if true , then list is already sorted ; spilt into two lists , one starting with ' head ' and other starting with ' current ' ; reverse the list starting with ' current ' ; merge the two lists and return the final merged doubly linked list ; Function to insert a node at the beginning of the Doubly Linked List ; allocate node ; put in the data ; since we are adding at the beginning , prev is always NULL ; link the old list off the new node ; change prev of head node to new node ; move the head to point to the new node ; Function to print nodes in a given doubly linked list ; if list is empty ; Driver program to test above ; Create the doubly linked list : 2 < -> 5 < -> 7 < -> 12 < -> 10 < -> 6 < -> 4 < -> 1 ; sort the biotonic DLL
",1
617,"create struct Node  integer data
Node assign to struct * next
create struct Node * prev
print a newline
reverse assign to void with Node * head_ref and Node * temp assign to NULL
Node * current assign to * head_ref
untill current is not NULL, temp assign to current -> prev
set current -> prev to current -> next
set current -> next to temp
set current to current -> prev
if temp is not NULL, head_ref assign to temp -> prev
if struct Node * merge ( struct Node * first, struct Node * second ), return second
if second is not second, return first
if first -> data is less than second -> data, set first -> next to merge ( first -> next, second )
first -> next -> prev assign to first
set first -> prev to NULL
return first
else  second -> next assign to merge ( first, second -> next )
second -> next -> prev assign to second
set second -> prev to NULL
return second
if head is NULL head -> next is NULL return head
Node * current assign to head -> next
untill current is not NULL, break loop if current -> data is less than current -> prev -> data
set current to current -> next
if current is NULL, return head
set current -> prev -> next to NULL
set current -> prev to NULL
reverse ( & current )
return merge ( head, current )
void push (struct Node * head_ref, int new_data), struct Node * new_node assign to (struct Node * ) malloc ( sizeof (struct Node ) )
new_node -> data assign to new_data
new_node -> prev assign to NULL
new_node -> next assign to ( * head_ref )
if ( * head_ref ) is not NULL) ( * head_ref ) -> prev assign to new_node
change the value of new_node to ( * head_ref )
printList is a void function with node * head and if head is NULL print "" Doubly Linked list empty ""
untill head is not NULL print head -> data and "" ""
set head to head -> next
declare integer main ( ) and struct Node * head assign to NULL
push ( & head, 1 )
push ( & head, 4 )
push ( & head, 6 )
push ( & head, 10 )
push ( & head, 12 )
push ( & head, 7 )
push ( & head, 5 )
push ( & head, 2 )
print Original Doubly linked list : n
printList is a new line
set head to sort ( head )
print Doubly linked list after sorting : n
printList is a new line
return 0
","Loss when two items are sold at same price and same percentage profit / loss 
 C ++ implementation of above approach . ; Function that will find loss ; Driver Code ; Calling Function
",0
618,"create struct Node with Node assign to char data
Node assign to struct * next
print a newline
Node * newNode ( char key )  Node * temp assign to new Node
set temp -> data to key
set temp -> next to NULL
return temp
printlist is a void function, printlist is a void, if node * head is not a void, print "" Empty List STRNEWLINE ""
return
untill head is not NULL print head -> data and "" ""
if head -> next, print "" - > ""
set head to head -> next
print a new line
return boolean function isVowel with character argument x with value'a'x with value'e'x with value'i'x with value'o'x with value'u')
set Node * arrange ( Node * head ) and Node * newHead to head
Node * latestVowel
assign head to Node * curr
if head is NULL, return NULL
if isVowel ( head -> data ) is true, set latestVowel to head
else  untill curr -> next is not NULL and isVowel ( curr -> next -> data ) ), curr assign to curr -> next
if curr -> next is NULL, return head
let latestVowel be newHead assign to curr -> next
set curr -> next to curr -> next -> next
set latestVowel -> next to head
untill curr is not NULL and curr is not NULL, if curr is not latestVowel, set latestVowel to curr is not newVowel
else set Node * temp to latestVowel -> next
let latestVowel -> next be curr -> next
set latestVowel to latestVowel -> next
set curr -> next to curr -> next -> next
set latestVowel -> next to temp
else set curr to curr -> next
return newHead
declare integer main ( ) and Node * head assign to newNode ('a')
head -> next assign to newNode ('b')
head -> next -> next assign to newNode ('c')
head -> next -> next -> next assign to newNode ('e')
head -> next -> next -> next -> next assign to newNode ('d')
head -> next -> next -> next -> next -> next assign to newNode ('o')
head -> next -> next -> next -> next -> next -> next -> next -> next assign to newNode ('x')
head -> next -> next -> next -> next -> next -> next -> next -> next -> next -> next assign to newNode ('i')
printf is a new line
printlist ( head )
set head to arrange ( head )
printf is a new line
printlist ( head )
return 0
","Arrange consonants and vowels nodes in a linked list 
 C ++ program to arrange consonants and vowels nodes in a linked list ; A linked list node ; Function to add new node to the List ; utility function to print linked list ; utility function untill checking vowel ; function to arrange consonants and vowels nodes ; untill keep track of vowel ; list is empty ; We need to discover the first vowel in the list . It is going to be the returned head , and also the initial latestVowel . ; first element is a vowel . It will also be the new head and the initial latestVowel ; ; First element is not a vowel . Iterate through the list until we find a vowel . Note that curr points to the element * beuntille * the element with the vowel . ; This is an edge case where there are only consonants in the list . ; Set the initial latestVowel and the new head to the vowel item that we found . Relink the chain of consonants after that vowel item : old_head_consonant -> consonant1 -> consonant2 -> vowel -> rest_of_list becomes vowel -> old_head_consonant -> consonant1 -> consonant2 -> rest_of_list ; Now traverse the list . Curr is always the item * beuntille * the one we are checking , so that we can use it to re - link . ; The next discovered item is a vowel ; If it comes directly after the previous vowel , we don 't need to  move items around, just mark the  new latestVowel and advance curr. ; But if it comes after an intervening chain of consonants , we need to chain the newly discovered vowel right after the old vowel . Curr is not changed as after the re - linking it will have a new next , that has not been checked yet , and we always keep curr at one beuntille the next to check . ; Chain in new vowel ; Advance latestVowel ; Remove found vowel from previous place ; Re - link chain of consonants after latestVowel ; No vowel in the next element , advance curr . ; Driver code
",1
619,"create struct Node with Node assign to char data
Node assign to struct * next
print a newline
Node * newNode ( char key )  Node * temp assign to new Node
set temp -> data to key
set temp -> next to NULL
return temp
printlist is a void function, printlist is a void, if node * head is not a void, print "" Empty List STRNEWLINE ""
return
untill head is not NULL print head -> data and "" ""
if head -> next, print "" - > ""
set head to head -> next
print a new line
return boolean function isVowel with character argument x with value'a'x with value'e'x with value'i'x with value'o'x with value'u')
set Node * arrange ( Node * head ) and Node * newHead to head
Node * latestVowel
assign head to Node * curr
if head is NULL, return NULL
if isVowel ( head -> data ) is true, set latestVowel to head
else  untill curr -> next is not NULL and isVowel ( curr -> next -> data ) ), curr assign to curr -> next
if curr -> next is NULL, return head
let latestVowel be newHead assign to curr -> next
set curr -> next to curr -> next -> next
set latestVowel -> next to head
untill curr is not NULL and curr is not NULL, if curr is not latestVowel, set latestVowel to curr is not newVowel
else set Node * temp to latestVowel -> next
let latestVowel -> next be curr -> next
set latestVowel to latestVowel -> next
set curr -> next to curr -> next -> next
set latestVowel -> next to temp
else set curr to curr -> next
return newHead
declare integer main ( ) and Node * head assign to newNode ('a')
head -> next assign to newNode ('b')
head -> next -> next assign to newNode ('c')
head -> next -> next -> next assign to newNode ('e')
head -> next -> next -> next -> next assign to newNode ('d')
head -> next -> next -> next -> next -> next assign to newNode ('o')
head -> next -> next -> next -> next -> next -> next -> next -> next assign to newNode ('x')
head -> next -> next -> next -> next -> next -> next -> next -> next -> next -> next assign to newNode ('i')
printf is a new line
printlist ( head )
set head to arrange ( head )
printf is a new line
printlist ( head )
return 0
","Check if a number is prime in Flipped Upside Down , Mirror Flipped and Mirror Flipped Upside Down 
 C ++ program to implement the above approach ; Function to check if N contains digits 0 , 1 , 2 , 5 , 8 only ; Extract digits of N ; Return false if any of these digits are present ; Function to check if N is prime or not ; Check untill all factors ; Function to check if n is prime in all the desired untillms ; Driver Code
",0
620,"create struct Node  integer data
Node assign to struct with Node assign to left, right
print a newline
Node * newNode ( int data)  Node * temp assign to new Node
set temp -> data to data
set temp -> right to temp -> left to NULL
return temp
Node * KthLargestUsingMorrisTraversal ( Node * root, int k )  Node * curr assign to root
Node * Klargest assign to NULL
create integer count with count assign to 0
untill curr is not NULL, set Klargest to curr if curr -> right is NULL, increment count by k
set curr to curr -> left
else set Node * succ to curr -> right
untill succ -> left is not NULL and succ -> left is not curr, set succ to succ -> left
if succ -> left is NULL, then succ -> left assign to curr
set curr to curr -> right
else  succ -> left assign to NULL
if ++ count is k, set Klargest to curr
set curr to curr -> left
return Klargest
declare integer main ( ), Node * root assign to newNode ( 4 )
set root -> left to newNode ( 2 )
set root -> right to newNode ( 7 )
root -> left -> left assign to newNode ( 1 )
root -> left -> right assign to newNode ( 3 )
root -> right -> left assign to newNode ( 6 )
set root -> right -> right to newNode ( 10 )
print Finding K - th largest Node in BST : "" print KthLargestUsingMorrisTraversal ( root, 2 ) -> data
return 0
","K 'th Largest element in BST using constant extra space 
 CPP code untill finding K - th largest Node using O ( 1 ) extra memory and reverse Morris traversal . ; Node structure ; helper function to create a new Node ; count variable to keep count of visited Nodes ; if right child is NULL ; first increment count and check if count assign to k ; otherwise move to the left child ; find inorder successor of current Node ; set left child of successor to the current Node ; move current to its right ; restoring the tree back to original binary search tree removing threaded links ; move current to its left child ; Constructed binary tree is 4 / \ 2 7 / \ / \ 1 3 6 10
",1
621,"create struct Node  integer data
Node assign to struct with Node assign to left, right
print a newline
Node * newNode ( int data)  Node * temp assign to new Node
set temp -> data to data
set temp -> right to temp -> left to NULL
return temp
Node * KthLargestUsingMorrisTraversal ( Node * root, int k )  Node * curr assign to root
Node * Klargest assign to NULL
create integer count with count assign to 0
untill curr is not NULL, set Klargest to curr if curr -> right is NULL, increment count by k
set curr to curr -> left
else set Node * succ to curr -> right
untill succ -> left is not NULL and succ -> left is not curr, set succ to succ -> left
if succ -> left is NULL, then succ -> left assign to curr
set curr to curr -> right
else  succ -> left assign to NULL
if ++ count is k, set Klargest to curr
set curr to curr -> left
return Klargest
declare integer main ( ), Node * root assign to newNode ( 4 )
set root -> left to newNode ( 2 )
set root -> right to newNode ( 7 )
root -> left -> left assign to newNode ( 1 )
root -> left -> right assign to newNode ( 3 )
root -> right -> left assign to newNode ( 6 )
set root -> right -> right to newNode ( 10 )
print Finding K - th largest Node in BST : "" print KthLargestUsingMorrisTraversal ( root, 2 ) -> data
return 0
","Queries to count Palindrome Numbers from a range whose sum of digits is a Prime Number 
 C ++ program untill the above approach ; Function to check if the number N is palindrome or not ; Store the value of N ; Store the reverse of number N ; Reverse temp and store in res ; If N is the same as res , then return true ; Function to find the sum of the digits of the number N ; Stores the sum of the digits ; Add the last digit of the number N to the sum ; Remove the last digit from N ; Return the resultant sum ; Function to check if N is prime or not ; If i is 1 or 0 , then return false ; Check if i is divisible by any number in the range array of 2 , n / 2   ; If n is divisible by i ; Function to precompute all the numbers till 10 to the power 5 that are palindromic and whose sum of digits is prime numbers ; Iterate over the range 1 to 10 to the power 5 ; If i is a palindrome number ; Stores the sum of the digits in i ; If the sum of digits in i is a prime number ; Find the prefix sum of arr array of   ; Function to count all the numbers in the given ranges that are palindromic and the sum of digits is prime numbers ; Function Call to precompute all the numbers till 10 to the power 5 ; Traverse the given queries Q array of   ; Print the result untill each query ; Driver Code ; Function Call
",0
622,"sortByRow is a void function with int arguments mat array of   array of MAX_SIZE   and n, and boolean ascending, sorting ( mat array of i  , mat array of i   + n )
else sort ( mat array of i  , mat array of i   + n, greater  integer > ( ) ) )
untill i assign to 0 to n exclusive, swap mat array of i   array of j   and mat array of j   array of i   )
sortMatRowAndColWise is a void function with mat, MAX_SIZE elements and sortByRow elements with mat, n, true elements
transpose mat, n
sortByRow ( mat, n, false )
transpose mat, n
printMat is a void function with int arguments mat array of   array of MAX_SIZE   and n, and untill i assign to 0 to n exclusive, print mat array of i   array of j   and "" ""
print newline
declare integer main ( ) and integer n assign to 3
create integer mat with mat assign to n, MAX_SIZE assign to  3, 2, 1 , 9, 8, 7 , 6, 5, 4
print Original Matrix : STRNEWLINE
printMat is a new line
sortMatRowAndColWise ( mat, n )
print Matrix After Sorting :
printMat is a new line
return 0
","Sorting rows of matrix in ascending order followed by columns in descending order 
 C ++ implementation to sort the rows of matrix in ascending order followed by sorting the columns in descending order ; function to sort each row of the matrix according to the order specified by ascending . ; function to find transpose of the matrix ; swapping element at index ( i , j ) by element at index ( j , i ) ; function to sort the matrix row - wise and column - wise ; sort rows of mat array of   array of   ; get transpose of mat array of   array of   ; again sort rows of mat array of   array of   in descending order . ; again get transpose of mat array of   array of   ; function to print the matrix ; Driver program to test above
",1
623,"sortByRow is a void function with int arguments mat array of   array of MAX_SIZE   and n, and boolean ascending, sorting ( mat array of i  , mat array of i   + n )
else sort ( mat array of i  , mat array of i   + n, greater  integer > ( ) ) )
untill i assign to 0 to n exclusive, swap mat array of i   array of j   and mat array of j   array of i   )
sortMatRowAndColWise is a void function with mat, MAX_SIZE elements and sortByRow elements with mat, n, true elements
transpose mat, n
sortByRow ( mat, n, false )
transpose mat, n
printMat is a void function with int arguments mat array of   array of MAX_SIZE   and n, and untill i assign to 0 to n exclusive, print mat array of i   array of j   and "" ""
print newline
declare integer main ( ) and integer n assign to 3
create integer mat with mat assign to n, MAX_SIZE assign to  3, 2, 1 , 9, 8, 7 , 6, 5, 4
print Original Matrix : STRNEWLINE
printMat is a new line
sortMatRowAndColWise ( mat, n )
print Matrix After Sorting :
printMat is a new line
return 0
","Print all Strings from array A array of   having all strings from array B array of   as subsequence 
 C ++ Program to implement the above approach ; Function to find strings from A array of   having all strings in B array of   as subsequence ; Calculate respective sizes ; Stores the answer ; Stores the frequency of each character in strings of A array of   ; Compute the frequencies of characters of all strings ; Stores the frequency of each character in strings of B array of   each character of a string in B array of   ; If the frequency of a character in B array of   exceeds that in A array of   ; A string exists in B array of   which is not a proper subset of A array of i   ; If all strings in B array of   are proper subset of A array of   ; Push the string in resultant vector ; If any string is found ; Print those strings ; Otherwise ; Driver code
",0
624,"sortByRow is a void function with int arguments mat and mat with MAX_SIZE and MAX_SIZE and n, and int arguments i assign to 0 and i  n, sort ( mat array of i   and mat array of i   + n )
untill i assign to 0 to n exclusive, swap mat array of i   array of j  , mat array of j   array of i   )
sortMatRowAndColWise is a void function with mat mat, MAX_SIZE, MAX_SIZE, int argument n, sortByRow is a void function
transpose mat, n
sortByRow ( mat, n )
transpose mat, n
printMat is a void function with int arguments mat and j with MAX_SIZE and MAX_SIZE and n, and untill i assign to 0 to n exclusive, print mat and j with j  n and j  "" ""
print newline
let main be a integer, with mat assign to 4, 1, 3, 9, 6, 8, 5, 2, 7, 7,    ;
n assign to integer with n assign to 3
print Original Matrix : STRNEWLINE
printMat is a new line
sortMatRowAndColWise ( mat, n )
print Matrix After Sorting :
printMat is a new line
return 0
","Sort the matrix row 
 C ++ implementation to sort the matrix row - wise and column - wise ; function to sort each row of the matrix ; sorting row number ' i ' ; function to find transpose of the matrix ; swapping element at index ( i , j ) by element at index ( j , i ) ; function to sort the matrix row - wise and column - wise ; sort rows of mat array of   array of   ; get transpose of mat array of   array of   ; again sort rows of mat array of   array of   ; again get transpose of mat array of   array of   ; function to print the matrix ; Driver program to test above
",1
625,"sortByRow is a void function with int arguments mat and mat with MAX_SIZE and MAX_SIZE and n, and int arguments i assign to 0 and i  n, sort ( mat array of i   and mat array of i   + n )
untill i assign to 0 to n exclusive, swap mat array of i   array of j  , mat array of j   array of i   )
sortMatRowAndColWise is a void function with mat mat, MAX_SIZE, MAX_SIZE, int argument n, sortByRow is a void function
transpose mat, n
sortByRow ( mat, n )
transpose mat, n
printMat is a void function with int arguments mat and j with MAX_SIZE and MAX_SIZE and n, and untill i assign to 0 to n exclusive, print mat and j with j  n and j  "" ""
print newline
let main be a integer, with mat assign to 4, 1, 3, 9, 6, 8, 5, 2, 7, 7,    ;
n assign to integer with n assign to 3
print Original Matrix : STRNEWLINE
printMat is a new line
sortMatRowAndColWise ( mat, n )
print Matrix After Sorting :
printMat is a new line
return 0
","Find the last player to be able to flip a character in a Binary String 
 C ++ program untill the above approach ; Function to check if player A wins the game or not ; Stores size of the groups of 0 s ; Stores size of the group of 0 s ; Traverse the array ; Increment c by 1 if a array of i   is 0 ; Otherwise , push the size in array and reset c to 0 ; If there is no substring of odd length consisting only of 0 s ; If there is only 1 substring of odd length consisting only of 0 s ; Otherwise ; Stores the size of the largest and second largest substrings of 0 s ; Traverse the array v array of   ; If current element is greater than first , then update both first and second ; If arr array of i   is in between first and second , then update second ; If the condition is satisfied ; Driver Code
",0
626,"declare doublyEven with integer n as argument, returning integer array arr size n   array of n  , i, j
untill i assign to 0 to n exclusive, arr array of i   array of j   assign to ( n * i ) + j + 1
untill i assign to 0 to n / 4 exclusive, arr array of i   array of j   assign to ( n * n + 1 ) - arr array of i   array of j   ; j   assign to 0 ; j  n / 4 ; j ++ )
untill i assign to 0 to n / 4 exclusive, arr array of i   array of j   assign to ( n * n + 1 ) - arr array of i   array of j   ; j  n ; j ++ )
untill i assign to 3 * n / 4 ; i  n ; i ++ ) untill j assign to 0 ; j  n / 4 ; j ++ ), arr array of i   array of j   assign to ( n * n + 1 ) - arr array of i   array of j    
untill i assign to 3 * n / 4 ; i  n ; i ++ ) untill j assign to 3 * n / 4 ; j  n ; j ++ ), arr array of i   array of j   assign to ( n * n + 1 ) - arr array of i   array of j    
untill i assign to n / 4, i  3 * n / 4, increment i by 1, arr array of i   array of j   assign to ( n * n + 1 ) - arr array of i   array of j  , increment i by 1, increment j )
untill i assign to 0 to n exclusive, print arr array of i   array of j   and "" ""
print "" STRNEWLINE ""
declare integer main ( ) and integer n assign to 8
doubleEven is a double function
return 0
","Magic Square 
 Even Order 
 C ++ Program to print Magic square of Doubly even order ; Function untill calculating Magic square ; filling matrix with its count value starting from 1 ; ; change value of Array elements at fix location as per rule ( n * n + 1 ) - arr array of i   array of j   Top Left corner of Matrix ( order ( n / 4 ) * ( n / 4 ) ) ; Top Right corner of Matrix ( order ( n / 4 ) * ( n / 4 ) ) ; Bottom Left corner of Matrix ( order ( n / 4 ) * ( n / 4 ) ) ; Bottom Right corner of Matrix ( order ( n / 4 ) * ( n / 4 ) ) ; Centre of Matrix ( order ( n / 2 ) * ( n / 2 ) ) ; Printing the magic - square ; driver program ; Function call
",1
627,"declare doublyEven with integer n as argument, returning integer array arr size n   array of n  , i, j
untill i assign to 0 to n exclusive, arr array of i   array of j   assign to ( n * i ) + j + 1
untill i assign to 0 to n / 4 exclusive, arr array of i   array of j   assign to ( n * n + 1 ) - arr array of i   array of j   ; j   assign to 0 ; j  n / 4 ; j ++ )
untill i assign to 0 to n / 4 exclusive, arr array of i   array of j   assign to ( n * n + 1 ) - arr array of i   array of j   ; j  n ; j ++ )
untill i assign to 3 * n / 4 ; i  n ; i ++ ) untill j assign to 0 ; j  n / 4 ; j ++ ), arr array of i   array of j   assign to ( n * n + 1 ) - arr array of i   array of j    
untill i assign to 3 * n / 4 ; i  n ; i ++ ) untill j assign to 3 * n / 4 ; j  n ; j ++ ), arr array of i   array of j   assign to ( n * n + 1 ) - arr array of i   array of j    
untill i assign to n / 4, i  3 * n / 4, increment i by 1, arr array of i   array of j   assign to ( n * n + 1 ) - arr array of i   array of j  , increment i by 1, increment j )
untill i assign to 0 to n exclusive, print arr array of i   array of j   and "" ""
print "" STRNEWLINE ""
declare integer main ( ) and integer n assign to 8
doubleEven is a double function
return 0
","Length of the longest subsegment which is UpDown after inserting atmost one integer 
 C ++ implementation of the approach ; Function to recursively fill the dp array ; If f ( i , state ) is already calculated then return the value ; Calculate f ( i , state ) according to the recurrence relation and store in dp array of   array of   ; Function that calls the resucrsive function to fill the dp array and then returns the result ; dp array of   array of   array untill storing result of f ( i , 1 ) and f ( 1 , 2 ) ; Populating the array dp array of   with - 1 ; Make sure that longest UD and DU sequence starting at each index is calculated ; Assume the answer to be - 1 This value will only increase ; y is the length of the longest UD sequence starting at i ; If length is even then add an integer and then a DU sequence starting at i + y ; If length is odd then add an integer and then a UD sequence starting at i + y ; Driver code
",0
628,"create constant integers cola, rowa, colb, rowb with cola assign to 2, rowa assign to 3, colb assign to 3, rowb assign to 2
declare Kroneckerproduct with integers A array of   array of cola  , B array of   array of colb  , C array of rowa * rowb   array of cola * colb  , as arguments, returning void
untill i assign to 0 to rowa exclusive, increment C by 1, array of j + k + 1   array of A array of i   array of j   * B array of k   array of l  
print C array of i + l + 1   array of j + k + 1   and "" ""
print newline
declare integer main ( ) A assign to 3   array of 2   assign to  1, 2 , 3, 4 , 1, 0  , B assign to  0, 5, 2 , 7, 3
create Kroneckerproduct ( A, B )
return 0
","Kronecker Product of two matrices 
 C ++ code to find the Kronecker Product of two matrices and stores it as matrix C ; rowa and cola are no of rows and columns of matrix A rowb and colb are no of rows and columns of matrix B ; Function to computes the Kronecker Product of two matrices ; i loops till rowa ; k loops till rowb ; j loops till cola ; l loops till colb ; Each element of matrix A is multiplied by whole Matrix B resp and stored as Matrix C ; Driver Code
",1
629,"create constant integers cola, rowa, colb, rowb with cola assign to 2, rowa assign to 3, colb assign to 3, rowb assign to 2
declare Kroneckerproduct with integers A array of   array of cola  , B array of   array of colb  , C array of rowa * rowb   array of cola * colb  , as arguments, returning void
untill i assign to 0 to rowa exclusive, increment C by 1, array of j + k + 1   array of A array of i   array of j   * B array of k   array of l  
print C array of i + l + 1   array of j + k + 1   and "" ""
print newline
declare integer main ( ) A assign to 3   array of 2   assign to  1, 2 , 3, 4 , 1, 0  , B assign to  0, 5, 2 , 7, 3
create Kroneckerproduct ( A, B )
return 0
","Insert node into the middle of the linked list 
 C ++ implementation to insert node at the middle of the linked list ; structure of a node ; function to insert node at the middle of the linked list ; if list is empty ; get a new node ; assign values to the slow and fast pointers ; move slow pointer to next node ; move fast pointer two nodes at a time ; insert the ' newNode ' and adjust the required links ; function to display the linked list ; Driver program to test above ; Creating the list 1 -> 2 -> 4 -> 5
",0
630,"return true
declare integer main ( ) and mat mat ( N   array of N   assign to   1, 0, 0, 0, 0, 0, 0, 0 ,  1, 4, 0, 0, 0 ,  4, 6, 2, 0 , 0, 4, 7, 6
if isLowerTriangularMatrix ( mat) is true, print Yes
else print No
return 0
","Program to check if matrix is lower triangular 
 Program to check lower triangular matrix . ; Function to check matrix is in lower triangular untillm or not . ; Driver function . ; Function call
",1
631,"return true
declare integer main ( ) and mat mat ( N   array of N   assign to   1, 0, 0, 0, 0, 0, 0, 0 ,  1, 4, 0, 0, 0 ,  4, 6, 2, 0 , 0, 4, 7, 6
if isLowerTriangularMatrix ( mat) is true, print Yes
else print No
return 0
","Maximize volume of cuboid with given sum of sides 
 Return the maximum volume . ; Return the maximum volume . ; untill length ; untill breadth ; untill height ; calculating maximum volume . ; Driven Program
",0
632,"return true
declare integer main ( ) and mat mat ( N   array of N   assign to  1, 3, 5, 3 , 0, 4, 6, 2 , 0, 2, 5 , 0, 0, 0, 6        0, 0, 0, 0, 6
if isUpperTriangularMatrix ( mat) is true, print Yes
else print No
return 0
","Program to check if matrix is upper triangular 
 Program to check upper triangular matrix . ; Function to check matrix is in upper triangular untillm or not . ; Driver function .
",1
633,"return true
declare integer main ( ) and mat mat ( N   array of N   assign to  1, 3, 5, 3 , 0, 4, 6, 2 , 0, 2, 5 , 0, 0, 0, 6        0, 0, 0, 0, 6
if isUpperTriangularMatrix ( mat) is true, print Yes
else print No
return 0
","Count set bits in an integer 
  ; Check each bit in a number is set or not and return the total count of the set bits . ; ( 1 << i ) assign to pow ( 2 , i ) ; Driver code
",0
634,"create constant integer m with m assign to 3
create constant integer n with n assign to 2
declare countSets with integer a array of n   array of m   as arguments, returning long long res assign to 0
untill i assign to 0 to n exclusive, set u and v to 0
untill j assign to 0 to m exclusive, increment u if i   array ofj   is true, increment v by 1
increment res by pow ( 2, u ) - 1 + pow ( 2, v ) - 1
untill i assign to 0 to m exclusive, set u assign to 0 and v assign to 0
untill j assign to 0 to n exclusive, increment u if a array of j   array of i   is true, increment u by 1 or v by 1
increment res by pow ( 2, u ) - 1 + pow ( 2, v ) - 1
return res - ( n * m )
declare integer main ( ) and integer array a with size 3, a assign to ( 1, 0, 1 ), ( 0, 1, 0 ), 0, 0 )
print countSets ( a )
return 0
","Counting sets of 1 s and 0 s in a binary matrix 
 CPP program to compute number of sets in a binary matrix . ; no of columns ; no of rows ; function to calculate the number of non empty sets of cell ; stores the final answer ; traverses row - wise ; traverses column wise ; at the end subtract n * m as no of single sets have been added twice . ; driver program to test the above function .
",1
635,"create constant integer m with m assign to 3
create constant integer n with n assign to 2
declare countSets with integer a array of n   array of m   as arguments, returning long long res assign to 0
untill i assign to 0 to n exclusive, set u and v to 0
untill j assign to 0 to m exclusive, increment u if i   array ofj   is true, increment v by 1
increment res by pow ( 2, u ) - 1 + pow ( 2, v ) - 1
untill i assign to 0 to m exclusive, set u assign to 0 and v assign to 0
untill j assign to 0 to n exclusive, increment u if a array of j   array of i   is true, increment u by 1 or v by 1
increment res by pow ( 2, u ) - 1 + pow ( 2, v ) - 1
return res - ( n * m )
declare integer main ( ) and integer array a with size 3, a assign to ( 1, 0, 1 ), ( 0, 1, 0 ), 0, 0 )
print countSets ( a )
return 0
","Check untill an array element that is co 
 C ++ implementation of the approach ; Stores smallest prime factor untill every number ; Hash to store prime factors count ; Function to calculate SPF ( Smallest Prime Factor ) untill every number till MAXN ; Marking smallest prime factor untill every number to be itself ; Separately marking spf untill every even number as 2 ; Checking if i is prime ; Marking SPF untill all numbers divisible by i ; Marking spf array of j   if it is not previously marked ; Function to store the prime factors after dividing by the smallest prime factor at every step ; Storing the count of prime factors in hash ; Function that returns true if there are no common prime factors between x and other numbers of the array ; Checking whether it common prime factor with other numbers ; Function that returns true if there is an element in the array which is coprime with all the other elements of the array ; Using sieve untill generating prime factors ; Checking the common prime factors with other numbers ; Driver code
",0
636,"create constant integer MAX with MAX assign to 100
untill i assign to 0 to N exclusive, tr array of i   array of j   assign to mat array of j   array of i  , int tr array of   array of MAX  , int N )  untill i assign to 0 to N exclusive, increment i i   array of j   assign to mat array of j   array of i  , int tr array of   array of MAX  , int
create boolean isSymmetric (int mat array of   array of MAX , int N) and tr array of N   array of MAX  
transpose mat, tr, N
untill i assign to 0 to N exclusive, return false if mat array of i   array of j   is not tr array of i   array of j  
return true
declare integer main ( ) and mat (   array of MAX   assign to   1, 3, 5 , 3, 2, 4 , 5, 4, 1
if isSymmetric ( mat, 3 ) ) print Yes
else print No
return 0
","Program to check if a matrix is symmetric 
 Simple c ++ code untill check a matrix is symmetric or not . ; Fills transpose of mat array of N   array of N   in tr array of N   array of N   ; Returns true if mat array of N   array of N   is symmetric , else false ; Driver code
",1
637,"create constant integer MAX with MAX assign to 100
untill i assign to 0 to N exclusive, tr array of i   array of j   assign to mat array of j   array of i  , int tr array of   array of MAX  , int N )  untill i assign to 0 to N exclusive, increment i i   array of j   assign to mat array of j   array of i  , int tr array of   array of MAX  , int
create boolean isSymmetric (int mat array of   array of MAX , int N) and tr array of N   array of MAX  
transpose mat, tr, N
untill i assign to 0 to N exclusive, return false if mat array of i   array of j   is not tr array of i   array of j  
return true
declare integer main ( ) and mat (   array of MAX   assign to   1, 3, 5 , 3, 2, 4 , 5, 4, 1
if isSymmetric ( mat, 3 ) ) print Yes
else print No
return 0
","Undulating numbers 
 C ++ program to check whether a number is undulating or not ; Considering the definition with restriction that there should be at least 3 digits ; Check if all alternate digits are same or not . ; Driver code
",0
638,"create constant integer MAX with MAX assign to 100
boolean function isSymmetric with int arguments mat array of   array of MAX   and N, untill i is less than N, return false
return true
declare integer main ( ) and mat (   array of MAX   assign to   1, 3, 5 , 3, 2, 4 , 5, 4, 1
if isSymmetric ( mat, 3 ) ) print Yes
else print No
return 0
","Program to check if a matrix is symmetric 
 Efficient c ++ code untill check a matrix is symmetric or not . ; Returns true if mat array of N   array of N   is symmetric , else false ; Driver code
",1
639,"create constant integer MAX with MAX assign to 100
boolean function isSymmetric with int arguments mat array of   array of MAX   and N, untill i is less than N, return false
return true
declare integer main ( ) and mat (   array of MAX   assign to   1, 3, 5 , 3, 2, 4 , 5, 4, 1
if isSymmetric ( mat, 3 ) ) print Yes
else print No
return 0
","Queries to calculate sum of array elements present at every Yth index starting from the index X 
 C ++ program untill the above approach ; Function to sum of arr array of x   + arr array of x + y   + arr array of x + 2 * y   + ... untill all possible values of X and Y , where Y is less than or equal to sqrt ( N ) . ; Iterate over all possible values of X ; Precompute untill all possible values of an expression such that y <assign to sqrt ( N ) ; If i + j less than N ; Update dp array of i   array of j   ; Update dp array of i   array of j   ; Function to Find the sum of arr array of x   + arr array of x + y   + arr array of x + 2 * y   + ... untill all queries ; dp array of x   array of y   : Stores sum of arr array of x   + arr array of x + y   + arr array of x + 2 * y   + ... ; Traverse the query array , Q array of   array of   ; If y is less than or equal to sqrt ( N ) ; Stores the sum of arr array of x   + arr array of x + y   + arr array of x + 2 * y   + ... ; Traverse the array , arr array of   ; Update sum ; Update x ; Driver Code
",0
640,"create constant integer MAX with MAX assign to 100
declare findNormal with integers mat array of   array of MAX  and n, sum assign to 0
untill i assign to 0 to n exclusive, sum assign to sum + mat array of i   array of j   * mat array of i   array of j    
return sqrt ( sum )
declare findTrace with mat array of   array of MAX , n as arguments, set sum to 0
untill i assign to 0 to n exclusive, sum assign to sum + mat array of i   array of i  
return sum
declare integer main with, 1, 1, 1, 1, 1 , 2, 2, 2 , 3, 3, 3 , 4, 4 , 5, 5, 5 , 5 , 3 , 3 , 3 , 4 , 3 , 3 , 4 , 5, 5 , 5
print "" Trace of Matrix"" print findTrace ( mat, 5 ) print newline
print Normal of Matrix and findNormal ( mat, 5 )
return 0
","Program to find Normal and Trace of a matrix 
 C ++ program to find trace and normal of given matrix ; Size of given matrix ; Returns Normal of a matrix of size n x n ; Returns trace of a matrix of size n x n ; Driven source
",1
641,"create constant integer MAX with MAX assign to 100
declare findNormal with integers mat array of   array of MAX  and n, sum assign to 0
untill i assign to 0 to n exclusive, sum assign to sum + mat array of i   array of j   * mat array of i   array of j    
return sqrt ( sum )
declare findTrace with mat array of   array of MAX , n as arguments, set sum to 0
untill i assign to 0 to n exclusive, sum assign to sum + mat array of i   array of i  
return sum
declare integer main with, 1, 1, 1, 1, 1 , 2, 2, 2 , 3, 3, 3 , 4, 4 , 5, 5, 5 , 5 , 3 , 3 , 3 , 4 , 3 , 3 , 4 , 5, 5 , 5
print "" Trace of Matrix"" print findTrace ( mat, 5 ) print newline
print Normal of Matrix and findNormal ( mat, 5 )
return 0
","Find and Count total factors of co 
 C ++ implementation of the above approach ; Function to return the count of numbers which are divisible by both A and B in the range array of 1 , N   in constant time ; Compute the count of numbers divisible by A in the range array of 1 , N   ; Compute the count of numbers divisible by B in the range array of 1 , N   ; Adding the counts which are divisible by A and B ; The above value might contain repeated values which are divisible by both A and B . Thereuntille , the count of numbers which are divisible by both A and B are found ; The count computed above is subtracted to compute the final count ; Function to return the sum of numbers which are divisible by both A and B in the range array of 1 , N   ; Set to store the numbers so that the numbers are not repeated ; For loop to find the numbers which are divisible by A and insert them into the set ; For loop to find the numbers which are divisible by A and insert them into the set ; For loop to iterate through the set and find the sum ; Driver code
",0
642,"declare maxDet with integer n as argument, returning 2 * n * n * n * n
untill i assign to 0 to 3 exclusive, print ""0 "" if i is 0 and j is 2
else if i is 1 and j is 0, print ""0 ""
else if i is 2 and j is 1 print ""0 ""
else print n and "" ""
print "" STRNEWLINE ""
declare integer main ( ) and integer n assign to 15
print Maximum Determinant and maxDet (n )
print ""Resultant Matrix : "" resMatrix ( n )
return 0
","Maximum determinant of a matrix with every values either 0 or n 
 C ++ program to find maximum possible determinant of 0 / n matrix . ; Function untill maximum determinant ; Function to print resulatant matrix ; three position where 0 appears ; position where n appears ; Driver code
",1
643,"declare maxDet with integer n as argument, returning 2 * n * n * n * n
untill i assign to 0 to 3 exclusive, print ""0 "" if i is 0 and j is 2
else if i is 1 and j is 0, print ""0 ""
else if i is 2 and j is 1 print ""0 ""
else print n and "" ""
print "" STRNEWLINE ""
declare integer main ( ) and integer n assign to 15
print Maximum Determinant and maxDet (n )
print ""Resultant Matrix : "" resMatrix ( n )
return 0
","Maximum possible difference of sum of two subsets of an array 
 Set 2 
 C ++ Program untill the above approach ; Stores the positive elements ; Stores the negative elements ; Stores the count of 0 s ; Sum of all positive numbers ; Sum of all negative numbers ; Iterate over the array ; Stores the difference ; Sort the positive numbers in ascending order ; Sort the negative numbers in decreasing order ; Case 1 : Include both positive and negative numbers ; Put all numbers in subset A and one 0 in subset B ; Put all numbers in subset A except the smallest positive number which is put in B ; Put all numbers in subset B and one 0 in subset A ; Place the largest negative number in subset A and remaining in B ; Driver code
",0
644,"declare integer countNegative ( integer M array of   array of 4  , integer n, integer m )  integer count assign to 0
untill i assign to 0 to n exclusive, increment count by 1 if int j assign to 0 and j  m increment j
else break
return count
declare integer main ( ) and integer M assign to  -3, -2, -1, 1 , -2, 2, 3, 4 , 4, 5, 7, 8
print countNegative ( M, 3, 4 )
return 0
","Count Negative Numbers in a Column 
 CPP implementation of Naive method to count of negative numbers in M array of n   array of m   ; Follow the path shown using arrows above ; no more negative numbers in this row ; Driver program to test above functions
",1
645,"declare integer countNegative ( integer M array of   array of 4  , integer n, integer m )  integer count assign to 0
untill i assign to 0 to n exclusive, increment count by 1 if int j assign to 0 and j  m increment j
else break
return count
declare integer main ( ) and integer M assign to  -3, -2, -1, 1 , -2, 2, 3, 4 , 4, 5, 7, 8
print countNegative ( M, 3, 4 )
return 0
","Check whether a given point lies on or inside the rectangle 
 Set 3 
 C ++ program to Check whether a given point lies inside or on the rectangle or not ; function to Check whether a given point lies inside or on the rectangle or not ; Driver code
",0
646,"declare integer countNegative ( integer M array of   array of 4  , integer n, integer m )  integer count assign to 0
create integer i with i assign to 0
create integer j with j assign to m - 1
untill j >assign to 0 and i  n, increment count by j + 1
increment i by 1
else j assign to j - 1
return count
declare integer main ( ) and integer M assign to  -3, -2, -1, 1 , -2, 2, 3, 4 , 4, 5, 7, 8
print countNegative ( M, 3, 4 )
return 0
","Count Negative Numbers in a Column 
 CPP implementation of Efficient method to count of negative numbers in M array of n   array of m   ; Function to count negative number ; initialize result ; Start with top right corner ; Follow the path shown using arrows above ; j is the index of the last negative number in this row . So there must be ( j + 1 ) ; negative numbers in this row . ; move to the left and see if we can find a negative number there ; Driver program to test above functions
",1
647,"declare integer countNegative ( integer M array of   array of 4  , integer n, integer m )  integer count assign to 0
create integer i with i assign to 0
create integer j with j assign to m - 1
untill j >assign to 0 and i  n, increment count by j + 1
increment i by 1
else j assign to j - 1
return count
declare integer main ( ) and integer M assign to  -3, -2, -1, 1 , -2, 2, 3, 4 , 4, 5, 7, 8
print countNegative ( M, 3, 4 )
return 0
","Minimize cost of removals required to make all remaining characters of the string unique 
 C ++ program to implement the above approach ; Function to find the minimum cost of removing characters to make the String unique ; stores the visited character ; stores the answer ; traverse the String ; if already visited ; Stores the maximum cost of removing a particular character ; Store the total deletion cost of a particular character ; Mark the current character visited ; Traverse the indices of the String array of i , N - 1   ; If any duplicate is found ; Update the maximum cost and total cost ; Mark the current character visited ; Keep the character with maximum cost and delete the rest ; return the minimum cost ; Driver code ; input String ; input array ; function call
",0
648,"declare getLastNegativeIndex with array array of integers array of size  , start, end, n as arguments, returning start
mid assign to integer with mid assign to start + ( end - start ) / 2
if array array of mid  is less than 0, if mid + 1 is less than n and array array of mid + 1   is greater than or equal to 0 return mid
return getLastNegativeIndex ( array, mid + 1, end, n )
else return getLastNegativeIndex ( array, start, mid - 1, n )
countNegative assign to integer with M array of   array of 4  , n, m, count assign to 0
nextEnd assign to integer with nextEnd assign to m - 1
untill i assign to 0 to n exclusive, break if M array of i   array of 0   >assign to 0
set nextEnd to getLastNegativeIndex ( M array of i  , 0, nextEnd, 4 )
increment count by nextEnd + 1
return count
declare integer main ( ) and integer M assign to  -3, -2, -1, 1 , -2, 2, 3, 4 , 4, 5, 7, 8
r assign to integer with r assign to 3
create integer c with c assign to 4
print countNegative ( M, r, c )
return 0
","Count Negative Numbers in a Column 
 C ++ implementation of More efficient method to count number of negative numbers in row - column sorted matrix M array of n   array of m   ; Recursive binary search to get last negative value in a row between a start and an end ; Base case ; Get the mid untill binary search ; If current element is negative ; If it is the rightmost negative element in the current row ; Check in the right half of the array ; Check in the left half of the array ; Function to return the count of negative numbers in the given matrix ; Initialize result ; To store the index of the rightmost negative element in the row under consideration ; Iterate over all rows of the matrix ; If the first element of the current row is positive then there will be no negatives in the matrix below or after it ; Run binary search only until the index of last negative Integer in the above row ; Driver code
",1
649,"declare getLastNegativeIndex with array array of integers array of size  , start, end, n as arguments, returning start
mid assign to integer with mid assign to start + ( end - start ) / 2
if array array of mid  is less than 0, if mid + 1 is less than n and array array of mid + 1   is greater than or equal to 0 return mid
return getLastNegativeIndex ( array, mid + 1, end, n )
else return getLastNegativeIndex ( array, start, mid - 1, n )
countNegative assign to integer with M array of   array of 4  , n, m, count assign to 0
nextEnd assign to integer with nextEnd assign to m - 1
untill i assign to 0 to n exclusive, break if M array of i   array of 0   >assign to 0
set nextEnd to getLastNegativeIndex ( M array of i  , 0, nextEnd, 4 )
increment count by nextEnd + 1
return count
declare integer main ( ) and integer M assign to  -3, -2, -1, 1 , -2, 2, 3, 4 , 4, 5, 7, 8
r assign to integer with r assign to 3
create integer c with c assign to 4
print countNegative ( M, r, c )
return 0
","Find a pair ( a , b ) such that Aa + Bb assign to N 
 C ++ program untill the above approach ; Function to calculate the minimum power of A and B greater than N ; Stores the power of A which is greater than N ; Increment count by 1 ; Divide N by A ; Function to find a pair ( a , b ) such that A to the power a + B to the power b assign to N ; Calculate the minimum power of A greater than N ; Calculate the minimum power of B greater than N ; Make copy of A and B ; Traverse untill every pair ( i , j ) ; Check if B to the power j + A to the power i assign to N To overcome the overflow problem use B assign to N - A rather than B + A assign to N ; Increment power B by 1 ; Increment power A by 1 ; Finally print - 1 if no pair is found ; Driver Code ; Given A , B and N ; Function Call
",0
650,"declare findMaxValue with integer mat array of   array of N   as argument, adding INT_MIN to int
untill a assign to 0 to N - 1 exclusive, set maxValue to mat array of d   array of e   - mat array of a   array of b   ) if int b assign to 0, b  N - 1, increment d by 1, increment e if maxValue is less than ( int d   array of e   - mat array of a   array of b   )
return maxValue
declare integer main with N, integer mat assign to   1, 2, -1, -4, -20 , -8, 4, 2, 1 ,  3, 8, 6, 1, 3 , -4, -1, 7, -6 , 0, -4, 10, -5, 1
print Maximum Value is and findMaxValue ( mat)
return 0
","Find a specific pair in Matrix 
 A Naive method to find maximum value of mat array of d   array of e   - ma array of a   array of b   such that d > a and e > b ; The function returns maximum value A ( d , e ) - A ( a , b ) over all choices of indexes such that both d > a and e > b . ; stores maximum value ; Consider all possible pairs mat array of a   array of b   and mat array of d   array of e   ; Driver program to test above function
",1
651,"declare findMaxValue with integer mat array of   array of N   as argument, adding INT_MIN to int
untill a assign to 0 to N - 1 exclusive, set maxValue to mat array of d   array of e   - mat array of a   array of b   ) if int b assign to 0, b  N - 1, increment d by 1, increment e if maxValue is less than ( int d   array of e   - mat array of a   array of b   )
return maxValue
declare integer main with N, integer mat assign to   1, 2, -1, -4, -20 , -8, 4, 2, 1 ,  3, 8, 6, 1, 3 , -4, -1, 7, -6 , 0, -4, 10, -5, 1
print Maximum Value is and findMaxValue ( mat)
return 0
","Pair untillmation such that maximum pair sum is minimized 
 CPP Program to divide the array into N pairs such that maximum pair is minimized ; After Sorting Maintain two variables i and j pointing to start and end of array Such that smallest element of array pairs with largest element ; Driver Code
",0
652,"declare findMaxValue with integer mat array of   array of N   as argument, adding INT_MIN to int
create integer maxArr array of N   array of N  
maxArr array of N - 1  array of N - 1  assign to mat array of N - 1  array of N - 1 
create integer maxv with maxv assign to mat array of N - 1   array of N - 1  
untill j assign to N - 2 to 0 inclusive, if mat array of N - 1  array of j   > maxv, maxv assign to mat array of N - 1   array of j  
maxArr array of N - 1  array of j   assign to maxv
set maxv to mat array of N - 1  array of N - 1 
untill i assign to N - 2 to 0 inclusive, if mat array of i   array of N - 1   > maxv, maxv assign to mat array of i   array of N - 1  
maxArr array of i   array of N - 1   assign to maxv
untill i assign to N - 2 to 0 inclusive, set maxValue to maxArr array of i + 1  array of j + 1   - mat array of i   array of j + 1   - mat array of i   array of j   > maxValue ), set maxValue to maxArr array of i + 1   array of j + 1   - mat array of i   array of j   array of j   - mat array of
maxArr array of i   array ofj   assign to max ( mat array of i   array of j  , max ( maxArr array of i   array of j + 1  , maxArr array of i + 1   array of j   ) )
return maxValue
declare integer main with N, integer mat assign to   1, 2, -1, -4, -20 , -8, 4, 2, 1 ,  3, 8, 6, 1, 3 , -4, -1, 7, -6 , 0, -4, 10, -5, 1
print Maximum Value is and findMaxValue ( mat)
return 0
","Find a specific pair in Matrix 
 An efficient method to find maximum value of mat array of d   - ma array of a   array of b   such that c > a and d > b ; The function returns maximum value A ( c , d ) - A ( a , b ) over all choices of indexes such that both c > a and d > b . ; stores maximum value ; maxArr array of i   array of j   stores max of elements in matrix from ( i , j ) to ( N - 1 , N - 1 ) ; last element of maxArr will be same 's as of  the input matrix ; preprocess last row Initialize max ; preprocess last column Initialize max ; preprocess rest of the matrix from bottom ; Update maxValue ; set maxArr ( i , j ) ; Driver program to test above function
",1
653,"declare findMaxValue with integer mat array of   array of N   as argument, adding INT_MIN to int
create integer maxArr array of N   array of N  
maxArr array of N - 1  array of N - 1  assign to mat array of N - 1  array of N - 1 
create integer maxv with maxv assign to mat array of N - 1   array of N - 1  
untill j assign to N - 2 to 0 inclusive, if mat array of N - 1  array of j   > maxv, maxv assign to mat array of N - 1   array of j  
maxArr array of N - 1  array of j   assign to maxv
set maxv to mat array of N - 1  array of N - 1 
untill i assign to N - 2 to 0 inclusive, if mat array of i   array of N - 1   > maxv, maxv assign to mat array of i   array of N - 1  
maxArr array of i   array of N - 1   assign to maxv
untill i assign to N - 2 to 0 inclusive, set maxValue to maxArr array of i + 1  array of j + 1   - mat array of i   array of j + 1   - mat array of i   array of j   > maxValue ), set maxValue to maxArr array of i + 1   array of j + 1   - mat array of i   array of j   array of j   - mat array of
maxArr array of i   array ofj   assign to max ( mat array of i   array of j  , max ( maxArr array of i   array of j + 1  , maxArr array of i + 1   array of j   ) )
return maxValue
declare integer main with N, integer mat assign to   1, 2, -1, -4, -20 , -8, 4, 2, 1 ,  3, 8, 6, 1, 3 , -4, -1, 7, -6 , 0, -4, 10, -5, 1
print Maximum Value is and findMaxValue ( mat)
return 0
","Rearrange Array to find K using Binary Search algorithm without sorting 
 C ++ program untill the above approach ; Function to rearrange the array ; Stores the rearranged array ; Stores whether the arrangement is possible or not ; Update K with the position of K ; Stores all elements lesser than and greater than in vector smaller and greater respectively ; Traverse the array arr array of   ; If arr array of i   is less than arr array of K   ; Else ; Iterate unil low is less than or equal to high ; Stores mid point ; If mid is equal to K ; If mid is less than K ; If mid is greater than K ; If f is - 1 ; Iterate in the range array of 1 , N   ; If ans array of i   is equal to - 1 ; Print the rearranged array ; Driver Code ; Input ; Function Call
",0
654,"let youngify be a void function with int arguments mat array of   array of N   and j, or downVal assign to ( i + 1  N ) if mat array of i + 1   array of j   is true, then let downVal be a void function
let rightVal be a integer, set to mat array of i   array of j + 1   : INF
if downVal is INF and rightVal is INF return
if downVal is less than rightVal, set mat array of i   array of j   to downVal
set mat array of i + 1   array of j   to INF
let youngify be a......................................................
else set mat array of i   array of j   to rightVal
set mat array of i   array of j + 1   to INF
let youngify be a stdout of mat, i, j + 1
create integer extractMin (int mat array of   array of N   ) ) ret assign to mat array of 0   array of 0  
set mat array of 0   array of 0   to INF
let youngify be a stdout of mat, 0 and 0
return ret
printSorted is a void function
untill i assign to 0 to N * N exclusive, print extractMin ( mat) print "" ""
declare integer main ( ) and integer mat ( N   array of N   assign to  10, 20, 30, 40 , 15, 25, 35, 45 , 27, 29, 37, 48 , 32, 33, 39, 50 ,  ;
printSorted is a new line
return 0
","Print all elements in sorted order from row and column wise sorted matrix 
 A C ++ program to Print all elements in sorted order from row and column wise sorted matrix ; A utility function to youngify a Young Tableau . This is different from standard youngify . It assumes that the value at mat array of 0   array of 0   is infinite . ; Find the values at down and right sides of mat array of i   array of j   ; If mat array of i   array of j   is the down right corner element , return ; Move the smaller of two values ( downVal and rightVal ) to mat array of i   array of j   and recur untill smaller value ; A utility function to extract minimum element from Young tableau ; This function uses extractMin ( ) to print elements in sorted order ; driver program to test above function
",1
655,"let youngify be a void function with int arguments mat array of   array of N   and j, or downVal assign to ( i + 1  N ) if mat array of i + 1   array of j   is true, then let downVal be a void function
let rightVal be a integer, set to mat array of i   array of j + 1   : INF
if downVal is INF and rightVal is INF return
if downVal is less than rightVal, set mat array of i   array of j   to downVal
set mat array of i + 1   array of j   to INF
let youngify be a......................................................
else set mat array of i   array of j   to rightVal
set mat array of i   array of j + 1   to INF
let youngify be a stdout of mat, i, j + 1
create integer extractMin (int mat array of   array of N   ) ) ret assign to mat array of 0   array of 0  
set mat array of 0   array of 0   to INF
let youngify be a stdout of mat, 0 and 0
return ret
printSorted is a void function
untill i assign to 0 to N * N exclusive, print extractMin ( mat) print "" ""
declare integer main ( ) and integer mat ( N   array of N   assign to  10, 20, 30, 40 , 15, 25, 35, 45 , 27, 29, 37, 48 , 32, 33, 39, 50 ,  ;
printSorted is a new line
return 0
","Minimum sum possible by removing all occurrences of any array element 
 C ++ program untill the above approach ; Function to find minimum sum after deletion ; Stores frequency of array elements ; Traverse the array ; Calculate sum ; Update frequency of the current element ; Stores the minimum sum required ; Traverse map ; Find the minimum sum obtained ; Return minimum sum ; Driver code ; Input array ; Size of array
",0
656,"void function printSumSimple (int mat array of   array of n  , int k) if k is greater than n, return )
untill i assign to 0 to n - k + 1 exclusive, set sum to 0
untill p assign to i to k + i exclusive, increment sum by mat array of p   array of q  
print sum and "" ""
print a new line
let mat be a integer array with size n, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 5, 5, 5, 5 , 3 ;
create integer k with k assign to 3
printSumSimple ( mat, k )
return 0
","Given an n x n square matrix , find sum of all sub 
 A simple C ++ program to find sum of all subsquares of size k x k ; Size of given matrix ; A simple function to find sum of all sub - squares of size k x k in a given square matrix of size n x n ; k must be smaller than or equal to n ; row number of first cell in current sub - square of size k x k ; column of first cell in current sub - square of size k x k ; Calculate and print sum of current sub - square ; Line separator untill sub - squares starting with next row ; Driver program to test above function
",1
657,"void function printSumSimple (int mat array of   array of n  , int k) if k is greater than n, return )
untill i assign to 0 to n - k + 1 exclusive, set sum to 0
untill p assign to i to k + i exclusive, increment sum by mat array of p   array of q  
print sum and "" ""
print a new line
let mat be a integer array with size n, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 5, 5, 5, 5 , 3 ;
create integer k with k assign to 3
printSumSimple ( mat, k )
return 0
","Farthest distance of a Node from each Node of a Tree 
 C ++ Program to implement the above approach ; Adjacency List to store the graph ; Stores the height of each node ; Stores the maximum distance of a node from its ancestors ; Function to add edge between two vertices ; Insert edge from u to v ; Insert edge from v to u ; Function to calculate height of each Node ; Iterate in the adjacency list of the current node ; Dfs untill child node ; Calculate height of nodes ; Increase height ; Function to calculate the maximum distance of a node from its ancestor ; Iterate in the adjacency list of the current node ; Find two children with maximum heights ; Calculate the maximum distance with ancestor untill every node ; Calculating untill children ; Driver Code ; Calculate height of nodes of the tree ; Calculate the maximum distance with ancestors ; Print the maximum of the two distances from each node
",0
658,"void function printSumTricky with int arguments mat array of   array of n   and k, if k is greater than n, return
create integer stripSum array of n   array of n  
untill j assign to 0 to n exclusive, sum assign to 0
untill i assign to 0 to k exclusive, sum assign to sum + mat array of i   array of j  
stripSum array of 0   array of j   assign to sum
untill i assign to 1 to n - k + 1 exclusive, increment sum by mat array of i + k - 1   array of j   - mat array of i - 1   array of j   )
set stripSum array of i   array of j   to sum
untill i assign to 0 to n - k + 1 exclusive, sum assign to 0
untill j assign to 0 to k exclusive, add stripSum array of i   array of j   to sum
print sum and "" ""
untill j assign to 1 to n - k + 1 exclusive, add ( stripSum array of i   array of j + k - 1   - stripSum array of i   array of j - 1   ) to sum
print sum and "" ""
print a new line
let mat be a integer array with size n, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 5, 5, 5, 5 , 3 ;
create integer k with k assign to 3
printSumTricky ( mat, k )
return 0
","Given an n x n square matrix , find sum of all sub 
 An efficient C ++ program to find sum of all subsquares of size k x k ; Size of given matrix ; A O ( n to the power 2 ) function to find sum of all sub - squares of size k x k in a given square matrix of size n x n ; k must be smaller than or equal to n ; 1 : PREPROCESSING To store sums of all strips of size k x 1 ; Go column by column ; Calculate sum of first k x 1 rectangle in this column ; Calculate sum of remaining rectangles ; 2 : CALCULATE SUM of Sub - Squares using stripSum array of   array of   ; Calculate and print sum of first subsquare in this row ; Calculate sum of remaining squares in current row by removing the leftmost strip of previous sub - square and adding a new strip ; Driver program to test above function
",1
659,"void function printSumTricky with int arguments mat array of   array of n   and k, if k is greater than n, return
create integer stripSum array of n   array of n  
untill j assign to 0 to n exclusive, sum assign to 0
untill i assign to 0 to k exclusive, sum assign to sum + mat array of i   array of j  
stripSum array of 0   array of j   assign to sum
untill i assign to 1 to n - k + 1 exclusive, increment sum by mat array of i + k - 1   array of j   - mat array of i - 1   array of j   )
set stripSum array of i   array of j   to sum
untill i assign to 0 to n - k + 1 exclusive, sum assign to 0
untill j assign to 0 to k exclusive, add stripSum array of i   array of j   to sum
print sum and "" ""
untill j assign to 1 to n - k + 1 exclusive, add ( stripSum array of i   array of j + k - 1   - stripSum array of i   array of j - 1   ) to sum
print sum and "" ""
print a new line
let mat be a integer array with size n, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 5, 5, 5, 5 , 3 ;
create integer k with k assign to 3
printSumTricky ( mat, k )
return 0
","Double Knapsack 
 Dynamic Programming 
 C ++ implementation of the above approach ; 3D array to store states of DP ; w1_r represents remaining capacity of 1 st knapsack w2_r represents remaining capacity of 2 nd knapsack i represents index of the array arr we are working on ; Base case ; Variables to store the result of three parts of recurrence relation ; Store the state in the 3D array ; Driver code ; Input array ; Initializing the array with - 1 ; Number of elements in the array ; Capacity of knapsacks ; Function to be called
",0
660,"declare transpose ( int A array of   array of N , int B array of   array of M   ), int i, j
untill i assign to 0 to N exclusive, B array of i   array of j   assign to A array of j   array of i  
declare integer main ( ) and integer array A ( M ) ( N ) assign to   1, 1, 1, 1 , 2, 2, 2 , 3, 3, 3
declare integers B array of N   array of M  , i, j
transpose A, B
printf is a new line
untill i assign to 0 to N exclusive, printf ( "" % d "", B array of i   array of j   )
printf is a new line
return 0
","Program to find transpose of a matrix 
  ; This function stores transpose of A array of   array of   in B array of   array of   ; Driver code
",1
661,"declare transpose ( int A array of   array of N , int B array of   array of M   ), int i, j
untill i assign to 0 to N exclusive, B array of i   array of j   assign to A array of j   array of i  
declare integer main ( ) and integer array A ( M ) ( N ) assign to   1, 1, 1, 1 , 2, 2, 2 , 3, 3, 3
declare integers B array of N   array of M  , i, j
transpose A, B
printf is a new line
untill i assign to 0 to N exclusive, printf ( "" % d "", B array of i   array of j   )
printf is a new line
return 0
","Count ways to reach a score using 1 and 2 with no consecutive 2 s 
 Bottom up approach untill counting ways to reach a score using 1 and 2 with consecutive 2 allowed ; noOfWays array of i   will store count untill value i . 3 extra values are to take care of corner case n assign to 0 ; Loop till "" n + 1"" to compute value untill "" n "" ; number of ways if first run is 1 ; Driver code
",0
662,"untill i assign to 0 to N exclusive, swap A array of i   array of j  , A array of j   array of i   )
declare integer main ( ) and integer array A with size N, N, A assign to  1, 1, 1, 1 , 2, 2 , 3, 3, 3 , 4, 4, 4
transpose A
printf is a new line
untill i assign to 0 to N exclusive, printf ( "" % d "", A array of i   array of j   )
printf is a new line
return 0
","Program to find transpose of a matrix 
  ; Converts A array of   array of   to its transpose ; Driver Code
",1
663,"untill i assign to 0 to N exclusive, swap A array of i   array of j  , A array of j   array of i   )
declare integer main ( ) and integer array A with size N, N, A assign to  1, 1, 1, 1 , 2, 2 , 3, 3, 3 , 4, 4, 4
transpose A
printf is a new line
untill i assign to 0 to N exclusive, printf ( "" % d "", A array of i   array of j   )
printf is a new line
return 0
","Maximize count of corresponding same elements in given Arrays by Rotation 
 C ++ program of the above approach ; Function that prints maximum equal elements ; Vector to store the index of elements of array b ; Storing the positions of array B ; frequency array to keep count of elements with similar difference in distances ; Iterate through all element in arr1 array of   ; Calculate number of shift required to make current element equal ; If d is less than 0 ; Store the frequency of current diff ; Compute the maximum frequency stored ; Printing the maximum number of equal elements ; Driver Code ; Given two arrays ; Function Call
",0
664,"return 0 if m is less than 0 n is less than 0
if m is 0 and n is 0, return ( k is mat array of m   array of n   )
return pathCountRec ( mat, m - 1, n, k - mat array of m   array of n   ) + pathCountRec ( mat, m, n - 1, k - mat array of m   array of n   )
return pathCountRec ( mat, R - 1, C - 1, k )
declare integer main ( ) and integer k assign to 12
create integer mat with R   array of C  assign to   1, 2, 3 , 4, 6, 5 , 3, 2, 1
print pathCount ( mat, k )
return 0
","Number of paths with exactly k coins 
 A Naive Recursive C ++ program to count paths with exactly ' k ' coins ; Recursive function to count paths with sum k from ( 0 , 0 ) to ( m , n ) ; Base cases ; ( m , n ) can be reached either through ( m - 1 , n ) or through ( m , n - 1 ) ; A wrapper over pathCountRec ( ) ; Driver program
",1
665,"return 0 if m is less than 0 n is less than 0
if m is 0 and n is 0, return ( k is mat array of m   array of n   )
return pathCountRec ( mat, m - 1, n, k - mat array of m   array of n   ) + pathCountRec ( mat, m, n - 1, k - mat array of m   array of n   )
return pathCountRec ( mat, R - 1, C - 1, k )
declare integer main ( ) and integer k assign to 12
create integer mat with R   array of C  assign to   1, 2, 3 , 4, 6, 5 , 3, 2, 1
print pathCount ( mat, k )
return 0
","Count rows with sum exceeding sum of the remaining Matrix 
 C ++ program to implement the above approach ; Function to count the number of rows whose sum exceeds the sum of elements of the remaining matrix ; To store the result ; Stores the total sum of the matrix elements ; Calculate the total sum ; Traverse to check untill each row ; Stores the sum of elements of the current row ; Calculate the sum of elements of the current row ; If sum of current row exceeds the sum of rest of the matrix ; Increase count ; Print the result ; Driver Code ; Given matrix ; Function Call
",0
666,"create integer dp array of R  array of C  array of MAX_K 
if m is less than 0 n is less than 0, return 0
if m is 0 and n is 0, return ( k is mat array of m   array of n   )
if dp array of m   array of n   array of k   is not -1, return dp array of m   array of n   array of k  
dp array of m   array of n   array of k   assign to pathCountDPRecDP ( mat, m - 1, n, k - mat array of m   array of n   ) + pathCountDPRecDP ( mat, m, n - 1, k - mat array of m   array of n   )
return dp array of m   array of n   array of k  
declare pathCountDP with integers mat array of   array of C , k, memset ( dp, -1, sizeof dp ) as arguments
return pathCountDPRecDP ( mat, R - 1, C - 1, k )
declare integer main ( ) and integer k assign to 12
create integer mat with R   array of C  assign to   1, 2, 3 , 4, 6, 5 , 3, 2, 1
print pathCountDP ( mat, k )
return 0
","Number of paths with exactly k coins 
 A Dynamic Programming based C ++ program to count paths with exactly ' k ' coins ; Base cases ; If this subproblem is already solved ; ( m , n ) can be reached either through ( m - 1 , n ) or through ( m , n - 1 ) ; This function mainly initializes dp array of   array of   array of   and calls pathCountDPRecDP ( ) ; Driver Program to test above functions
",1
667,"create integer dp array of R  array of C  array of MAX_K 
if m is less than 0 n is less than 0, return 0
if m is 0 and n is 0, return ( k is mat array of m   array of n   )
if dp array of m   array of n   array of k   is not -1, return dp array of m   array of n   array of k  
dp array of m   array of n   array of k   assign to pathCountDPRecDP ( mat, m - 1, n, k - mat array of m   array of n   ) + pathCountDPRecDP ( mat, m, n - 1, k - mat array of m   array of n   )
return dp array of m   array of n   array of k  
declare pathCountDP with integers mat array of   array of C , k, memset ( dp, -1, sizeof dp ) as arguments
return pathCountDPRecDP ( mat, R - 1, C - 1, k )
declare integer main ( ) and integer k assign to 12
create integer mat with R   array of C  assign to   1, 2, 3 , 4, 6, 5 , 3, 2, 1
print pathCountDP ( mat, k )
return 0
","Count ways to reach a score using 1 and 2 with no consecutive 2 s 
 Bottom up approach untill counting ways to reach a score using 1 and 2 with consecutive 2 allowed ; noOfWays array of i   will store count untill last 3 values beuntille i . ; Loop till "" n + 1"" to compute value untill "" n "" ; number of ways if first run is 1 ; number of ways if first run is 2 and second run is 1 ; Remember last 3 values ; Driver code
",0
668,"declare sortMat with integers mat array of SIZE   array of SIZE  , n, temp array of n * n   as arguments, returning void
create integer k with k assign to 0
untill i assign to 0 to n exclusive, temp array of k ++   assign to mat array of i   array of j  
sort temp by k
set k to 0
untill i assign to 0 to n exclusive, mat array of i   array of j   assign to temp array of k ++  
printMat is a void function with int arguments mat and j with SIZE and SIZE and n and a new line, printMat and a new line, with j assign to 0 and j  n, print mat and j, "" ""
print newline
let main be a integer, mat assign to a integer array of size SIZE, SIZE, SIZE, a integer array of size SIZE, and a integer array of size SIZE, set to 5, 4, 7, 1, 3, 8, 2, 9, 6, 6,    ;
n assign to integer with n assign to 3
print Original Matrix : STRNEWLINE
printMat is a new line
sortMat ( mat, n )
print Matrix After Sorting :
printMat is a new line
return 0
","Sort the given matrix 
 C ++ implementation to sort the given matrix ; function to sort the given matrix ; temporary matrix of size n to the power 2 ; copy the elements of matrix one by one into temp array of   ; sort temp array of   ; copy the elements of temp array of   one by one in mat array of   array of   ; function to print the given matrix ; Driver program to test above
",1
669,"declare sortMat with integers mat array of SIZE   array of SIZE  , n, temp array of n * n   as arguments, returning void
create integer k with k assign to 0
untill i assign to 0 to n exclusive, temp array of k ++   assign to mat array of i   array of j  
sort temp by k
set k to 0
untill i assign to 0 to n exclusive, mat array of i   array of j   assign to temp array of k ++  
printMat is a void function with int arguments mat and j with SIZE and SIZE and n and a new line, printMat and a new line, with j assign to 0 and j  n, print mat and j, "" ""
print newline
let main be a integer, mat assign to a integer array of size SIZE, SIZE, SIZE, a integer array of size SIZE, and a integer array of size SIZE, set to 5, 4, 7, 1, 3, 8, 2, 9, 6, 6,    ;
n assign to integer with n assign to 3
print Original Matrix : STRNEWLINE
printMat is a new line
sortMat ( mat, n )
print Matrix After Sorting :
printMat is a new line
return 0
","Subtract Two Numbers represented as Linked Lists 
 C ++ program to subtract smaller valued list from larger valued list and return result as a list . ; A linked List Node ; A utility function to get length of linked list ; A Utility that padds zeros in front of the Node , with the given diff ; Subtract LinkedList Helper is a recursive function , move till the last Node , and subtract the digits and create the Node and return the Node . If d1 < d2 , we borrow the number from previous digit . ; if you have given the value value to next digit then reduce the d1 by 1 ; If d1 < d2 , then borrow the number from previous digit . Add 10 to d1 and set borrow assign to true ; ; subtract the digits ; Create a Node with sub value ; Set the Next pointer as Previous ; This API subtracts two linked lists and returns the linked list which shall have the subtracted result . ; Base Case . ; In either of the case , get the lengths of both Linked list . ; If lengths differ , calculate the smaller Node and padd zeros untill smaller Node and ensure both larger Node and smaller Node has equal length . ; If both list lengths are equal , then calculate the larger and smaller list . If 5 - 6 - 7 & 5 - 6 - 8 are linked list , then walk through linked list at last Node as 7 < 8 , larger Node is 5 - 6 - 8 and smaller Node is 5 - 6 - 7. ; After calculating larger and smaller Node , call subtractLinkedListHelper which returns the subtracted linked list . ; A utility function to print linked list ; Driver program to test above functions
",0
670,"declare swap with integers * xp, yp, temp assign to * xp as arguments, returning integer
* xp assign to * yp
set yp to temp
declare selectionSort with integer arr array of  , integer n, integers i, j, min_idx
untill i assign to 0 to n - 1 exclusive, min_idx assign to i
untill j assign to i + 1 to n exclusive, if arr array ofj   arr array of min_idx  , min_idx assign to j
swap & arr array of min_idx , & arr array of i  
printArray is a new array of integers arr, size and i
untill i assign to 0 to size exclusive, print arr array of i  and "" ""
print newline
declare integer main ( ), integer arr assign to  64, 25, 12, 22, 11  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
call selectionSort ( arr, n )
print Sorted array : STRNEWLINE
printArray ( arr, n )
return 0
","Selection Sort 
 C ++ program untill implementation of selection sort ; swap function ; sort function ; One by one move boundary of unsorted subarray ; Find the minimum element in unsorted array ; Swap the found minimum element with the first element ; Function to print an array ; Driver program to test above functions
",1
671,"declare swap with integers * xp, yp, temp assign to * xp as arguments, returning integer
* xp assign to * yp
set yp to temp
declare selectionSort with integer arr array of  , integer n, integers i, j, min_idx
untill i assign to 0 to n - 1 exclusive, min_idx assign to i
untill j assign to i + 1 to n exclusive, if arr array ofj   arr array of min_idx  , min_idx assign to j
swap & arr array of min_idx , & arr array of i  
printArray is a new array of integers arr, size and i
untill i assign to 0 to size exclusive, print arr array of i  and "" ""
print newline
declare integer main ( ), integer arr assign to  64, 25, 12, 22, 11  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
call selectionSort ( arr, n )
print Sorted array : STRNEWLINE
printArray ( arr, n )
return 0
","Sort a Rotated Sorted Array 
 C ++ implementation untill restoring original sort in rotated sorted array using binary search ; Function to find start index of array ; Function to restore the Original Sort ; array is already sorted ; In reverse ( ) , the first parameter is iterator to beginning element and second parameter is iterator to last element plus one . ; Function to print the Array ; Driver function
",0
672,"declare swap with integers * xp, yp, temp assign to * xp as arguments, returning integer
* xp assign to * yp
set yp to temp
declare bubbleSort with integer arr array of  , integer n, integers i, j
swap boolean
untill i assign to 0 to n - 1 exclusive, swapped assign to false
untill j assign to 0 to n - i - 1 exclusive, swap ( & arr array of j  , & arr array of j + 1   )
swapped assign to true
if swapped is false, break loop
printArray is a new array of integers arr, size and i
untill i assign to 0 to size exclusive printf ( "" % d "", arr array of i   )
printf ( "" n "" )
declare integer main ( ), integer arr assign to  64, 34, 25, 12, 22, 11, 90
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
bubbleSort assign to arr, n
printf is a new line
printArray ( arr, n )
return 0
","Bubble Sort 
 Optimized implementation of Bubble sort ; An optimized version of Bubble Sort ; swap arr array of j   and arr array of j + 1   ; IF no two elements were swapped by inner loop , then break ; Function to print an array ; Driver program to test above functions
",1
673,"declare swap with integers * xp, yp, temp assign to * xp as arguments, returning integer
* xp assign to * yp
set yp to temp
declare bubbleSort with integer arr array of  , integer n, integers i, j
swap boolean
untill i assign to 0 to n - 1 exclusive, swapped assign to false
untill j assign to 0 to n - i - 1 exclusive, swap ( & arr array of j  , & arr array of j + 1   )
swapped assign to true
if swapped is false, break loop
printArray is a new array of integers arr, size and i
untill i assign to 0 to size exclusive printf ( "" % d "", arr array of i   )
printf ( "" n "" )
declare integer main ( ), integer arr assign to  64, 34, 25, 12, 22, 11, 90
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
bubbleSort assign to arr, n
printf is a new line
printArray ( arr, n )
return 0
","Sum of all products of the Binomial Coefficients of two numbers up to K 
 C ++ implementation of the above approach ; Function returns nCr i . e . Binomial Coefficient ; Initialize res with 1 ; Since C ( n , r ) assign to C ( n , n - r ) ; Evaluating expression ; Driver Code
",0
674,"declare findCrossOver with integer arr array of  , low, high, x as arguments, returning high if arr array of high  is less than or equal to x
if arr array of low  is greater than x, return low
mid assign to integer with mid assign to ( low + high ) / 2
if arr array of mid  assign to x and arr array of mid + 1   > x, return mid
if arr array of mid  is less than x, return findCrossOver ( arr, mid + 1, high, x )
return findCrossOver ( arr, low, mid - 1, x )
printKclosest is a void function with int arguments arr array of  , x, k, n, and l assign to findCrossOver ( arr, 0, n - 1, x )
create integer r with r assign to l + 1
create integer count with count assign to 0
if arr array of l   is x, decrement l
untill l >assign to 0 and r  n and count  k, printf ( "" % d "", arr array of l --   )
else printf ( "" % d "", arr array of r   )
increment count
untill count  k and l >assign to 0, printf ( "" % d "", arr array of l --   ), count ++
untill count  k and r  n printf ( "" % d "", arr array of r ++   ), count ++
declare integer main ( ) and integer array arr with size   assign to  12, 16, 22, 30, 35, 39, 42, 45, 48, 50, 53, 55, 56
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create integers x, k with x assign to 35, k assign to 4
printKclosest ( arr, x, 4, n )
return 0
","Find k closest elements to a given value 
  ; Function to find the cross over point ( the point beuntillewhich elements are smaller than or equal to x and afterwhich greater than x ) ; Base cases x is greater than all ; x is smaller than all ; Find the middle point ; If x is same as middle element , then return mid ; If x is greater than arr array of mid   , then either arr array of mid + 1   is ceiling of x or ceiling lies in arr array of mid + 1. . . high   ; This function prints k closest elements to x in arr array of   . n is the number of elements in arr array of   ; Find the crossover point ; Right index to search ; To keep track of count of elements already printed ; If x is present in arr array of   , then reduce left index Assumption : all elements in arr array of   are distinct ; Compare elements on left and right of crossover point to find the k closest elements ; If there are no more elements on right side , then print left elements ; If there are no more elements on left side , then print right elements ; Driver program to check above functions
",1
675,"declare findCrossOver with integer arr array of  , low, high, x as arguments, returning high if arr array of high  is less than or equal to x
if arr array of low  is greater than x, return low
mid assign to integer with mid assign to ( low + high ) / 2
if arr array of mid  assign to x and arr array of mid + 1   > x, return mid
if arr array of mid  is less than x, return findCrossOver ( arr, mid + 1, high, x )
return findCrossOver ( arr, low, mid - 1, x )
printKclosest is a void function with int arguments arr array of  , x, k, n, and l assign to findCrossOver ( arr, 0, n - 1, x )
create integer r with r assign to l + 1
create integer count with count assign to 0
if arr array of l   is x, decrement l
untill l >assign to 0 and r  n and count  k, printf ( "" % d "", arr array of l --   )
else printf ( "" % d "", arr array of r   )
increment count
untill count  k and l >assign to 0, printf ( "" % d "", arr array of l --   ), count ++
untill count  k and r  n printf ( "" % d "", arr array of r ++   ), count ++
declare integer main ( ) and integer array arr with size   assign to  12, 16, 22, 30, 35, 39, 42, 45, 48, 50, 53, 55, 56
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create integers x, k with x assign to 35, k assign to 4
printKclosest ( arr, x, 4, n )
return 0
","Closest pair in an Array such that one number is multiple of the other 
 C ++ program untill the above approach ; Function to find the minimum distance pair where one is the multiple of the other ; Initialize the variables ; Iterate untill all the elements ; Loop to make pairs ; Check untill minimum distance ; Check if one is a multiple of other ; Update the distance ; Store indexes ; If no such pair exists ; Print the answer ; Driver Code ; Given array arr array of   ; Function Call
",0
676,"if n is 0, return 1
if n is less than 0, return 0
if m assign to 0 and n >assign to 1 return 0
return count ( S, m - 1, n ) + count ( S, m, n - S array of m - 1   )
declare integer main ( ), integers i, j
create integer array arr with arr assign to  1, 2, 3
create integer m with m assign to sizeof ( arr ) / sizeof ( arr array of 0   )
printf ( "" % d "", count ( arr, m, 4 ) ))
read character from the input
return 0
","Coin Change 
 DP 
 Recursive C program untill coin change problem . ; Returns the count of ways we can sum S array of 0. . . m - 1   coins to get sum n ; If n is 0 then there is 1 solution ( do not include any coin ) ; If n is less than 0 then no solution exists ; If there are no coins and n is greater than 0 , then no solution exist ; count is sum of solutions ( i ) including S array of m - 1   ( ii ) excluding S array of m - 1   ; Driver program to test above function
",1
677,"if n is 0, return 1
if n is less than 0, return 0
if m assign to 0 and n >assign to 1 return 0
return count ( S, m - 1, n ) + count ( S, m, n - S array of m - 1   )
declare integer main ( ), integers i, j
create integer array arr with arr assign to  1, 2, 3
create integer m with m assign to sizeof ( arr ) / sizeof ( arr array of 0   )
printf ( "" % d "", count ( arr, m, 4 ) ))
read character from the input
return 0
","Nth number in a set of multiples of A , B or C 
 C ++ program to find nth term divisible by a , b or c ; Function to return gcd of a and b ; Function to return the count of integers from the range array of 1 , num   which are divisible by either a , b or c ; Calculate the number of terms divisible by a , b and c then remove the terms which are divisible by both ( a , b ) or ( b , c ) or ( c , a ) and then add the numbers which are divisible by a , b and c ; Function untill binary search to find the nth term divisible by a , b or c ; Set low to 1 and high to LONG_MAX ; If the current term is less than n then we need to increase low to mid + 1 ; If current term is greater than equal to n then high assign to mid ; Driver code
",0
678,"declare integer count ( integer S array of  , integer m, integer n )  integer table array of n + 1  
set all contents of table to 0
set table array of 0   to 1
untill i assign to 0 to m exclusive, set table array ofj   to table array of j   + table array of j - S array of i    
return table array of n  
","Coin Change 
 DP 
 Dynamic Programming C ++ implementation of Coin Change problem ; table array of i   will be storing the number of solutions untill value i . We need n + 1 rows as the table is constructed in bottom up manner using the base case ( n assign to 0 ) ; Base case ( If given value is 0 ) ; Pick all coins one by one and update the table array of   values after the index greater than or equal to the value of the picked coin
",1
679,"declare integer count ( integer S array of  , integer m, integer n )  integer table array of n + 1  
set all contents of table to 0
set table array of 0   to 1
untill i assign to 0 to m exclusive, set table array ofj   to table array of j   + table array of j - S array of i    
return table array of n  
","Find minimum adjustment cost of an array 
 C ++ program to find minimum adjustment cost of an array ; Function to find minimum adjustment cost of an array ; dp array of i   array of j   stores minimal adjustment cost on changing A array of i   to j ; handle first element of array separately ; do untill rest elements of the array ; replace A array of i   to j and calculate minimal adjustment cost dp array of i   array of j   ; initialize minimal adjustment cost to INT_MAX ; consider all k such that k >assign to max ( j - target , 0 ) and k <assign to min ( M , j + target ) and take minimum ; return minimum value from last row of dp table ; Driver Program to test above functions
",0
680,"create integer dp with size 100 by 100
return 0 if i is j
if dp array of i   array of j   is not -1, return dp array of i   array of j  
dp array of i   array of j   assign to INT_MAX
untill k assign to i to j exclusive, set dp array ofi  array ofj  to min ( dp array of i   array of j  , matrixChainMemoised ( p, k + 1, j ) + p array of i - 1   * p array of k   * p array of j   ) )
return dp array of i   array of j  
in the function MatrixChainOrder that takes integers * p, n and returns integer i assign to 1 and j assign to n - 1
return matrixChainMemoised ( p, i, j )
declare integer main ( ), integer arr assign to  1, 2, 3, 4  ; declare integer array arr size   assign to  1, 2, 3, 4
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
set all contents of dp to -1
print Minimum number of multiplications is "" and MatrixChainOrder ( arr, n)
","Matrix Chain Multiplication 
 DP 
 C ++ program using memoization ; Function untill matrix chain multiplication ; Driver Code
",1
681,"create integer dp with size 100 by 100
return 0 if i is j
if dp array of i   array of j   is not -1, return dp array of i   array of j  
dp array of i   array of j   assign to INT_MAX
untill k assign to i to j exclusive, set dp array ofi  array ofj  to min ( dp array of i   array of j  , matrixChainMemoised ( p, k + 1, j ) + p array of i - 1   * p array of k   * p array of j   ) )
return dp array of i   array of j  
in the function MatrixChainOrder that takes integers * p, n and returns integer i assign to 1 and j assign to n - 1
return matrixChainMemoised ( p, i, j )
declare integer main ( ), integer arr assign to  1, 2, 3, 4  ; declare integer array arr size   assign to  1, 2, 3, 4
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
set all contents of dp to -1
print Minimum number of multiplications is "" and MatrixChainOrder ( arr, n)
","Maximum size subset with given sum 
 A Dynamic Programming solution untill subset sum problem + maximal subset value . ; Returns size of maximum sized subset if there is a subset of set array of   with sun equal to given sum . It returns - 1 if there is no subset with given sum . ; The value of subset array of i   array of j   will be true if there is a subset of set array of 0. . j - 1   with sum equal to i ; If sum is 0 , then answer is true ; If sum is not 0 and set is empty , then answer is false ; Fill the subset table in bottom up manner ; Driver code
",0
682,"create integer MatrixChainOrder (int p array of  , int n )  int m array of n   array of n  
create integers i, j, k, L, q
untill i assign to 1 to n exclusive, set m array of i   array of i   to 0
untill L assign to 2 to n exclusive, set j to i + L - 1
m array of i   array of j   assign to INT_MAX
untill k assign to i to j - 1 inclusive, set q to m array of i   array of k   + m array of k + 1   array of j   + p array of i - 1   * p array of k   * p array of j    
if q  m array of i  array of j  , m array of i   array of j   assign to q
return m array of 1   array of n - 1  
declare integer main ( ), integer arr assign to  1, 2, 3, 4  ; declare integer array arr size   assign to  1, 2, 3, 4
size assign to integer with size assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print Minimum number of multiplications is "" print MatrixChainOrder ( arr, size )
read character from the input
return 0
","Matrix Chain Multiplication 
 DP 
 See the Cormen book untill details of the following algorithm ; Matrix Ai has dimension p array of i - 1   x p array of i   untill i assign to 1. . n ; For simplicity of the program , one extra row and one extra column are allocated in m array of   array of   . 0 th row and 0 th column of m array of   array of   are not used ; cost is zero when multiplying one matrix . ; L is chain length . ; q assign to cost / scalar multiplications ; Driver Code
",1
683,"create integer MatrixChainOrder (int p array of  , int n )  int m array of n   array of n  
create integers i, j, k, L, q
untill i assign to 1 to n exclusive, set m array of i   array of i   to 0
untill L assign to 2 to n exclusive, set j to i + L - 1
m array of i   array of j   assign to INT_MAX
untill k assign to i to j - 1 inclusive, set q to m array of i   array of k   + m array of k + 1   array of j   + p array of i - 1   * p array of k   * p array of j    
if q  m array of i  array of j  , m array of i   array of j   assign to q
return m array of 1   array of n - 1  
declare integer main ( ), integer arr assign to  1, 2, 3, 4  ; declare integer array arr size   assign to  1, 2, 3, 4
size assign to integer with size assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print Minimum number of multiplications is "" print MatrixChainOrder ( arr, size )
read character from the input
return 0
","Sort the biotonic doubly linked list 
 C ++ implementation to sort the biotonic doubly linked list ; a node of the doubly linked list ; Function to reverse a Doubly Linked List ; swap next and prev untill all nodes of doubly linked list ; Beuntille changing head , check untill the cases like empty list and list with only one node ; Function to merge two sorted doubly linked lists ; If first linked list is empty ; If second linked list is empty ; Pick the smaller value ; function to sort a biotonic doubly linked list ; if list is empty or if it contains a single node only ; if true , then ' current ' is the first node which is smaller than its previous node ; move to the next node ; if true , then list is already sorted ; spilt into two lists , one starting with ' head ' and other starting with ' current ' ; reverse the list starting with ' current ' ; merge the two lists and return the final merged doubly linked list ; Function to insert a node at the beginning of the Doubly Linked List ; allocate node ; put in the data ; since we are adding at the beginning , prev is always NULL ; link the old list off the new node ; change prev of head node to new node ; move the head to point to the new node ; Function to print nodes in a given doubly linked list ; if list is empty ; Driver program to test above ; Create the doubly linked list : 2 < -> 5 < -> 7 < -> 12 < -> 10 < -> 6 < -> 4 < -> 1 ; sort the biotonic DLL
",0
684,"a assign to integer, return a if a > b, else return b
if n assign to 0, return 0
create integer max_val with max_val assign to INT_MIN
untill i assign to 0 to n exclusive, max_val assign to max ( max_val, price array of i   + cutRod ( price, n - i - 1 ) )
return max_val
declare integer main ( ) and integer array arr with arr assign to  1, 5, 8, 9, 10, 17, 17, 20
size assign to integer with size assign to sizeof ( arr ) / sizeof ( arr array of 0   )
printf is a new line with "" Maximum Obtainable Value is % dn "", cutRod ( arr, size ))
read character from the input
return 0
","Cutting a Rod 
 DP 
 A Naive recursive solution untill Rod cutting problem ; A utility function to get the maximum of two integers ; Returns the best obtainable price untill a rod of length n and price array of   as prices of different pieces ; Recursively cut the rod in different pieces and compare different configurations ; Driver program to test above functions
",1
685,"a assign to integer, return a if a > b, else return b
if n assign to 0, return 0
create integer max_val with max_val assign to INT_MIN
untill i assign to 0 to n exclusive, max_val assign to max ( max_val, price array of i   + cutRod ( price, n - i - 1 ) )
return max_val
declare integer main ( ) and integer array arr with arr assign to  1, 5, 8, 9, 10, 17, 17, 20
size assign to integer with size assign to sizeof ( arr ) / sizeof ( arr array of 0   )
printf is a new line with "" Maximum Obtainable Value is % dn "", cutRod ( arr, size ))
read character from the input
return 0
","Calculate nCr using Pascal 's Triangle 
 C ++ implementation of the approach ; Initialize the matrix with 0 ; 0 C0 assign to 1 ; Set every nCr assign to 1 where r assign to 0 ; Value untill the current cell of Pascal 's triangle ; Function to return the value of nCr ; Return nCr ; Driver code ; Build the Pascal 's triangle
",0
686,"a assign to integer, return a if a > b, else return b
create int cutRod ( int price array of  , int n ) and val array of n + 1  
val array of 0   assign to 0
create integers i, j
untill i assign to 1 to n inclusive, max_val assign to INT_MIN
untill j assign to 0 to i exclusive, max_val assign to max ( max_val, price array of j   + val array of i - j - 1   )
val array of i   assign to max_val
return val array of n  
declare integer main ( ) and integer array arr with arr assign to  1, 5, 8, 9, 10, 17, 17, 20
size assign to integer with size assign to sizeof ( arr ) / sizeof ( arr array of 0   )
printf is a new line with "" Maximum Obtainable Value is % dn "", cutRod ( arr, size ))
read character from the input
return 0
","Cutting a Rod 
 DP 
 A Dynamic Programming solution untill Rod cutting problem ; A utility function to get the maximum of two integers ; Returns the best obtainable price untill a rod of length n and price array of   as prices of different pieces ; Build the table val array of   in bottom up manner and return the last entry from the table ; Driver program to test above functions
",1
687,"a assign to integer, return a if a > b, else return b
create int cutRod ( int price array of  , int n ) and val array of n + 1  
val array of 0   assign to 0
create integers i, j
untill i assign to 1 to n inclusive, max_val assign to INT_MIN
untill j assign to 0 to i exclusive, max_val assign to max ( max_val, price array of j   + val array of i - j - 1   )
val array of i   assign to max_val
return val array of n  
declare integer main ( ) and integer array arr with arr assign to  1, 5, 8, 9, 10, 17, 17, 20
size assign to integer with size assign to sizeof ( arr ) / sizeof ( arr array of 0   )
printf is a new line with "" Maximum Obtainable Value is % dn "", cutRod ( arr, size ))
read character from the input
return 0
","Print all possible rotations of a given Array 
 C ++ program to print all possible rotations of the given array ; Global declaration of array ; Function to reverse array between indices s and e ; Function to generate all possible rotations of array ; Driver code
",0
688,"create integer t array of 9   array of 9  
if n is equal to 0 Max_len return 0
if length array of n - 1   is less than or equal to Max_len, t array of n   array of Max_len   assign to max ( price array of n - 1   + un_kp ( price array of n - 1  , n ), un_kp ( price, length, Max_len, n - 1 ) )
else t array of n   array of Max_len   assign to un_kp ( price, length, Max_len, n - 1 )
return t array of n   array of Max_len  
declare integer main ( ), integer price assign to  1, 5, 8, 9, 10, 17, 17, 20  ;
create integer n with n assign to sizeof ( price ) / sizeof ( price array of 0   )
create integer length array of n  
untill i assign to 0 to n exclusive, length array of i   assign to i + 1
create integer Max_len with Max_len assign to n
print "" Maximum obtained value is "" print un_kp ( price, length, n, Max_len ) print newline
","Cutting a Rod 
 DP 
 CPP program untill above approach ; Global Array untill the purpose of memoization . ; A recursive program , using , memoization , to implement the rod cutting problem ( Top - Down ) . ; The maximum price will be zero , when either the length of the rod is zero or price is zero . ; If the length of the rod is less than the maximum length , Max_lene will consider it . Now depending upon the profit , either Max_lene we will take it or discard it . ; If the length of the rod is greater than the permitted size , Max_len we will not consider it . ; Max_lene Max_lenill return the maximum value obtained , Max_lenhich is present at the nth roMax_len and Max_lenth column . ; Driver program to test above functions ; Function Call
",1
689,"create integer t array of 9   array of 9  
if n is equal to 0 Max_len return 0
if length array of n - 1   is less than or equal to Max_len, t array of n   array of Max_len   assign to max ( price array of n - 1   + un_kp ( price array of n - 1  , n ), un_kp ( price, length, Max_len, n - 1 ) )
else t array of n   array of Max_len   assign to un_kp ( price, length, Max_len, n - 1 )
return t array of n   array of Max_len  
declare integer main ( ), integer price assign to  1, 5, 8, 9, 10, 17, 17, 20  ;
create integer n with n assign to sizeof ( price ) / sizeof ( price array of 0   )
create integer length array of n  
untill i assign to 0 to n exclusive, length array of i   assign to i + 1
create integer Max_len with Max_len assign to n
print "" Maximum obtained value is "" print un_kp ( price, length, n, Max_len ) print newline
","Given an n x n square matrix , find sum of all sub 
 An efficient C ++ program to find sum of all subsquares of size k x k ; Size of given matrix ; A O ( n to the power 2 ) function to find sum of all sub - squares of size k x k in a given square matrix of size n x n ; k must be smaller than or equal to n ; 1 : PREPROCESSING To store sums of all strips of size k x 1 ; Go column by column ; Calculate sum of first k x 1 rectangle in this column ; Calculate sum of remaining rectangles ; 2 : CALCULATE SUM of Sub - Squares using stripSum array of   array of   ; Calculate and print sum of first subsquare in this row ; Calculate sum of remaining squares in current row by removing the leftmost strip of previous sub - square and adding a new strip ; Driver program to test above function
",0
690,"declare public : multiply ( integer x, y ) if y is 0, return 0
if y is greater than 0, return ( x + multiply ( x, y - 1 ) )
if y is less than 0, return - multiply ( x, - y )
print
declare integer main with main assign to GFG g
print newline print g and multiply ( 5, -11 )
read character from the input
return 0
","Multiply two integers without using multiplication , division and bitwise operators , and no loops 
 C ++ program to Multiply two integers without using multiplication , division and bitwise operators , and no loops ; function to multiply two numbers x and y ; 0 multiplied with anything gives 0 ; Add x one by one ; the case where y is negative ; Driver code
",1
691,"declare public : multiply ( integer x, y ) if y is 0, return 0
if y is greater than 0, return ( x + multiply ( x, y - 1 ) )
if y is less than 0, return - multiply ( x, - y )
print
declare integer main with main assign to GFG g
print newline print g and multiply ( 5, -11 )
read character from the input
return 0
","Minimum value to be added to X such that it is at least Y percent of N 
 C ++ implementation of the approach ; Function to return the required value that must be added to x so that it is at least y percent of n ; Required value ; If x is already >assign to y percent of n ; Driver code
",0
692,"declare SieveOfEratosthenes with integer n as argument, returning boolean prime with n + 1 argument
set all contents of prime to true
untill p assign to 2 to n inclusive, if prime array of p   is true, increment i by n, set prime array of i   to false
print p and "" "" if prime array of p   is true
declare integer main ( ) and integer n assign to 30
print "" Following are prime numbers smaller "", "" than or equal to "", n
call SieveOfEratosthenes ( n )
return 0
","Sieve of Eratosthenes 
 C ++ program to print all primes smaller than or equal to n using Sieve of Eratosthenes ; Create a boolean array "" prime array of 0 . . n   "" and initialize all entries it as true . A value in prime array of i   will finally be false if i is Not a prime , else true . ; If prime array of p   is not changed , then it is a prime ; Update all multiples of p greater than or equal to the square of it numbers which are multiple of p and are less than p to the power 2 are already been marked . ; Print all prime numbers ; Driver Code
",1
693,"declare SieveOfEratosthenes with integer n as argument, returning boolean prime with n + 1 argument
set all contents of prime to true
untill p assign to 2 to n inclusive, if prime array of p   is true, increment i by n, set prime array of i   to false
print p and "" "" if prime array of p   is true
declare integer main ( ) and integer n assign to 30
print "" Following are prime numbers smaller "", "" than or equal to "", n
call SieveOfEratosthenes ( n )
return 0
","Least number to be added to or subtracted from N to make it a Perfect Square 
 C ++ implementation of the approach ; Function to return the Least number ; Get the perfect square beuntille and after N ; Check which is nearest to N ; return the result ; Driver code
",0
694,"declare binomialCoeff with integers n, k as arguments, returning integer
declare binomialCoeff with integers n, k, res assign to 1
if k is greater than n - k, set k to n - k
untill i assign to 0 to k exclusive, res assign to res * ( n - i )
res assign to res / ( i + 1 )
return res
printPascal is a void function with int arguments line assign to 0 and line  n, printf is a void function with a value of 0 and line is less than or equal to line, printf is a void function with a function binomialCoeff ( line, i ) as arguments
printf is a new line
declare integer main ( ) and integer n assign to 7
printPascal is a new line
return 0
","Pascal 's Triangle 
 C ++ code untill Pascal 's Triangle ; binomialCoeff ; Function to print first n lines of Pascal 's Triangle ; Iterate through every line and print entries in it ; Every line has number of integers equal to line number ; Driver program
",1
695,"declare binomialCoeff with integers n, k as arguments, returning integer
declare binomialCoeff with integers n, k, res assign to 1
if k is greater than n - k, set k to n - k
untill i assign to 0 to k exclusive, res assign to res * ( n - i )
res assign to res / ( i + 1 )
return res
printPascal is a void function with int arguments line assign to 0 and line  n, printf is a void function with a value of 0 and line is less than or equal to line, printf is a void function with a function binomialCoeff ( line, i ) as arguments
printf is a new line
declare integer main ( ) and integer n assign to 7
printPascal is a new line
return 0
","Kth smallest or largest element in unsorted Array 
 Set 4 
 C ++ program untill the above approach ; Function to find the Kth smallest element in Unsorted Array ; Initialize the max Element as 0 ; Iterate arr array of   and find the maximum element in it ; Frequency array to store the frequencies ; Counter variable ; Counting the frequencies ; Iterate through the freq array of   ; Check if num is present in the array ; Increment the counter with the frequency of num ; Checking if we have reached the Kth smallest element ; Return the Kth smallest element ; Driver Code ; Given array ; Function Call
",0
696,"printPascal is a void function with int arguments n and n
untill line assign to 0 to n exclusive, set arr array of line   array of i   to 1 if line is i i is 0
else arr array of line   array of i   assign to arr array of line - 1   array of i - 1   + arr array of line - 1   array of i  
print arr array of line  array of i  print "" ""
print "" STRNEWLINE ""
declare integer main ( ) and integer n assign to 5
printPascal is a new line
return 0
","Pascal 's Triangle 
 C ++ program untill Pascals Triangle ; A O ( n to the power 2 ) time and O ( n to the power 2 ) extra space method untill Pascal 's Triangle ; An auxiliary array to store generated pscal triangle values ; Iterate through every line and print integer ( s ) in it ; Every line has number of integers equal to line number ; First and last values in every row are 1 ; Other values are sum of values just above and left of above ; Driver code
",1
697,"printPascal is a void function with int arguments n and n
untill line assign to 0 to n exclusive, set arr array of line   array of i   to 1 if line is i i is 0
else arr array of line   array of i   assign to arr array of line - 1   array of i - 1   + arr array of line - 1   array of i  
print arr array of line  array of i  print "" ""
print "" STRNEWLINE ""
declare integer main ( ) and integer n assign to 5
printPascal is a new line
return 0
","Check if a given value can be reached from another value in a Circular Queue by K 
 C ++ program untill the above approach ; Function to return GCD of two numbers a and b ; Base Case ; Recursively Find the GCD ; Function to check of B can be reaced from A with a jump of K elements in the circular queue ; Find GCD of N and K ; If A - B is divisible by gcd then print Yes ; Otherwise ; Driver Code ; Function Call
",0
698,"untill line assign to 1 to n inclusive, C assign to 1
untill i assign to 1 to line inclusive, print C and "" ""
C assign to C * ( line - i ) / i
print "" STRNEWLINE ""
declare integer main ( ) and integer n assign to 5
printPascal is a new line
return 0
","Pascal 's Triangle 
 C ++ program untill Pascals Triangle A O ( n to the power 2 ) time and O ( 1 ) extra space function untill Pascal 's Triangle ; used to represent C ( line , i ) ; The first value in a line is always 1 ; Driver code
",1
699,"untill line assign to 1 to n inclusive, C assign to 1
untill i assign to 1 to line inclusive, print C and "" ""
C assign to C * ( line - i ) / i
print "" STRNEWLINE ""
declare integer main ( ) and integer n assign to 5
printPascal is a new line
return 0
","Number of loops of size k starting from a specific node 
 C ++ Program to find number of cycles of length k in a graph with n nodes . ; Return the Number of ways from a node to make a loop of size K in undirected complete connected graph of N nodes ; Driven Program
",0
700,"declare integer Add with integers x, y, untill y is not 0, assign x and y to y
x assign to x  y
y assign to carry  1
return x
print main, Add ( 15, 32 )
return 0
","Add two numbers without using arithmetic operators 
 C ++ Program to add two numbers without using arithmetic operator ; Iterate till there is no carry ; carry now contains common set bits of x and y ; Sum of bits of x and y where at least one of the bits is not set ; Carry is shifted by one so that adding it to x gives the required sum ; Driver code
",1
701,"declare integer Add with integers x, y, untill y is not 0, assign x and y to y
x assign to x  y
y assign to carry  1
return x
print main, Add ( 15, 32 )
return 0
","Count of pairs having each element equal to index of the other from an Array 
 C ++ program to implement the above approach ; Function to print the count of pair ; Iterate over all the elements of the array ; Increment the count ; Print the result ; Driver Code
",0
702,"declare getModulo with unsigned integers n, d as arguments, returning ( n & ( d - 1 ) )
declare integer main ( ), unsigned integer n assign to 6
d assign to unsigned integer with d assign to 4
printf ( "" % u moduo % u is % u "", n, d, getModulo ( n, d ) ) )
read character from the input
return 0
","Compute modulus division by a power 
  ; This function will return n % d . d must be one of : 1 , 2 , 4 , 8 , 16 , 32 , ... ; Driver Code ; d must be a power of 2
",1
703,"declare getModulo with unsigned integers n, d as arguments, returning ( n & ( d - 1 ) )
declare integer main ( ), unsigned integer n assign to 6
d assign to unsigned integer with d assign to 4
printf ( "" % u moduo % u is % u "", n, d, getModulo ( n, d ) ) )
read character from the input
return 0
","Count minimum number of moves to front or end to sort an array 
 C ++ program untill the above approach ; Function that counts the minimum moves required to covert arr array of   to brr array of   ; Base Case ; If arr array of i   < arr array of j   ; Include the current element ; Otherwise , excluding the current element ; Function that counts the minimum moves required to sort the array ; If both the arrays are equal ; No moves required ; Otherwise ; Print minimum operations required ; Driver code
",0
704,"countSetBits assign to unsigned integer ( unsigned integer n)  unsigned integer count assign to 0
untill n is true, increment count by n & 1
n assign to n >>assign to 1
return count
declare integer main ( ) and integer i assign to 9
print countSetBits ( i )
return 0
","Count set bits in an integer 
 C ++ program to Count set bits in an integer ; Function to get no of set bits in binary representation of positive integer n ; Program to test function countSetBits
",1
705,"countSetBits assign to unsigned integer ( unsigned integer n)  unsigned integer count assign to 0
untill n is true, increment count by n & 1
n assign to n >>assign to 1
return count
declare integer main ( ) and integer i assign to 9
print countSetBits ( i )
return 0
","Maximum number of squares that can fit in a right angle isosceles triangle 
 CPP program untill finding maximum squares that can fit in right angle isosceles triangle ; function untill finding max squares ; return in O ( 1 ) with derived untillmula ; driver program
",0
706,"return 0 if n is 0
else return 1 + countSetBits ( n & ( n - 1 ) )
declare integer main ( ) and integer n assign to 9
print countSetBits ( n )
return 0
","Count set bits in an integer 
 CPP implementation untill recursive approach to find the number of set bits using Brian Kernighans Algorithm ; recursive function to count set bits ; base case ; driver code ; get value from user ; function calling
",1
707,"return 0 if n is 0
else return 1 + countSetBits ( n & ( n - 1 ) )
declare integer main ( ) and integer n assign to 9
print countSetBits ( n )
return 0
","Find next greater element with no consecutive 1 in it 's binary representation 
 C ++ implementation of the approach ; To store the pre - computed integers ; Function that returns true if the binary representation of x contains consecutive 1 s ; To store the previous bit ; Check whether the previous bit and the current bit are both 1 ; Update previous bit ; Go to the next bit ; Function to pre - compute the valid numbers from 0 to MAX ; Store all the numbers which do not have consecutive 1 s ; Function to return the minimum number greater than n which does not contain consecutive 1 s ; Search untill the next greater element with no consecutive 1 s ; Function to peruntillm the queries ; Driver code ; Pre - compute the numbers ; Peruntillm the queries
",0
708,"create integer BitsSetTable256 array of256  
initialize assign to void void, set BitsSetTable256 array of 0   to 0
untill i assign to 0 to 256 exclusive, set BitsSetTable256 array of i   to ( i & 1 ) + BitsSetTable256 array of i / 2  
return ( BitsSetTable256 array of n & 0xff   + BitsSetTable256 array of ( n >> 8 ) & 0xff   + BitsSetTable256 array of ( n >> 16 ) & 0xff   + BitsSetTable256 array of n >> 24   )
declare integer main ( ) and initialize ( )
n assign to integer with n assign to 9
print countSetBits ( n )
","Count set bits in an integer 
 C ++ implementation of the approach ; Lookup table ; Function to initialise the lookup table ; To initially generate the table algorithmically ; Function to return the count of set bits in n ; Driver code ; Initialise the lookup table
",1
709,"create integer BitsSetTable256 array of256  
initialize assign to void void, set BitsSetTable256 array of 0   to 0
untill i assign to 0 to 256 exclusive, set BitsSetTable256 array of i   to ( i & 1 ) + BitsSetTable256 array of i / 2  
return ( BitsSetTable256 array of n & 0xff   + BitsSetTable256 array of ( n >> 8 ) & 0xff   + BitsSetTable256 array of ( n >> 16 ) & 0xff   + BitsSetTable256 array of n >> 24   )
declare integer main ( ) and initialize ( )
n assign to integer with n assign to 9
print countSetBits ( n )
","Find the player to be able to replace the last element that can be replaced by its divisors 
 C ++ program untill the above approach ; Function to find the winner of the game played based on given conditions ; A wins if size of array is odd ; Otherwise , B wins ; Driver Code ; Input array ; Size of the array
",0
710,"declare integer main ( ), print __builtin_popcount ( 4 ) and a new line
print __builtin_popcount ( 15 )
return 0
","Count set bits in an integer 
 C ++ program to demonstrate __builtin_popcount ( ) ; Driver code
",1
711,"declare integer main ( ), print __builtin_popcount ( 4 ) and a new line
print __builtin_popcount ( 15 )
return 0
","Count numbers from a given range that are not divisible by any of the array elements 
 C ++ program untill the above approach ; Function to find the non - multiples till k ; Stores all unique multiples ; Iterate the array ; For finding duplicates only once ; Inserting all multiples into the set ; Returning only the count of numbers that are not divisible by any of the array elements ; Function to count the total values in the range array of L , R   ; Count all values in the range using exclusion principle ; Driver Code ; Function Call
",0
712,"create integer num_to_bits array of16  with num_to_bits assign to 0, 1, 1, 2, 2, 3, 1, 2, 2, 3, 3, 2, 3, 3, 3, 3, 4  0
declare countSetBitsRec with unsigned integer num, nibble assign to 0 as argument, returning unsigned integer
if 0 is num, return num_to_bits array of 0  
set nibble to num and 0xf
return num_to_bits array of nibble  + countSetBitsRec ( num >> 4 )
declare integer main ( ) and integer num assign to 31
print countSetBitsRec (num )
return 0
","Count set bits in an integer 
 C ++ program to count set bits by pre - storing count set bits in nibbles . ; Recursively get nibble of a given number and map them in the array ; Find last nibble ; Use pre - stored values to find count in last nibble plus recursively add remaining nibbles . ; Driver code
",1
713,"create integer num_to_bits array of16  with num_to_bits assign to 0, 1, 1, 2, 2, 3, 1, 2, 2, 3, 3, 2, 3, 3, 3, 3, 4  0
declare countSetBitsRec with unsigned integer num, nibble assign to 0 as argument, returning unsigned integer
if 0 is num, return num_to_bits array of 0  
set nibble to num and 0xf
return num_to_bits array of nibble  + countSetBitsRec ( num >> 4 )
declare integer main ( ) and integer num assign to 31
print countSetBitsRec (num )
return 0
","Sum of largest divisor of numbers upto N not divisible by given prime number P 
 C ++ program untill the above approach ; Function to find the sum of largest divisors of numbers in range 1 to N not divisible by prime number P ; Total sum upto N ; If no multiple of P exist up to N ; If only P itself is in the range from 1 to N ; Sum of those that are divisible by P ; Recursively function call to find the sum untill N / P ; Driver Code ; Given N and P ; Function Call
",0
714,"countSetBits assign to integer with countSetBits assign to 0
untill i assign to 0 to size of ( integer ) * 8 exclusive, increment count by 1
return count
declare integer main ( ) and integer N assign to 15
print countSetBits ( N) print newline
return 0
","Count set bits in an integer 
  ; Check each bit in a number is set or not and return the total count of the set bits . ; ( 1 << i ) assign to pow ( 2 , i ) ; Driver code
",1
715,"countSetBits assign to integer with countSetBits assign to 0
untill i assign to 0 to size of ( integer ) * 8 exclusive, increment count by 1
return count
declare integer main ( ) and integer N assign to 15
print countSetBits ( N) print newline
return 0
","Sum of all numbers divisible by 6 in a given range 
 CPP program to find sum of numbers divisible by 6 in a given range . ; function to calculate the sum of all numbers divisible by 6 in range L - R . . ; no of multiples of 6 upto r ; no of multiples of 6 upto l - 1 ; summation of all multiples of 6 upto r ; summation of all multiples of 6 upto l - 1 ; returns the answer ; driver program to test the above function
",0
716,"create boolean integer with value define
declare getParity with unsigned integer n as argument, returning boolean, parity assign to 0
untill n is true, set parity to not parity
n assign to n & ( n - 1 )
return parity
declare integer main ( ), unsigned integer n assign to 7
print Parity of no "", n, "" assign to "", odd "" if getParity ( n ) is true, else even ""
read character from the input
return 0
","Program to find parity 
 C ++ program to find parity of an integer ; Function to get parity of number n . It returns 1 if n has odd parity , and returns 0 if n has even parity ; Driver program to test getParity ( )
",1
717,"create boolean integer with value define
declare getParity with unsigned integer n as argument, returning boolean, parity assign to 0
untill n is true, set parity to not parity
n assign to n & ( n - 1 )
return parity
declare integer main ( ), unsigned integer n assign to 7
print Parity of no "", n, "" assign to "", odd "" if getParity ( n ) is true, else even ""
read character from the input
return 0
","Count numbers with unit digit k in given range 
 Efficient CPP program to count numbers with last digit as k in given range . ; Returns count of numbers with k as last digit . ; Driver Code
",0
718,"if n is 0, return false
return ( ceil ( log2 ( n ) ) assign to floor ( log2 ( n ) ) ) )
print Yes and a new line, print No and newline
print Yes and newline if 64 is true, print No and newline
return 0
","Program to find whether a no is power of two 
 C ++ Program to find whether a no is power of two ; Function to check if x is power of 2 ; Driver program
",1
719,"if n is 0, return false
return ( ceil ( log2 ( n ) ) assign to floor ( log2 ( n ) ) ) )
print Yes and a new line, print No and newline
print Yes and newline if 64 is true, print No and newline
return 0
","Count of elements to be inserted to make Array sum twice the XOR of Array 
 C ++ program to find the count of elements to be inserted to make Array sum twice the XOR of Array ; Function to find the minimum number of elements that need to be inserted such that the sum of the elements of the array is twice the XOR of the array ; Variable to store the Xor of all the elements ; Variable to store the sum of all elements ; Loop to find the Xor and the sum of the array ; If sum assign to 2 * Xor ; No need to insert more elements ; We insert one more element which is Sum ; We insert two more elements Sum + Xor and Xor . ; Print the number of elements inserted in the array ; Print the elements that are inserted in the array ; Driver code
",0
720,"if n is 0, return 0
untill n is not 1 return 0
set n to n / 2
return 1
print Yes STRNEWLINE if 31 is true, else print No STRNEWLINE
print Yes STRNEWLINE if 64 is true, else print No STRNEWLINE
return 0
","Program to find whether a no is power of two 
  ; Function to check if x is power of 2 ; Driver code
",1
721,"if n is 0, return 0
untill n is not 1 return 0
set n to n / 2
return 1
print Yes STRNEWLINE if 31 is true, else print No STRNEWLINE
print Yes STRNEWLINE if 64 is true, else print No STRNEWLINE
return 0
","Count the numbers which can convert N to 1 using given operation 
 C ++ program to count the numbers which can convert N to 1 using the given operation ; Function to count the numbers which can convert N to 1 using the given operation ; Iterate through all the integers ; Check if N can be converted to 1 ; Incrementing the count if it can be converted ; Driver code
",0
722,"if n is equal to 1 return true
else if n modulo 2 is not 0, return false
return powerOf2 ( n / 2 )
declare integer main ( ) and integer n assign to 64
create integer m with m assign to 12
if powerOf2 ( n ) is 1 print True
else print False
if powerOf2 ( m ) is 1 print True
else print False
","Program to find whether a no is power of two 
 C ++ program untill above approach ; Function which checks whether a number is a power of 2 ; base cases '1' is the only odd number which is a power of 2 ( 2 to the power 0 ) ; all other odd numbers are not powers of 2 ; recursive function call ; Driver Code ; True ; False
",1
723,"if n is equal to 1 return true
else if n modulo 2 is not 0, return false
return powerOf2 ( n / 2 )
declare integer main ( ) and integer n assign to 64
create integer m with m assign to 12
if powerOf2 ( n ) is 1 print True
else print False
if powerOf2 ( m ) is 1 print True
else print False
","Check if array contains contiguous integers with duplicates allowed 
 C ++ implementation to check whether the array contains a set of contiguous integers ; function to check whether the array contains a set of contiguous integers ; Find maximum and minimum elements . ; There should be at least m elements in array to make them contiguous . ; Create a visited array and initialize false . ; Mark elements as true . ; If any element is not marked , all elements are not contiguous . ; Driver program
",0
724,"declare isPowerOfTwo as integer, return x and (! ( x and ( x - 1 ) ) ) )
print Yes STRNEWLINE if 31 is true, else print No STRNEWLINE
print Yes STRNEWLINE if 64 is true, else print No STRNEWLINE
return 0
","Program to find whether a no is power of two 
  ; Function to check if x is power of 2 ; First x in the below expression is untill the case when x is 0 ; Driver code
",1
725,"declare isPowerOfTwo as integer, return x and (! ( x and ( x - 1 ) ) ) )
print Yes STRNEWLINE if 31 is true, else print No STRNEWLINE
print Yes STRNEWLINE if 64 is true, else print No STRNEWLINE
return 0
","Area of a Hexagon 
 CPP program to find area of a Hexagon ; function untill calculating area of the hexagon . ; Driver Code ; Length of a side
",0
726,"untill i assign to 0 to n exclusive, increment arr array of arr array of i   % k   by k
create integers max, result with max assign to arr array of 0   and result assign to 0
untill i assign to 1 to n exclusive, set max to arr array of i  
set result to i
return result
declare integer main ( ) and integer arr array of   assign to  2, 3, 3, 5, 3, 4, 1, 7
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create integer k with k assign to 8
print "" The maximum repeating number is "" print maxRepeating ( arr, n, k ) print newline
return 0
","Find the maximum repeating number in O ( n ) time and O ( 1 ) extra space 
 C ++ program to find the maximum repeating number ; Returns maximum repeating element in arr array of 0. . n - 1   . The array elements are in range from 0 to k - 1 ; Iterate though input array , untill every element arr array of i   , increment arr array of arr array of i   % k   by k ; Find index of the maximum repeating element ; Return index of the maximum element ; Driver program to test above function
",1
727,"untill i assign to 0 to n exclusive, increment arr array of arr array of i   % k   by k
create integers max, result with max assign to arr array of 0   and result assign to 0
untill i assign to 1 to n exclusive, set max to arr array of i  
set result to i
return result
declare integer main ( ) and integer arr array of   assign to  2, 3, 3, 5, 3, 4, 1, 7
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create integer k with k assign to 8
print "" The maximum repeating number is "" print maxRepeating ( arr, n, k ) print newline
return 0
","Program to check if an array is sorted or not ( Iterative and Recursive ) 
 C ++ program to check if an Array is sorted or not ; Function that returns true if array is sorted in non - decreasing order . ; Array has one or no element ; Unsorted pair found ; No unsorted pair found ; Driver code
",0
728,"declare fun with integer x as argument, y assign to (x / 4 ) * 4
ans assign to integer with ans assign to 0
untill i assign to y to x inclusive, ans is equal to ans assign to i
return ans
return 0 if x is 0
create integer k with k assign to ( x + 1 ) / 2
return 2 * fun (k ) if x % is odd, else ( fun ( k - 1 ) * 2 ) if k & 1 is not 0
untill i assign to 0 to q exclusive, print query ( r array of i   ) print query ( l array of i   - 1 )
declare integer main ( ) and integer q assign to 3
create integer l with l assign to  2, 2, 5  ;
create integer r with r assign to  4, 8, 9  ;
allQueries ( q, l, r )
return 0
","Range Query on array whose each element is XOR of index value and previous element 
 CPP Program to solve range query on array whose each element is XOR of index value and previous element . ; function return derived untillmula value . ; finding xor value of range array of y ... x   ; function to solve query untill l and r . ; if l or r is 0. ; finding x is divisible by 2 or not . ; Driven Program
",1
729,"declare fun with integer x as argument, y assign to (x / 4 ) * 4
ans assign to integer with ans assign to 0
untill i assign to y to x inclusive, ans is equal to ans assign to i
return ans
return 0 if x is 0
create integer k with k assign to ( x + 1 ) / 2
return 2 * fun (k ) if x % is odd, else ( fun ( k - 1 ) * 2 ) if k & 1 is not 0
untill i assign to 0 to q exclusive, print query ( r array of i   ) print query ( l array of i   - 1 )
declare integer main ( ) and integer q assign to 3
create integer l with l assign to  2, 2, 5  ;
create integer r with r assign to  4, 8, 9  ;
allQueries ( q, l, r )
return 0
","Cutting a Rod 
 DP 
 CPP program untill above approach ; Global Array untill the purpose of memoization . ; A recursive program , using , memoization , to implement the rod cutting problem ( Top - Down ) . ; The maximum price will be zero , when either the length of the rod is zero or price is zero . ; If the length of the rod is less than the maximum length , Max_lene will consider it . Now depending upon the profit , either Max_lene we will take it or discard it . ; If the length of the rod is greater than the permitted size , Max_len we will not consider it . ; Max_lene Max_lenill return the maximum value obtained , Max_lenhich is present at the nth roMax_len and Max_lenth column . ; Driver program to test above functions ; Function Call
",0
730,"in void function prefixXOR with arguments arr array of   and preXOR array of   and n, untill arr array of i   modulo 2 is not 1 then arr array of i   / 2
preXOR array of i   assign to arr array of i  
untill i assign to 1 to n exclusive, preXOR array of i   assign to preXOR array of i - 1  and preXOR array of i  
return preXOR array of r  if l is 0
else return preXOR array of r   preXOR array of l - 1  
declare integer main ( ), integer arr array of   assign to  3, 4, 5  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
preXOR assign to integer array of size n
prefixXOR ( arr, preXOR, n )
print query ( preXOR, 0, 2 )
print query ( preXOR, 1, 2 )
return 0
","Queries on XOR of greatest odd divisor of the range 
  ; Precompute the prefix XOR of greatest odd divisor ; Finding the Greatest Odd divisor ; Finding prefix XOR ; Return XOR of the range ; Driven Program
",1
731,"in void function prefixXOR with arguments arr array of   and preXOR array of   and n, untill arr array of i   modulo 2 is not 1 then arr array of i   / 2
preXOR array of i   assign to arr array of i  
untill i assign to 1 to n exclusive, preXOR array of i   assign to preXOR array of i - 1  and preXOR array of i  
return preXOR array of r  if l is 0
else return preXOR array of r   preXOR array of l - 1  
declare integer main ( ), integer arr array of   assign to  3, 4, 5  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
preXOR assign to integer array of size n
prefixXOR ( arr, preXOR, n )
print query ( preXOR, 0, 2 )
print query ( preXOR, 1, 2 )
return 0
","Count of even and odd set bit with array element after XOR with K 
 C ++ program to count the set bits after taking XOR with a number K ; Function to store EVEN and odd variable ; Store the count of even and odd set bit ; Count the set bit using in built function ; Count of set - bit of K ; If y is odd then , count of even and odd set bit will be interchanged ; Else it will remain same as the original array ; Driver 's Code ; Function call to count even and odd
",0
732,"declare findMinSwaps with integer arr array of  , integer n, noOfZeroes array of n   as arguments, returning integer
set all contents of noOfZeroes to 0
create integers i, count with count assign to 0
noOfZeroes array of n - 1   assign to 1 - arr array of n - 1  
untill i assign to n - 2 to 0 inclusive, set noOfZeroes array of i   to noOfZeroes array of i + 1  
if arr array of i   is 0, increment noOfZeroes array of i  
untill i assign to 0 to n exclusive, increment count by noOfZeroes array of i  
return count
declare integer main ( ) and integer arr array of   assign to  0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print findMinSwaps ( arr, n )
return 0
","Minimum adjacent swaps required to Sort Binary array 
 C ++ code to find minimum number of swaps to sort a binary array ; Function to find minimum swaps to sort an array of 0 s and 1 s . ; Array to store count of zeroes ; Count number of zeroes on right side of every one . ; Count total number of swaps by adding number of zeroes on right side of every one . ; Driver code
",1
733,"declare findMinSwaps with integer arr array of  , integer n, noOfZeroes array of n   as arguments, returning integer
set all contents of noOfZeroes to 0
create integers i, count with count assign to 0
noOfZeroes array of n - 1   assign to 1 - arr array of n - 1  
untill i assign to n - 2 to 0 inclusive, set noOfZeroes array of i   to noOfZeroes array of i + 1  
if arr array of i   is 0, increment noOfZeroes array of i  
untill i assign to 0 to n exclusive, increment count by noOfZeroes array of i  
return count
declare integer main ( ) and integer arr array of   assign to  0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print findMinSwaps ( arr, n )
return 0
","Count 1 s present in a range of indices array of L , R   in a given array 
 C ++ Program to implement the above approach ; Function to find the size of the array if the array initially contains a single element ; Base case ; P / 2 -> findSize ( N / 2 ) P % 2 -> 1 P / 2 -> findSize ( N / 2 ) ; Function to return the count of 1 s in the range array of L , R   ; Base Case ; PART 1 -> N / 2 array of 1 , Siz_M   ; Update the right end point of the range to min ( Siz_M , R ) ; PART 2 -> N % 2 array of SizM + 1 , Siz_M + 1   ; PART 3 -> N / 2 array of SizM + 2 , 2 * Siz_M - 1   Same as PART 1 Property of Symmetricity Shift the coordinates according to PART 1 Subtract ( Siz_M + 1 ) from both L , R ; Driver Code ; Input ; Counts the number of 1 's in  the range array ofL, R 
",0
734,"minswaps assign to integer with minswaps assign to integer array of size array of   and n assign to integer, count assign to 0
create integer num_unplaced_zeros with num_unplaced_zeros assign to 0
untill index assign to n - 1 to 0 inclusive, increment num_unplaced_zeros by 1
else count assign to count + num_unplaced_zeros
return count
declare integer main ( ) and integer arr array of   assign to  0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1  ;
print minswaps ( arr, 9 )
return 0
","Minimum adjacent swaps required to Sort Binary array 
  ; Driver Code
",1
735,"minswaps assign to integer with minswaps assign to integer array of size array of   and n assign to integer, count assign to 0
create integer num_unplaced_zeros with num_unplaced_zeros assign to 0
untill index assign to n - 1 to 0 inclusive, increment num_unplaced_zeros by 1
else count assign to count + num_unplaced_zeros
return count
declare integer main ( ) and integer arr array of   assign to  0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1  ;
print minswaps ( arr, 9 )
return 0
","Find all elements in array which have at 
 C ++ program to find all elements in array which have atleast two greater elements itself . ; If current element is smaller than first then update both first and second ; If arr array of i   is in between first and second then update second ; Driver code
",0
736,"if n is 0 n is 1 return true
return false if arr array of i - 1   > arr array of i  
return true
declare integer main ( ), integer arr assign to  20, 23, 23, 45, 78, 88  ; declare integer array arr assign to  20, 23, 23, 23, 45, 78, 88
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
if arraySortedOrNot ( arr, n ) is true, print Yes STRNEWLINE
else print No STRNEWLINE
","Program to check if an array is sorted or not ( Iterative and Recursive ) 
 C ++ program to check if an Array is sorted or not ; Function that returns true if array is sorted in non - decreasing order . ; Array has one or no element ; Unsorted pair found ; No unsorted pair found ; Driver code
",1
737,"if n is 0 n is 1 return true
return false if arr array of i - 1   > arr array of i  
return true
declare integer main ( ), integer arr assign to  20, 23, 23, 45, 78, 88  ; declare integer array arr assign to  20, 23, 23, 23, 45, 78, 88
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
if arraySortedOrNot ( arr, n ) is true, print Yes STRNEWLINE
else print No STRNEWLINE
","Sort the array in a given index range 
 C ++ program to sort the array in a given index range ; Function to sort the elements of the array from index a to index b ; Variables to store start and end of the index range ; Sort the subarray from arr array of l   to arr array of r   ; Print the modified array ; Driver code
",0
738,"declare printTwoOdd with integers arr array of  , size, xor2 assign to arr array of 0  
create integer set_bit_no
create integer i
n assign to integer with n assign to size - 2
create integers x, y with x assign to 0 and y assign to 0
untill i assign to 1 to size exclusive, set xor2 to xor2 and arr array of i  
set_bit_no assign to xor2 and  ( xor2 - 1 )
untill i assign to 0 to size exclusive, x assign to x  arr array of i  
else y assign to y  arr array of i  
print "" The two ODD elements are "" x  "" & ""  y
declare integer main ( ) and integer arr array of   assign to  4, 2, 4, 5, 2, 3, 3, 1  ;
create integer arr_size with arr_size assign to sizeof ( arr) / sizeof ( arr array of 0   )
printTwoOdd ( arr, arr_size )
return 0
","Find the two numbers with odd occurrences in an unsorted array 
 C ++ Program to find the two odd occurring elements ; Prints two numbers that occur odd number of times . The function assumes that the array size is at least 2 and there are exactly two numbers occurring odd number of times . ; Will hold XOR of two odd occurring elements ; Will have only single set bit of xor2 ; Get the xor of all elements in arr array of   . The xor will basically be xor of two odd occurring elements ; Get one set bit in the xor2 . We get rightmost set bit in the following line as it is easy to get ; Now divide elements in two sets : 1 ) The elements having the corresponding bit as 1. 2 ) The elements having the corresponding bit as 0. ; XOR of first set is finally going to hold one odd occurring number x ; XOR of second set is finally going to hold the other odd occurring number y ; Driver code
",1
739,"declare printTwoOdd with integers arr array of  , size, xor2 assign to arr array of 0  
create integer set_bit_no
create integer i
n assign to integer with n assign to size - 2
create integers x, y with x assign to 0 and y assign to 0
untill i assign to 1 to size exclusive, set xor2 to xor2 and arr array of i  
set_bit_no assign to xor2 and  ( xor2 - 1 )
untill i assign to 0 to size exclusive, x assign to x  arr array of i  
else y assign to y  arr array of i  
print "" The two ODD elements are "" x  "" & ""  y
declare integer main ( ) and integer arr array of   assign to  4, 2, 4, 5, 2, 3, 3, 1  ;
create integer arr_size with arr_size assign to sizeof ( arr) / sizeof ( arr array of 0   )
printTwoOdd ( arr, arr_size )
return 0
","Find smallest range containing elements from k lists 
 C ++ program to finds out smallest range that includes elements from each of the given sorted lists . ; array untill storing the current index of list i ; This function takes an k sorted lists in the untillm of 2D array as an argument . It finds out smallest range that includes elements from each of the k lists . ; initializing to 0 index ; ; untill maintaining the index of list containing the minimum element ; iterating over all the list ; if every element of list array of i   is traversed then break the loop ; find minimum value among all the list elements pointing by the ptr array of   array ; update the index of the list ; find maximum value among all the list elements pointing by the ptr array of   array ; if any list exhaust we will not get any better answer , so break the untill loop ; updating the minrange ; Driver program to test above function
",0
740,"printTwoOdd is a void function with int arguments arr array of   and size, printTwoOdd is a void function with int arguments arr and size, and int arguments m
untill i assign to 0 to size exclusive, increment m array of arr array of i    
print ""The two ODD elements are ""
untill x : m, if second % 2 is not 0, print x. first, "", ""
declare integer main ( ) and integer arr assign to  4, 2, 4, 5, 2, 3, 3, 1  ;
create integer arr_size with arr_size assign to sizeof ( arr) / sizeof ( arr array of 0   )
printTwoOdd ( arr, arr_size )
return 0
","Find the two numbers with odd occurrences in an unsorted array 
 C ++ Program to find the two odd occurring elements ; Prints two numbers that occur odd number of times . The function assumes that the array size is at least 2 and there are exactly two numbers occurring odd number of times . ; Create map and calculate frequency of array of * elements using array . ; Traverse through the map and check if its second element that is the frequency is odd or not . Then this is the odd occurring element . Its is clearly mentioned in problem that there are only two odd occurring elements so this will print those two elements . ; Driver code
",1
741,"printTwoOdd is a void function with int arguments arr array of   and size, printTwoOdd is a void function with int arguments arr and size, and int arguments m
untill i assign to 0 to size exclusive, increment m array of arr array of i    
print ""The two ODD elements are ""
untill x : m, if second % 2 is not 0, print x. first, "", ""
declare integer main ( ) and integer arr assign to  4, 2, 4, 5, 2, 3, 3, 1  ;
create integer arr_size with arr_size assign to sizeof ( arr) / sizeof ( arr array of 0   )
printTwoOdd ( arr, arr_size )
return 0
","Recursive Selection Sort 
 Recursive C ++ program to sort an array using selection sort ; Return minimum index ; Find minimum of remaining elements ; Return minimum of current and remaining . ; Recursive selection sort . n is size of a array of   and index is index of starting element . ; Return when starting and size are same ; calling minimum index function untill minimum index ; Swapping when index nd minimum index are not same ; swap ; Recursively calling selection sort function ; Driver code ; Calling function ; printing sorted array
",0
742,"declare findPair with integer arr array of  , size, n as arguments, set i to 0
create integer j with j assign to 1
untill i is less than size and j is less than size, print Pair Found : ( ""  arr array of i    "", "" arr array of j    "" )
return true
else if arr array ofj  - arr array of i    n, increment j
else i is incremented by 1
print ""No such pair ""
return false
declare integer main ( ), integer arr array of   assign to  1, 8, 30, 40, 100  ;
size assign to integer with size assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create integer n with n assign to 60
findPair ( arr, size, n )
return 0
","Find a pair with the given difference 
 C ++ program to find a pair with the given difference ; The function assumes that the array is sorted ; Initialize positions of two elements ; Search untill a pair ; Driver program to test above function
",1
743,"declare findPair with integer arr array of  , size, n as arguments, set i to 0
create integer j with j assign to 1
untill i is less than size and j is less than size, print Pair Found : ( ""  arr array of i    "", "" arr array of j    "" )
return true
else if arr array ofj  - arr array of i    n, increment j
else i is incremented by 1
print ""No such pair ""
return false
declare integer main ( ), integer arr array of   assign to  1, 8, 30, 40, 100  ;
size assign to integer with size assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create integer n with n assign to 60
findPair ( arr, size, n )
return 0
","Program to find the Encrypted word 
 C ++ program to implement the above approach ; Function to find the encrypted string ; to store the encrypted string ; after ' z ' , it should go to a . ; Driver code
",0
744,"printMax is a void function with int arguments arr array of  , k, n, vector and int arguments brr ( arr, arr + n)
sort ( brr. begin ( ), brr. end ( ), greater  integer > ( ) ) )
untill i assign to 0 to n exclusive, print arr array of i   and "" ""
declare integer main ( ), integer arr assign to  50, 8, 45, 12, 25, 40, 84
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create integer k with k assign to 3
printMax ( arr, k, n )
return 0
","Find k maximum elements of array in original order 
 C ++ program to find k maximum elements of array in original order ; Function to print m Maximum elements ; vector to store the copy of the original array ; Sorting the vector in descending order . Please refer below link untill details www . geeksuntillgeeks . org / sort - c - stl / https : ; Traversing through original array and printing all those elements that are in first k of sorted vector . goo . gl / 44 Rwgt Please refer https : untill details of binary_search ( ) ; Driver code
",1
745,"printMax is a void function with int arguments arr array of  , k, n, vector and int arguments brr ( arr, arr + n)
sort ( brr. begin ( ), brr. end ( ), greater  integer > ( ) ) )
untill i assign to 0 to n exclusive, print arr array of i   and "" ""
declare integer main ( ), integer arr assign to  50, 8, 45, 12, 25, 40, 84
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create integer k with k assign to 3
printMax ( arr, k, n )
return 0
","Double the first element and move zero to end 
 C ++ implementation to rearrange the array elements after modification ; function which pushes all zeros to end of an array . ; Count of non - zero elements ; Traverse the array . If element encountered is non - zero , then replace the element at index ' count ' with this element ; here count is incremented ; Now all non - zero elements have been shifted to front and ' count ' is set as index of first 0. Make all elements 0 from count to end . ; function to rearrange the array elements after modification ; if ' arr array of   ' contains a single element only ; traverse the array ; if true , peruntillm the required modification ; double current index value ; put 0 in the next index ; increment by 1 so as to move two indexes ahead during loop iteration ; push all the zeros at the end of ' arr array of   ' ; function to print the array elements ; Driver program to test above
",0
746,"printSmall is a void function with int arguments arr array of   and asize, int argument n, and vector argument of int > copy_arr ( arr, arr + asize)
sort ( copy_arr. begin ( ), copy_arr. begin ( ) + asize )
untill i assign to 0 to asize exclusive, print arr array of i  and "" ""
declare integer main ( ) and integer arr array of   assign to  1, 5, 8, 9, 6, 7, 3, 4, 2, 0
asize assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create integer n with n assign to 5
printSmall ( arr, asize, n )
return 0
","Print n smallest elements from given array in their original order 
 CPP untill printing smallest n number in order ; Function to print smallest n numbers ; Make copy of array ; Sort copy array ; For each arr array of i   find whether it is a part of n - smallest with binary search ; Driver program
",1
747,"printSmall is a void function with int arguments arr array of   and asize, int argument n, and vector argument of int > copy_arr ( arr, arr + asize)
sort ( copy_arr. begin ( ), copy_arr. begin ( ) + asize )
untill i assign to 0 to asize exclusive, print arr array of i  and "" ""
declare integer main ( ) and integer arr array of   assign to  1, 5, 8, 9, 6, 7, 3, 4, 2, 0
asize assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create integer n with n assign to 5
printSmall ( arr, asize, n )
return 0
","Recursive Insertion Sort 
 Recursive C ++ program untill insertion sort ; Recursive function to sort an array using insertion sort ; Base case ; Sort first n - 1 elements ; Insert last element at its correct position in sorted array . ; Move elements of arr array of 0. . i - 1   , that are greater than key , to one position ahead of their current position ; A utility function to print an array of size n ; Driver program to test insertion sort
",0
748,"if n is equal to 1 return true
sort arr, arr + n
create integer d with d assign to arr array of 1  - arr array of 0  
return false if arr array of i   - arr array of i - 1   is not d
return true
declare integer main ( ), integer arr array of   assign to  20, 15, 5, 0, 10  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print Yes and a new line if checkIsAP is true, else print No
return 0
","Check whether Arithmetic Progression can be untillmed from the given array 
 C ++ program to check if a given array can untillm arithmetic progression ; Returns true if a permutation of arr array of 0. . n - 1   can untillm arithmetic progression ; Sort array ; After sorting , difference between consecutive elements must be same . ; Driven Program
",1
749,"if n is equal to 1 return true
sort arr, arr + n
create integer d with d assign to arr array of 1  - arr array of 0  
return false if arr array of i   - arr array of i - 1   is not d
return true
declare integer main ( ), integer arr array of   assign to  20, 15, 5, 0, 10  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print Yes and a new line if checkIsAP is true, else print No
return 0
","Total time required to travel a path denoted by a given string 
 C ++ code untill the above approach ; Function to calculate time taken to travel the path ; Stores total time ; Initial position ; Stores visited segments ; Check whether segment is present in the set ; Increment the value of time by 2 ; Insert segment into the set ; Print the value of time ; Driver Code
",0
750,"checkIsAP is a boolean function with int arguments arr array of   and n, untill desdered_map is a boolean function, int is a new function with int arguments hm and int arguments hm
create integers smallest assign to INT_MAX, second_smallest assign to INT_MAX
untill i assign to 0 to n exclusive, if arr array of i   is less than smallest, set second_smallest to smallest
let smallest be arr array of i  
else if arr array of i   is not smallest and arr array of i   is less than second_smallest, set second_smallest to arr array of i  
if find ( arr array of i   ) is hm. end ( ) ), increment hm array of arr array of i    
else return false
diff assign to second_smallest - smallest
untill i assign to 0 to n - 1 exclusive, return false if hm. find ( second_smallest ) is hm. end ( )
increment second_smallest by diff
return true
declare integer main ( ), integer arr array of   assign to  20, 15, 5, 0, 10  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print Yes and a new line if checkIsAP is true, else print No
return 0
","Check whether Arithmetic Progression can be untillmed from the given array 
 C ++ program to check if a given array can untillm arithmetic progression ; Returns true if a permutation of arr array of 0. . n - 1   can untillm arithmetic progression ; Find the smallest and and update second smallest ; Find second smallest ; Check if the duplicate element found or not ; If duplicate found then return false ; Find the difference between smallest and second smallest ; As we have used smallest and second smallest , so we should now only check untill n - 2 elements ; Driven Program
",1
751,"checkIsAP is a boolean function with int arguments arr array of   and n, untill desdered_map is a boolean function, int is a new function with int arguments hm and int arguments hm
create integers smallest assign to INT_MAX, second_smallest assign to INT_MAX
untill i assign to 0 to n exclusive, if arr array of i   is less than smallest, set second_smallest to smallest
let smallest be arr array of i  
else if arr array of i   is not smallest and arr array of i   is less than second_smallest, set second_smallest to arr array of i  
if find ( arr array of i   ) is hm. end ( ) ), increment hm array of arr array of i    
else return false
diff assign to second_smallest - smallest
untill i assign to 0 to n - 1 exclusive, return false if hm. find ( second_smallest ) is hm. end ( )
increment second_smallest by diff
return true
declare integer main ( ), integer arr array of   assign to  20, 15, 5, 0, 10  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print Yes and a new line if checkIsAP is true, else print No
return 0
","Highest power of 2 less than or equal to given number 
 C ++ program to find highest power of 2 smaller than or equal to n . ; check untill the set bits ; Then we remove all but the top bit by xor ' ing â– the â– â– string â– of â– 1' s with that string of 1 ' s â– shifted â– one â– to â– â– the â– left , â– and â– we â– end â– up â– with â– just â– the â– one â– top â– bit â– â– followed â– by â– 0' s . ; Driver code
",0
752,"declare countPairs with integers a array of   and n, set mn to INT_MAX
create integer mx with mx assign to INT_MIN
untill i assign to 0 to n exclusive, set mn to min ( mn, a array of i   )
mx assign to max ( mx, a array of i   )
c1 assign to integer with c1 assign to 0
create integer c2 with c2 assign to 0
untill i assign to 0 to n exclusive, increment c1 by 1 if a array of i   is mn
if a array of i   is mx, increment c2
if mn is equal to mx, return n * ( n - 1 ) / 2
else return c1 * c2
declare integer main ( ), integer array a with size   assign to  3, 2, 1, 1, 3  ;
create integer n with n assign to sizeof ( a ) / sizeof ( a array of 0   )
print countPairs ( a, n )
return 0
","Count ways of choosing a pair with maximum difference 
 CPP Code to find no . of Ways of choosing a pair with maximum difference ; To find minimum and maximum of the array ; to find the count of minimum and maximum elements ; Count variables ; condition untill all elements equal ; Driver code
",1
753,"declare countPairs with integers a array of   and n, set mn to INT_MAX
create integer mx with mx assign to INT_MIN
untill i assign to 0 to n exclusive, set mn to min ( mn, a array of i   )
mx assign to max ( mx, a array of i   )
c1 assign to integer with c1 assign to 0
create integer c2 with c2 assign to 0
untill i assign to 0 to n exclusive, increment c1 by 1 if a array of i   is mn
if a array of i   is mx, increment c2
if mn is equal to mx, return n * ( n - 1 ) / 2
else return c1 * c2
declare integer main ( ), integer array a with size   assign to  3, 2, 1, 1, 3  ;
create integer n with n assign to sizeof ( a ) / sizeof ( a array of 0   )
print countPairs ( a, n )
return 0
","Number of paths with exactly k coins 
 A Dynamic Programming based C ++ program to count paths with exactly ' k ' coins ; Base cases ; If this subproblem is already solved ; ( m , n ) can be reached either through ( m - 1 , n ) or through ( m , n - 1 ) ; This function mainly initializes dp array of   array of   array of   and calls pathCountDPRecDP ( ) ; Driver Program to test above functions
",0
754,"create struct node  integer data
create struct node * next
print a newline
create typedef struct Node Node
if node * head is NULL, return void
assign head, curr to head -> next to Node * prev
untill curr is true, swap prev -> data and curr -> data
if curr -> next and curr -> next -> data > curr -> data swap curr -> next -> data, curr -> data
set prev to curr -> next
if curr is not equal to next, break loop
set curr to curr -> next -> next
push assign to void with node * head, integer k, node * tem assign to ( Node * ) malloc assign to sizeof ( Node )
set tem -> data to k
set tem -> next to * head
set head to tem
void display ( Node * head ), Node * curr assign to head
untill curr is not NULL, printf ( "" % d "", curr -> data )
set curr to curr -> next
declare integer main ( ), Node * head assign to NULL
push ( & head, 7 )
push ( & head, 3 )
push ( & head, 8 )
push ( & head, 6 )
push ( & head, 9 )
rearrange head
display ( head )
return 0
","Rearrange a given linked list in 
 C ++ code to rearrange linked list in place ; function untill rearranging a linked list with high and low value . ; Base case . ; two pointer variable . ; swap function untill swapping data . ; swap function untill swapping data . ; function to insert a node in the linked list at the beginning . ; function to display node of linked list . ; driver code ; let create a linked list . 9 -> 6 -> 8 -> 3 -> 7
",1
755,"create struct node  integer data
create struct node * next
print a newline
create typedef struct Node Node
if node * head is NULL, return void
assign head, curr to head -> next to Node * prev
untill curr is true, swap prev -> data and curr -> data
if curr -> next and curr -> next -> data > curr -> data swap curr -> next -> data, curr -> data
set prev to curr -> next
if curr is not equal to next, break loop
set curr to curr -> next -> next
push assign to void with node * head, integer k, node * tem assign to ( Node * ) malloc assign to sizeof ( Node )
set tem -> data to k
set tem -> next to * head
set head to tem
void display ( Node * head ), Node * curr assign to head
untill curr is not NULL, printf ( "" % d "", curr -> data )
set curr to curr -> next
declare integer main ( ), Node * head assign to NULL
push ( & head, 7 )
push ( & head, 3 )
push ( & head, 8 )
push ( & head, 6 )
push ( & head, 9 )
rearrange head
display ( head )
return 0
","Count of numbers in range array of L , R   having sum of digits of its square equal to square of sum of digits 
 C ++ program untill the above approach ; Function to check if the number is valid ; Sum of digits of num ; Squared number ; Sum of digits of ( num * num ) ; Function to convert a string to an integer ; Function to generate all possible strings of length len ; Desired string ; Take only valid numbers ; Recurse untill all possible digits ; Function to calculate unique numbers in range array of L , R   ; Initialize a variable to store the answer ; Calculate the maximum possible length ; Set to store distinct valid numbers ; Generate all possible strings of length i ; Iterate the set to get the count of valid numbers in the range array of L , R   ; Driver Code
",0
756,"create struct Node  integer data
Node assign to struct * next
print a newline
Node * newNode ( int data)  Node * temp assign to new Node
set temp -> data to data
set temp -> next to NULL
return temp
create integer getLength ( Node * Node ) and integer size assign to 0
untill Node is not NULL, set Node to Node -> next
increment size
return size
if sNode is NULL return NULL
Node * zHead assign to newNode ( 0 )
decrement diff
assign zHead to Node * temp
untill diff --, temp -> next assign to newNode ( 0 )
set temp to temp -> next
set temp -> next to sNode
return zHead
if l1 is NULL and l2 is NULL and borrow is 0, return NULL
set Node * previous to subtractLinkedListHelper ( l1 if l1 -> next if NULL, l2 if l2 -> next if NULL, borrow )
d1 assign to integer with d1 assign to l1 -> data
d2 assign to integer with d2 assign to l2 -> data
sub assign to integer with sub assign to 0
if borrow is true, decrement d1
set borrow to false
if d1 is less than d2 then set borrow to true
set d1 to d1 + 10
sub assign to d1 - d2
Node * current assign to newNode ( sub )
set current -> next to previous
return current
if l1 is NULL and l2 is NULL return NULL
create integer len1 with len1 assign to getLength ( l1 )
create integer len2 with len2 assign to getLength ( l2 )
Node * lNode assign to NULL, * sNode assign to NULL
assign l1 to Node * temp1
assign l2 to Node * temp2
if len1 is not len2 then set lNode to len1 > len2? l1 : l2
sNode assign to len1 > len2? l2 : l1
set sNode to paddZeros ( sNode, abs ( len1 - len2 ) ) )
else if l1 && l2 different from l2 -> data, set lNode to l1 -> data > l2 -> data? temp1 : temp2
sNode assign to l1 -> data > l2 -> data? temp2 : temp1
break loop
l1 assign to l1 -> next
set l2 to l2 -> next
create boolean borrow with borrow assign to false
return subtractLinkedListHelper ( lNode, sNode, borrow )
printList is a void function, untill Node is not NULL, printf is a void function
Node assign to Node -> next
printf is a newline
declare integer main ( ), Node * head1 assign to newNode ( 0 ) )
head1 -> next assign to newNode ( 0 )
head1 -> next -> next assign to newNode ( 0 )
Node * head2 assign to newNode ( 1 )
assign subtractLinkedList ( head1, head2 ) to Node * result
printList is a new function
return 0
","Subtract Two Numbers represented as Linked Lists 
 C ++ program to subtract smaller valued list from larger valued list and return result as a list . ; A linked List Node ; A utility function to get length of linked list ; A Utility that padds zeros in front of the Node , with the given diff ; Subtract LinkedList Helper is a recursive function , move till the last Node , and subtract the digits and create the Node and return the Node . If d1 < d2 , we borrow the number from previous digit . ; if you have given the value value to next digit then reduce the d1 by 1 ; If d1 < d2 , then borrow the number from previous digit . Add 10 to d1 and set borrow assign to true ; ; subtract the digits ; Create a Node with sub value ; Set the Next pointer as Previous ; This API subtracts two linked lists and returns the linked list which shall have the subtracted result . ; Base Case . ; In either of the case , get the lengths of both Linked list . ; If lengths differ , calculate the smaller Node and padd zeros untill smaller Node and ensure both larger Node and smaller Node has equal length . ; If both list lengths are equal , then calculate the larger and smaller list . If 5 - 6 - 7 & 5 - 6 - 8 are linked list , then walk through linked list at last Node as 7 < 8 , larger Node is 5 - 6 - 8 and smaller Node is 5 - 6 - 7. ; After calculating larger and smaller Node , call subtractLinkedListHelper which returns the subtracted linked list . ; A utility function to print linked list ; Driver program to test above functions
",1
757,"create struct Node  integer data
Node assign to struct * next
print a newline
Node * newNode ( int data)  Node * temp assign to new Node
set temp -> data to data
set temp -> next to NULL
return temp
create integer getLength ( Node * Node ) and integer size assign to 0
untill Node is not NULL, set Node to Node -> next
increment size
return size
if sNode is NULL return NULL
Node * zHead assign to newNode ( 0 )
decrement diff
assign zHead to Node * temp
untill diff --, temp -> next assign to newNode ( 0 )
set temp to temp -> next
set temp -> next to sNode
return zHead
if l1 is NULL and l2 is NULL and borrow is 0, return NULL
set Node * previous to subtractLinkedListHelper ( l1 if l1 -> next if NULL, l2 if l2 -> next if NULL, borrow )
d1 assign to integer with d1 assign to l1 -> data
d2 assign to integer with d2 assign to l2 -> data
sub assign to integer with sub assign to 0
if borrow is true, decrement d1
set borrow to false
if d1 is less than d2 then set borrow to true
set d1 to d1 + 10
sub assign to d1 - d2
Node * current assign to newNode ( sub )
set current -> next to previous
return current
if l1 is NULL and l2 is NULL return NULL
create integer len1 with len1 assign to getLength ( l1 )
create integer len2 with len2 assign to getLength ( l2 )
Node * lNode assign to NULL, * sNode assign to NULL
assign l1 to Node * temp1
assign l2 to Node * temp2
if len1 is not len2 then set lNode to len1 > len2? l1 : l2
sNode assign to len1 > len2? l2 : l1
set sNode to paddZeros ( sNode, abs ( len1 - len2 ) ) )
else if l1 && l2 different from l2 -> data, set lNode to l1 -> data > l2 -> data? temp1 : temp2
sNode assign to l1 -> data > l2 -> data? temp2 : temp1
break loop
l1 assign to l1 -> next
set l2 to l2 -> next
create boolean borrow with borrow assign to false
return subtractLinkedListHelper ( lNode, sNode, borrow )
printList is a void function, untill Node is not NULL, printf is a void function
Node assign to Node -> next
printf is a newline
declare integer main ( ), Node * head1 assign to newNode ( 0 ) )
head1 -> next assign to newNode ( 0 )
head1 -> next -> next assign to newNode ( 0 )
Node * head2 assign to newNode ( 1 )
assign subtractLinkedList ( head1, head2 ) to Node * result
printList is a new function
return 0
","Sort a Bitonic Array 
 C ++ program untill the above approach ; Function to Sort a Bitonic array in constant space ; Initialize the value of k ; In each iteration compare elements k distance apart and swap if they are not in order ; k is reduced to half after every iteration ; Print the array elements ; Driver Code ; Given array arr array of   ; Function Call
",0
758,"create struct Node  integer data
Node * next
print a newline
Node * getNode ( integer data)  Node * newNode assign to ( Node * ) malloc ( sizeof ( Node ) )
set newNode -> data to data
set newNode -> next to NULL
return newNode
if ( * head_ref assign to NULL) * head_ref assign to getNode ( x )
else  Node * newNode assign to getNode (x )
assign the new value assign to head_ref to Node * ptr
create integer len with len assign to 0
untill ptr is not NULL, increment len
set ptr to ptr -> next
if len modulo 2 is 0, else len + 1 is true
set ptr to * head_ref
untill count is greater than 1 set ptr to ptr -> next
set newNode -> next to ptr -> next
set ptr -> next to newNode
print Node * head and untill head is not NULL print head -> data and "" ""
set head to head -> next
declare integer main ( ), Node * head assign to NULL
head assign to getNode ( 1 )
head -> next assign to getNode ( 2 )
head -> next -> next assign to getNode ( 4 )
head -> next -> next -> next assign to getNode ( 5 )
print Linked list beuntille insertion
display ( head )
create integer x with x assign to 3
insertAtMid ( & head, x )
print Linked list after insertion : "" display ( head )
return 0
","Insert node into the middle of the linked list 
 C ++ implementation to insert node at the middle of the linked list ; structure of a node ; function to create and return a node ; function to insert node at the middle of the linked list ; if list is empty ; get a new node ; calculate length of the linked list , i . e , the number of nodes ; ' count ' the number of nodes after which the new node is to be inserted ; ' ptr ' points to the node after which the new node is to be inserted ; insert the ' newNode ' and adjust the required links ; function to display the linked list ; Driver program to test above ; Creating the list 1 -> 2 -> 4 -> 5
",1
759,"create struct Node  integer data
Node * next
print a newline
Node * getNode ( integer data)  Node * newNode assign to ( Node * ) malloc ( sizeof ( Node ) )
set newNode -> data to data
set newNode -> next to NULL
return newNode
if ( * head_ref assign to NULL) * head_ref assign to getNode ( x )
else  Node * newNode assign to getNode (x )
assign the new value assign to head_ref to Node * ptr
create integer len with len assign to 0
untill ptr is not NULL, increment len
set ptr to ptr -> next
if len modulo 2 is 0, else len + 1 is true
set ptr to * head_ref
untill count is greater than 1 set ptr to ptr -> next
set newNode -> next to ptr -> next
set ptr -> next to newNode
print Node * head and untill head is not NULL print head -> data and "" ""
set head to head -> next
declare integer main ( ), Node * head assign to NULL
head assign to getNode ( 1 )
head -> next assign to getNode ( 2 )
head -> next -> next assign to getNode ( 4 )
head -> next -> next -> next assign to getNode ( 5 )
print Linked list beuntille insertion
display ( head )
create integer x with x assign to 3
insertAtMid ( & head, x )
print Linked list after insertion : "" display ( head )
return 0
","Expected Number of Trials to get N Consecutive Heads 
 C ++ implementation of the above approach ; Driver Code ; Formula untill number of trails untill N consecutive heads
",0
760,"create struct Node  integer data
Node * next
print a newline
Node * getNode ( integer data)  Node * newNode assign to ( Node * ) malloc ( sizeof ( Node ) )
set newNode -> data to data
set newNode -> next to NULL
return newNode
if ( * head_ref assign to NULL) * head_ref assign to getNode ( x )
else  Node * newNode assign to getNode (x )
Node * slow assign to * head_ref
Node * fast assign to ( * head_ref ) -> next
untill fast and fast -> next, slow assign to slow -> next
set fast to fast -> next -> next
set newNode -> next to slow -> next
set slow to slow -> next to newNode
print Node * head and untill head is not NULL print head -> data and "" ""
set head to head -> next
declare integer main ( ), Node * head assign to NULL
head assign to getNode ( 1 )
head -> next assign to getNode ( 2 )
head -> next -> next assign to getNode ( 4 )
head -> next -> next -> next assign to getNode ( 5 )
print Linked list beuntille insertion
display ( head )
create integer x with x assign to 3
insertAtMid ( & head, x )
print Linked list after insertion : "" display ( head )
return 0
","Insert node into the middle of the linked list 
 C ++ implementation to insert node at the middle of the linked list ; structure of a node ; function to insert node at the middle of the linked list ; if list is empty ; get a new node ; assign values to the slow and fast pointers ; move slow pointer to next node ; move fast pointer two nodes at a time ; insert the ' newNode ' and adjust the required links ; function to display the linked list ; Driver program to test above ; Creating the list 1 -> 2 -> 4 -> 5
",1
761,"create struct Node  integer data
Node * next
print a newline
Node * getNode ( integer data)  Node * newNode assign to ( Node * ) malloc ( sizeof ( Node ) )
set newNode -> data to data
set newNode -> next to NULL
return newNode
if ( * head_ref assign to NULL) * head_ref assign to getNode ( x )
else  Node * newNode assign to getNode (x )
Node * slow assign to * head_ref
Node * fast assign to ( * head_ref ) -> next
untill fast and fast -> next, slow assign to slow -> next
set fast to fast -> next -> next
set newNode -> next to slow -> next
set slow to slow -> next to newNode
print Node * head and untill head is not NULL print head -> data and "" ""
set head to head -> next
declare integer main ( ), Node * head assign to NULL
head assign to getNode ( 1 )
head -> next assign to getNode ( 2 )
head -> next -> next assign to getNode ( 4 )
head -> next -> next -> next assign to getNode ( 5 )
print Linked list beuntille insertion
display ( head )
create integer x with x assign to 3
insertAtMid ( & head, x )
print Linked list after insertion : "" display ( head )
return 0
","Construct a matrix with sum equal to the sum of diagonal elements 
 C ++ program to implement the above approach ; Function to construct matrix with diagonal sum equal to matrix sum ; If diagonal position ; Positive element ; Negative element ; Driver Code
",0
762,"create struct Node  integer data
Node * prev, * next assign to struct
print a newline
declare struct Node * getNode ( integer data), struct Node * newNode assign to ( struct Node * ) malloc ( sizeof ( struct Node ) )
set newNode -> data to data
newNode -> prev assign to newNode -> next assign to NULL
return newNode
insert struct Node * head_ref, struct Node * newNode and struct Node * current into void
if head_ref is NULL, head_ref assign to newNode
else if ( * head_ref ) -> data >assign to newNode -> data )  newNode -> next assign to * head_ref
newNode -> next -> prev assign to newNode
* head_ref assign to newNode
else set current to * head_ref
untill current -> next is not NULL and current -> next -> data is less than newNode -> data, set current to current -> next
newNode -> next assign to current -> next
if current -> next is not NULL, set newNode -> next -> prev to newNode
set current -> next to newNode
newNode -> prev assign to current
insertionSort is a void function with node * head_ref elements and node * sorted is equal to NULL
Node * current assign to * head_ref
untill current is not NULL, set Node * next to current -> next
set current -> prev to current -> next to NULL
insert sorted, current into sorted
set current to next
* head_ref assign to sorted
printList is a void function with node * head and untill head is not NULL print head -> data and "" ""
set head to head -> next
push assign to void, struct Node * head_ref, int new_data assign to struct Node * new_node assign to ( struct Node * ) malloc ( sizeof ( struct Node ) )
new_node -> data assign to new_data
new_node -> next assign to ( * head_ref )
new_node -> prev assign to NULL
if ( * head_ref ) is not NULL) ( * head_ref ) -> prev assign to new_node
change the value of new_node to ( * head_ref )
declare integer main ( ) and struct Node * head assign to NULL
push ( & head, 9 )
push ( & head, 3 )
push ( & head, 5 )
push ( & head, 10 )
push ( & head, 12 )
push ( & head, 8 )
print Doubly Linked List Beuntille Sortingn
printList is a new line
print insertionSort ( & head )
print "" nDoubly Linked List After Sortingn ""
printList is a new line
return 0
","Insertion Sort untill Doubly Linked List 
 C ++ implementation untill insertion Sort on a doubly linked list ; Node of a doubly linked list ; function to create and return a new node of a doubly linked list ; allocate node ; put in the data ; function to insert a new node in sorted way in a sorted doubly linked list ; if list is empty ; if the node is to be inserted at the beginning of the doubly linked list ; locate the node after which the new node is to be inserted ; Make the appropriate links ; if the new node is not inserted at the end of the list ; function to sort a doubly linked list using insertion sort ; Initialize ' sorted ' - a sorted doubly linked list ; Traverse the given doubly linked list and insert every node to ' sorted ' ; Store next untill next iteration ; removing all the links so as to create ' current ' as a new node untill insertion ; insert current in ' sorted ' doubly linked list ; Update current ; Update head_ref to point to sorted doubly linked list ; function to print the doubly linked list ; function to insert a node at the beginning of the doubly linked list ; allocate node ; put in the data ; Make next of new node as head and previous as NULL ; change prev of head node to new node ; move the head to point to the new node ; Driver program to test above ; start with the empty doubly linked list ; insert the following data
",1
763,"create struct Node  integer data
Node * prev, * next assign to struct
print a newline
declare struct Node * getNode ( integer data), struct Node * newNode assign to ( struct Node * ) malloc ( sizeof ( struct Node ) )
set newNode -> data to data
newNode -> prev assign to newNode -> next assign to NULL
return newNode
insert struct Node * head_ref, struct Node * newNode and struct Node * current into void
if head_ref is NULL, head_ref assign to newNode
else if ( * head_ref ) -> data >assign to newNode -> data )  newNode -> next assign to * head_ref
newNode -> next -> prev assign to newNode
* head_ref assign to newNode
else set current to * head_ref
untill current -> next is not NULL and current -> next -> data is less than newNode -> data, set current to current -> next
newNode -> next assign to current -> next
if current -> next is not NULL, set newNode -> next -> prev to newNode
set current -> next to newNode
newNode -> prev assign to current
insertionSort is a void function with node * head_ref elements and node * sorted is equal to NULL
Node * current assign to * head_ref
untill current is not NULL, set Node * next to current -> next
set current -> prev to current -> next to NULL
insert sorted, current into sorted
set current to next
* head_ref assign to sorted
printList is a void function with node * head and untill head is not NULL print head -> data and "" ""
set head to head -> next
push assign to void, struct Node * head_ref, int new_data assign to struct Node * new_node assign to ( struct Node * ) malloc ( sizeof ( struct Node ) )
new_node -> data assign to new_data
new_node -> next assign to ( * head_ref )
new_node -> prev assign to NULL
if ( * head_ref ) is not NULL) ( * head_ref ) -> prev assign to new_node
change the value of new_node to ( * head_ref )
declare integer main ( ) and struct Node * head assign to NULL
push ( & head, 9 )
push ( & head, 3 )
push ( & head, 5 )
push ( & head, 10 )
push ( & head, 12 )
push ( & head, 8 )
print Doubly Linked List Beuntille Sortingn
printList is a new line
print insertionSort ( & head )
print "" nDoubly Linked List After Sortingn ""
printList is a new line
return 0
","Minimize the total number of teddies to be distributed 
 C ++ implementation of the above approach ; Initializing one tablet untill each student ; if left adjacent is having higher marks review and change all the dp values assigned beuntille until assigned dp values are found wrong according to given constrains ; if right adjacent is having higher marks add one in dp of left adjacent and assign to right one ; Driver Code ; n number of students ; marks of students ; solution of problem
",0
764,"create integer array arr with size 10000
reverse assign to void with integers arr array of  , s, e, untill s  e, tem assign to arr array of s  
set arr array of s   to arr array of e  
set arr array of e   to tem
set s to s + 1
set e to e - 1
declare fun with integer arr array of  , k, integer n assign to 4 - 1
create integer v with v assign to n - k
if v >assign to 0, reverse ( arr, 0, v )
reverse ( arr, v + 1, n )
reverse ( arr, 0, n )
declare integer main ( ), arr array of 0   assign to 1
set arr array of 1   to 2
set arr array of 2  to 3
arr array of 3  assign to 4
untill i assign to 0 to 4 exclusive, fun ( arr, i )
print ( "" array of "" )
untill j assign to 0 to 4 exclusive, print arr array ofj  and "", ""
print ( ""   "" )
print a newlin
","Print all possible rotations of a given Array 
 C ++ program to print all possible rotations of the given array ; Global declaration of array ; Function to reverse array between indices s and e ; Function to generate all possible rotations of array ; Driver code
",1
765,"create integer array arr with size 10000
reverse assign to void with integers arr array of  , s, e, untill s  e, tem assign to arr array of s  
set arr array of s   to arr array of e  
set arr array of e   to tem
set s to s + 1
set e to e - 1
declare fun with integer arr array of  , k, integer n assign to 4 - 1
create integer v with v assign to n - k
if v >assign to 0, reverse ( arr, 0, v )
reverse ( arr, v + 1, n )
reverse ( arr, 0, n )
declare integer main ( ), arr array of 0   assign to 1
set arr array of 1   to 2
set arr array of 2  to 3
arr array of 3  assign to 4
untill i assign to 0 to 4 exclusive, fun ( arr, i )
print ( "" array of "" )
untill j assign to 0 to 4 exclusive, print arr array ofj  and "", ""
print ( ""   "" )
print a newlin
","Program to find whether a no is power of two 
  ; Function to check if x is power of 2 ; First x in the below expression is untill the case when x is 0 ; Driver code
",0
766,"seg assign to integer array of size 4 * MAX
if l is r, seg array of node  assign to a array of l 
else  integer mid assign to ( l + r ) / 2
create 2 * node, l, mid, a
create build ( 2 * node + 1, mid + 1, r, a )
set seg array of node  to ( seg array of 2 * node  seg array of 2 * node + 1   )
if l > end or r  start, return 0
if start assign to l and r assign to end, return seg array of node 
mid assign to integer with mid assign to ( l + r ) / 2
return ( query ( 2 * node, l, mid, start, end, a ) ) 
 ( query ( 2 * node + 1, mid + 1, r, start, end, a ) ) )
void orsum ( int a array of  , int n, int q, int k array of   ), build ( 1, 0, n - 1, a )
untill j assign to 0 to q exclusive, i assign to k array ofj  modulo (n / 2)
sec assign to query ( 1, 0, n - 1, n / 2 - i, n - i - 1, a )
create integer first with first assign to ( query ( 1, 0, n - 1, 0, n / 2 - 1 - i, a ) 
 query ( 1, 0, n - 1, n - i, n - 1, a ) )
create integer temp with temp assign to sec + first
print temp
declare integer main ( ), integer array a with size   assign to  7, 44, 19, 86, 65, 39, 75, 101
create integer n with n assign to sizeof ( a ) / sizeof ( a array of 0   )
create integer q with q assign to 2
create integer k with k assign to  4, 2  ;
orsum ( a, n, q, k )
return 0
","Find array sum using Bitwise OR after splitting given array in two halves after K circular shifts 
 C ++ Program to find Bitwise OR of two equal halves of an array after peruntillming K right circular shifts ; Array untill storing the segment tree ; Function to build the segment tree ; Function to return the OR of elements in the range array of l , r   ; Check untill out of bound condition ; Find middle of the range ; Recurse untill all the elements in array ; Function to find the OR sum ; Function to build the segment Tree ; Loop to handle q queries ; Effective number of right circular shifts ; OR of second half of the array array of n / 2 - i , n - 1 - i   ; OR of first half of the array array of n - i , n - 1   OR array of 0 , n / 2 - 1 - i   ; Print final answer to the query ; Driver Code
",1
767,"seg assign to integer array of size 4 * MAX
if l is r, seg array of node  assign to a array of l 
else  integer mid assign to ( l + r ) / 2
create 2 * node, l, mid, a
create build ( 2 * node + 1, mid + 1, r, a )
set seg array of node  to ( seg array of 2 * node  seg array of 2 * node + 1   )
if l > end or r  start, return 0
if start assign to l and r assign to end, return seg array of node 
mid assign to integer with mid assign to ( l + r ) / 2
return ( query ( 2 * node, l, mid, start, end, a ) ) 
 ( query ( 2 * node + 1, mid + 1, r, start, end, a ) ) )
void orsum ( int a array of  , int n, int q, int k array of   ), build ( 1, 0, n - 1, a )
untill j assign to 0 to q exclusive, i assign to k array ofj  modulo (n / 2)
sec assign to query ( 1, 0, n - 1, n / 2 - i, n - i - 1, a )
create integer first with first assign to ( query ( 1, 0, n - 1, 0, n / 2 - 1 - i, a ) 
 query ( 1, 0, n - 1, n - i, n - 1, a ) )
create integer temp with temp assign to sec + first
print temp
declare integer main ( ), integer array a with size   assign to  7, 44, 19, 86, 65, 39, 75, 101
create integer n with n assign to sizeof ( a ) / sizeof ( a array of 0   )
create integer q with q assign to 2
create integer k with k assign to  4, 2  ;
orsum ( a, n, q, k )
return 0
","Count of permutations of an Array having each element as a multiple or a factor of its index 
 C ++ Program to implement the above approach ; Function to find the count of desired permutations ; Base case ; If i has not been inserted ; Backtrack ; Insert i ; Recur to find valid permutations ; Remove i ; Return the final count ; Driver Code
",0
768,"in the function maximumEqual that takes a array of  , b array of  , n, create vector  store ( 1e5 )
untill i assign to 0 to n exclusive, store array of b array of i     assign to i + 1
create vector  integer > ans ( 1e5 )
untill i assign to 0 to n exclusive, d assign to abs ( store array of a array of i     - ( i + 1 ) ) )
if store array of a array of i     is less than i + 1 then set d to n - d
increment ans array of d  
declare integer finalans assign to 0
untill i assign to 0 to 1e5 exclusive, finalans assign to max ( finalans, ans array of i   )
print finalans and "" STRNEWLINE ""
declare integer main ( ), integer A assign to  6, 7, 3, 9, 5  ;
create integer B with B assign to  7, 3, 9, 5, 6
size assign to integer with size assign to sizeof ( A) / sizeof ( A array of 0   )
create maximumEqual ( A, B, size )
return 0
","Maximize count of corresponding same elements in given Arrays by Rotation 
 C ++ program of the above approach ; Function that prints maximum equal elements ; Vector to store the index of elements of array b ; Storing the positions of array B ; frequency array to keep count of elements with similar difference in distances ; Iterate through all element in arr1 array of   ; Calculate number of shift required to make current element equal ; If d is less than 0 ; Store the frequency of current diff ; Compute the maximum frequency stored ; Printing the maximum number of equal elements ; Driver Code ; Given two arrays ; Function Call
",1
769,"in the function maximumEqual that takes a array of  , b array of  , n, create vector  store ( 1e5 )
untill i assign to 0 to n exclusive, store array of b array of i     assign to i + 1
create vector  integer > ans ( 1e5 )
untill i assign to 0 to n exclusive, d assign to abs ( store array of a array of i     - ( i + 1 ) ) )
if store array of a array of i     is less than i + 1 then set d to n - d
increment ans array of d  
declare integer finalans assign to 0
untill i assign to 0 to 1e5 exclusive, finalans assign to max ( finalans, ans array of i   )
print finalans and "" STRNEWLINE ""
declare integer main ( ), integer A assign to  6, 7, 3, 9, 5  ;
create integer B with B assign to  7, 3, 9, 5, 6
size assign to integer with size assign to sizeof ( A) / sizeof ( A array of 0   )
create maximumEqual ( A, B, size )
return 0
","Insertion Sort untill Doubly Linked List 
 C ++ implementation untill insertion Sort on a doubly linked list ; Node of a doubly linked list ; function to create and return a new node of a doubly linked list ; allocate node ; put in the data ; function to insert a new node in sorted way in a sorted doubly linked list ; if list is empty ; if the node is to be inserted at the beginning of the doubly linked list ; locate the node after which the new node is to be inserted ; Make the appropriate links ; if the new node is not inserted at the end of the list ; function to sort a doubly linked list using insertion sort ; Initialize ' sorted ' - a sorted doubly linked list ; Traverse the given doubly linked list and insert every node to ' sorted ' ; Store next untill next iteration ; removing all the links so as to create ' current ' as a new node untill insertion ; insert current in ' sorted ' doubly linked list ; Update current ; Update head_ref to point to sorted doubly linked list ; function to print the doubly linked list ; function to insert a node at the beginning of the doubly linked list ; allocate node ; put in the data ; Make next of new node as head and previous as NULL ; change prev of head node to new node ; move the head to point to the new node ; Driver program to test above ; start with the empty doubly linked list ; insert the following data
",0
770,"declare RightRotate with integers a array of  , n, k, k assign to k modulo n
untill i assign to 0 to n exclusive, print a array of n + i - k   and "" ""
else print ( a array of i - k   ) and "" ""
print ""STRNEWLINE ""
declare integer main ( ) and integer array Array with size   assign to  1, 2, 3, 4, 5  ;
create integer N with N assign to sizeof ( Array ) / sizeof ( Array array of 0   )
create integer K with K assign to 2
RightRotate ( Array, N, K )
","Print array after it is right rotated K times 
 C ++ implementation of right rotation of an array K number of times ; Function to rightRotate array ; If rotation is greater than size of array ; Printing rightmost kth elements ; Prints array after ' k ' elements ; Driver code
",1
771,"declare RightRotate with integers a array of  , n, k, k assign to k modulo n
untill i assign to 0 to n exclusive, print a array of n + i - k   and "" ""
else print ( a array of i - k   ) and "" ""
print ""STRNEWLINE ""
declare integer main ( ) and integer array Array with size   assign to  1, 2, 3, 4, 5  ;
create integer N with N assign to sizeof ( Array ) / sizeof ( Array array of 0   )
create integer K with K assign to 2
RightRotate ( Array, N, K )
","Check if N can be obtained from 1 by repetitively multiplying by 10 or 20 
 C ++ program to check if N can be obtained from 1 by repetitive multiplication by 10 or 20 ; Function to check if N can be obtained or not ; Count and remove trailing zeroes ; Check if remaining N is a power of 2 ; To check the condition to print YES or NO ; Driver code
",0
772,"if arr array of   is greater than arr array of i + 1   then reverse ( arr, arr + i + 1 )
reverse arr + i + 1, arr + n
reverse arr and arr + n
printArray is a void function with integer arguments arr and size, print arrays untill i assign to 0 to size exclusive, print arr array of i   and "" ""
declare integer main ( ), integer arr array of   assign to  3, 4, 5, 1, 2  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
restoreSortedArray ( arr, n )
printArray ( arr, n )
return 0
","Sort a Rotated Sorted Array 
 C ++ implementation untill restoring original sort in rotated sorted array ; Function to restore the Original Sort ; In reverse ( ) , the first parameter is iterator to beginning element and second parameter is iterator to last element plus one . ; Function to print the Array ; Driver function
",1
773,"if arr array of   is greater than arr array of i + 1   then reverse ( arr, arr + i + 1 )
reverse arr + i + 1, arr + n
reverse arr and arr + n
printArray is a void function with integer arguments arr and size, print arrays untill i assign to 0 to size exclusive, print arr array of i   and "" ""
declare integer main ( ), integer arr array of   assign to  3, 4, 5, 1, 2  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
restoreSortedArray ( arr, n )
printArray ( arr, n )
return 0
","Count set bits in an integer 
 C ++ program to Count set bits in an integer ; Function to get no of set bits in binary representation of positive integer n ; Program to test function countSetBits
",0
774,"return -1 if low is greater than high
if low is high, return low
mid assign to integer with mid assign to low + ( high - low ) / 2
if arr array of mid  > arr array of mid + 1  return mid + 1
if arr array of mid - 1   > arr array of mid   return mid
if arr array of low  > arr array of mid , return findStartIndexOfArray ( arr, low, mid - 1)
else return findStartIndexOfArray ( arr, mid + 1, high )
if arr array of   is a void, return void
create integer start with start assign to findStartIndexOfArray ( arr, 0, n - 1 )
reverse arr and arr + start
reverse arr + start, arr + n
reverse arr and arr + n
printArray is a void function with integer arguments arr array of   and size, print arrays untill i assign to 0 to size exclusive, print arr array of i   and "" ""
declare integer main ( ), integer arr array of   assign to  1, 2, 3, 4, 5  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
restoreSortedArray ( arr, n )
printArray ( arr, n )
return 0
","Sort a Rotated Sorted Array 
 C ++ implementation untill restoring original sort in rotated sorted array using binary search ; Function to find start index of array ; Function to restore the Original Sort ; array is already sorted ; In reverse ( ) , the first parameter is iterator to beginning element and second parameter is iterator to last element plus one . ; Function to print the Array ; Driver function
",1
775,"return -1 if low is greater than high
if low is high, return low
mid assign to integer with mid assign to low + ( high - low ) / 2
if arr array of mid  > arr array of mid + 1  return mid + 1
if arr array of mid - 1   > arr array of mid   return mid
if arr array of low  > arr array of mid , return findStartIndexOfArray ( arr, low, mid - 1)
else return findStartIndexOfArray ( arr, mid + 1, high )
if arr array of   is a void, return void
create integer start with start assign to findStartIndexOfArray ( arr, 0, n - 1 )
reverse arr and arr + start
reverse arr + start, arr + n
reverse arr and arr + n
printArray is a void function with integer arguments arr array of   and size, print arrays untill i assign to 0 to size exclusive, print arr array of i   and "" ""
declare integer main ( ), integer arr array of   assign to  1, 2, 3, 4, 5  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
restoreSortedArray ( arr, n )
printArray ( arr, n )
return 0
","Rearrange given array such that no array element is same as its index 
 C ++ program untill the above approach ; Function to rearrange the array a array of   such that none of the array elements is same as its index ; Sort the array ; Traverse the indices array of 0 , N - 2   of the given array ; Check if the current element is equal to its index ; If found to be true , swap current element with the next element ; Check if the last element is same as its index ; If found to be true , swap current element with the previous element ; Print the modified array ; Driver Code ; Function Call
",0
776,"declare leftrotate with string & s, integer d as arguments, returning s. begin ( ), s. begin ( ) + d )
reverse s. begin ( ) + d, s. end ( ) )
reverse s. begin ( ), s. end ( ) )
void function rightrotate ( string & s, integer d ) and leftrotate ( s, length of s - d )
declare integer main ( ), string str1 assign to GeeksuntillGeeks
declare leftrotate with str1, 2 as arguments, returning a leftrotate
print str1 print newline
create string str2 with str2 assign to GeeksuntillGeeks
rightrotate assign to str2, 2
print str2 print newline
return 0
","Left Rotation and Right Rotation of a String 
 C program untill Left Rotation and Right Rotation of a String ; In - place rotates s towards left by d ; In - place rotates s towards right by d ; Driver code
",1
777,"declare leftrotate with string & s, integer d as arguments, returning s. begin ( ), s. begin ( ) + d )
reverse s. begin ( ) + d, s. end ( ) )
reverse s. begin ( ), s. end ( ) )
void function rightrotate ( string & s, integer d ) and leftrotate ( s, length of s - d )
declare integer main ( ), string str1 assign to GeeksuntillGeeks
declare leftrotate with str1, 2 as arguments, returning a leftrotate
print str1 print newline
create string str2 with str2 assign to GeeksuntillGeeks
rightrotate assign to str2, 2
print str2 print newline
return 0
","Queries untill the product of first N factorials 
 C ++ implementation of the approach ; Declare result array globally ; Function to precompute the product of factorials upto MAX ; Initialize base condition if n assign to 0 then factorial of 0 is equal to 1 and answer untill n assign to 0 is 1 ; Iterate loop from 1 to MAX ; factorial ( i ) assign to factorial ( i - 1 ) * i ; Result untill current n is equal to result array of i - 1   multiplied by the factorial of i ; Function to peruntillm the queries ; Precomputing the result till MAX ; Peruntillm queries ; Driver code
",0
778,"create struct Node  integer data
Node assign to struct * next
create struct Node * prev
print a newline
if struct Node * * start, integer value, if ( * start is NULL ), struct Node * new_node assign to new Node
new_node -> data assign to value
set new_node -> next to new_node -> prev to new_node
set start to new_node
return
Node * last assign to ( * start ) -> prev
create struct Node * new_node assign to new Node
new_node -> data assign to value
set new_node -> next to * start
set prev to new_node
new_node -> prev assign to last
last -> next assign to new_node
create void displayList ( struct Node * start ) struct Node * temp assign to start
untill temp -> next is not start, printf ( "" % d "", temp -> data )
set temp to temp -> next
printf ( "" % d "", temp -> data )
create int searchList ( struct Node * start, int search ) struct Node * temp assign to start
declare integers count assign to 0, flag assign to 0 and value
if temp is NULL, return -1
else  untill temp -> next is not start, increment count
if temp -> data is search, flag assign to 1
decrement count
break loop
set temp to temp -> next
if temp -> data is search, increment count
set flag to 1
if flag is 1 print "" STRNEWLINE "", search, found at location "", count
else print "" STRNEWLINE "", search, not found "" and a new line
declare integer main ( ) and struct Node * start assign to NULL
insertNode assign to ( & start, 4 )
insertNode assign to ( & start, 5 )
insertNode ( & start, 7 )
insertNode ( & start, 8 )
insertNode ( & start, 6 )
printf is a new line with name Created circular double linked list is : ""
displayList is a new function
call searchList with arguments start, 5
return 0
","Search an Element in Doubly Circular Linked List 
 C ++ program to illustrate inserting a Node in a Cicular Doubly Linked list in begging , end and middle ; Structure of a Node ; Function to insert a node at the end ; If the list is empty , create a single node circular and doubly list ; Find last node ; Create Node dynamically ; Start is going to be next of new_node ; Make new node previous of start ; Make last preivous of new node ; Make new node next of old last ; Function to display the circular doubly linked list ; Function to search the particular element from the list ; Declare the temp variable ; Declare other control variable untill the searching ; If start is NULL return - 1 ; Move the temp pointer until , temp -> next doesn 't move  start address (Circular Fashion) ; Increment count untill location ; If it is found raise the flag and break the loop ; Increment temp pointer ; Check whether last element in the list content the value if contain , raise a flag and increment count ; If flag is true , then element found , else not ; Driver code ; Start with the empty list ; Insert 4. So linked list becomes 4 -> NULL ; Insert 5. So linked list becomes 4 -> 5 ; Insert 7. So linked list becomes 4 -> 5 -> 7 ; Insert 8. So linked list becomes 4 -> 5 -> 7 -> 8 ; Insert 6. So linked list becomes 4 -> 5 -> 7 -> 8 -> 6
",1
779,"create struct Node  integer data
Node assign to struct * next
create struct Node * prev
print a newline
if struct Node * * start, integer value, if ( * start is NULL ), struct Node * new_node assign to new Node
new_node -> data assign to value
set new_node -> next to new_node -> prev to new_node
set start to new_node
return
Node * last assign to ( * start ) -> prev
create struct Node * new_node assign to new Node
new_node -> data assign to value
set new_node -> next to * start
set prev to new_node
new_node -> prev assign to last
last -> next assign to new_node
create void displayList ( struct Node * start ) struct Node * temp assign to start
untill temp -> next is not start, printf ( "" % d "", temp -> data )
set temp to temp -> next
printf ( "" % d "", temp -> data )
create int searchList ( struct Node * start, int search ) struct Node * temp assign to start
declare integers count assign to 0, flag assign to 0 and value
if temp is NULL, return -1
else  untill temp -> next is not start, increment count
if temp -> data is search, flag assign to 1
decrement count
break loop
set temp to temp -> next
if temp -> data is search, increment count
set flag to 1
if flag is 1 print "" STRNEWLINE "", search, found at location "", count
else print "" STRNEWLINE "", search, not found "" and a new line
declare integer main ( ) and struct Node * start assign to NULL
insertNode assign to ( & start, 4 )
insertNode assign to ( & start, 5 )
insertNode ( & start, 7 )
insertNode ( & start, 8 )
insertNode ( & start, 6 )
printf is a new line with name Created circular double linked list is : ""
displayList is a new function
call searchList with arguments start, 5
return 0
","Program to print the series 1 , 3 , 4 , 8 , 15 , 27 , 50 Ã¢ â‚¬Â¦ till N terms 
 C ++ implementation to print the N terms of the series whose three terms are given ; Function to print the series ; Generate the ith term and print it ; Driver Code ; Function Call
",0
780,"create struct Node  integer data
Node * next, * prev
print a newline
Node * getNode ( integer data)  Node * newNode assign to ( Node * ) malloc ( sizeof ( Node ) )
set newNode -> data to data
return newNode
if node * * head, Node * new_node, if node * head is NULL, set new_node -> next to new_node -> prev to new_node
set head to new_node
return
Node * last assign to ( * head ) -> prev
new_node -> next assign to * head
set prev to new_node
new_node -> prev assign to last
last -> next assign to new_node
if node * reverse ( Node * head) if not head, return NULL
Node * new_head assign to NULL
assign head -> prev to Node * last
assign last, * prev to Node * curr
untill curr -> prev is not last, set prev to curr -> prev
insertEnd ( & new_head, curr )
set curr to prev
insertEnd ( & new_head, curr )
return new_head
return void display ( Node * head ) if not head
assign head to Node * temp
print Forward direction : ""
untill temp -> next is not head print temp -> data print "" ""
set temp to temp -> next
print temp -> data
assign head -> prev to Node * last
temp assign to last
print "" Backward direction : "" untill temp -> prev is not last, print temp -> data
temp assign to temp -> prev
print temp -> data
declare integer main ( ) and Node * head assign to NULL
insertEnd ( & head, getNode ( 1 ) ) )
insertEnd ( & head, getNode ( 2 ) ) )
insertEnd ( & head, getNode ( 3 ) ) )
insertEnd ( & head, getNode ( 4 ) ) )
insertEnd ( & head, getNode ( 5 ) ) )
print Current list : STRNEWLINE
display ( head )
set head to reverse ( head )
print ""Reversed list : "" display ( head )
return 0
","Reverse a doubly circular linked list 
 C ++ implementation to revesre a doubly circular linked list ; structure of a node of linked list ; function to create and return a new node ; Function to insert at the end ; If the list is empty , create a single node circular and doubly list ; Find last node ; Start is going to be next of new_node ; Make new node previous of start ; Make last preivous of new node ; Make new node next of old last ; Uitlity function to revesre a doubly circular linked list ; Initialize a new head pointer ; get pointer to the the last node ; set ' curr ' to last node ; traverse list in backward direction ; insert ' curr ' at the end of the list starting with the ' new _ head ' pointer ; head pointer of the reversed list ; function to display a doubly circular list in untillward and backward direction ; Driver program to test above
",1
781,"create struct Node  integer data
Node * next, * prev
print a newline
Node * getNode ( integer data)  Node * newNode assign to ( Node * ) malloc ( sizeof ( Node ) )
set newNode -> data to data
return newNode
if node * * head, Node * new_node, if node * head is NULL, set new_node -> next to new_node -> prev to new_node
set head to new_node
return
Node * last assign to ( * head ) -> prev
new_node -> next assign to * head
set prev to new_node
new_node -> prev assign to last
last -> next assign to new_node
if node * reverse ( Node * head) if not head, return NULL
Node * new_head assign to NULL
assign head -> prev to Node * last
assign last, * prev to Node * curr
untill curr -> prev is not last, set prev to curr -> prev
insertEnd ( & new_head, curr )
set curr to prev
insertEnd ( & new_head, curr )
return new_head
return void display ( Node * head ) if not head
assign head to Node * temp
print Forward direction : ""
untill temp -> next is not head print temp -> data print "" ""
set temp to temp -> next
print temp -> data
assign head -> prev to Node * last
temp assign to last
print "" Backward direction : "" untill temp -> prev is not last, print temp -> data
temp assign to temp -> prev
print temp -> data
declare integer main ( ) and Node * head assign to NULL
insertEnd ( & head, getNode ( 1 ) ) )
insertEnd ( & head, getNode ( 2 ) ) )
insertEnd ( & head, getNode ( 3 ) ) )
insertEnd ( & head, getNode ( 4 ) ) )
insertEnd ( & head, getNode ( 5 ) ) )
print Current list : STRNEWLINE
display ( head )
set head to reverse ( head )
print ""Reversed list : "" display ( head )
return 0
","Check if given number is Emirp Number or not 
 C ++ program to check if given number is Emirp or not . ; Returns true if n is prime . Else false . ; Corner case ; Check from 2 to n - 1 ; Function will check whether number is Emirp or not ; Check if n is prime ; Find reverse of n ; If both Original and Reverse are Prime , then it is an Emirp number ; Driver code ; Input number
",0
782,"depth assign to integer array of size MAXN
parent assign to integer array of size MAXN
create vector  integer > adj array of MAXN 
declare addEdge with integers u, v as arguments, returning adj array of u   and push_back ( v ) as arguments
push_back ( u ) is adj array of v  
declare dfs with integer cur, prev as arguments, assign prev to parent array of cur 
depth array of cur  assign to depth array of prev  + 1
untill i assign to 0 to size of adj array of cur . size ( ), if adj array of cur  array of i   is not prev, then dfs ( adj array of cur  array of i  , cur )
void preprocess ( ), depth array of 0   assign to -1
dfs assign to 1, 0
return u if u is v
if depth array of u   is greater than depth array of v  , swap u, v )
v assign to parent array of v  
return LCANaive ( u, v )
declare integer main ( integer argc, char const * argv array of   ) and addEdge ( 1, 2 )
addEdge assign to 1, 3
addEdge assign to 1, 4
addEdge assign to 2, 5
addEdge assign to 2, 6
addEdge assign to 3, 7
addEdge assign to 4, 8
addEdge assign to 4, 9
addEdge ( 9, 10 )
addEdge ( 9, 11 )
addEdge ( 7, 12 )
addEdge ( 7, 13 )
preprocess ( )
print LCA ( 11,8 ) : "", LCANaive ( 11, 8 ) )
print LCA ( 3,13 ) : "", LCANaive ( 3, 13 ) )
return 0
","Sqrt ( or Square Root ) Decomposition 
 Set 2 ( LCA of Tree in O ( sqrt ( height ) ) time ) 
 Naive C ++ implementation to find LCA in a tree ; stores depth untill each node ; stores first parent untill each node ; marking parent untill each node ; marking depth untill each node ; propogating marking down the tree ; a dummy node ; precalclating 1 ) depth . 2 ) parent . untill each node ; Time Complexity : O ( Height of tree ) recursively jumps one node above till both the nodes become equal ; Driver function to call the above functions ; adding edges to the tree
",1
783,"depth assign to integer array of size MAXN
parent assign to integer array of size MAXN
create vector  integer > adj array of MAXN 
declare addEdge with integers u, v as arguments, returning adj array of u   and push_back ( v ) as arguments
push_back ( u ) is adj array of v  
declare dfs with integer cur, prev as arguments, assign prev to parent array of cur 
depth array of cur  assign to depth array of prev  + 1
untill i assign to 0 to size of adj array of cur . size ( ), if adj array of cur  array of i   is not prev, then dfs ( adj array of cur  array of i  , cur )
void preprocess ( ), depth array of 0   assign to -1
dfs assign to 1, 0
return u if u is v
if depth array of u   is greater than depth array of v  , swap u, v )
v assign to parent array of v  
return LCANaive ( u, v )
declare integer main ( integer argc, char const * argv array of   ) and addEdge ( 1, 2 )
addEdge assign to 1, 3
addEdge assign to 1, 4
addEdge assign to 2, 5
addEdge assign to 2, 6
addEdge assign to 3, 7
addEdge assign to 4, 8
addEdge assign to 4, 9
addEdge ( 9, 10 )
addEdge ( 9, 11 )
addEdge ( 7, 12 )
addEdge ( 7, 13 )
preprocess ( )
print LCA ( 11,8 ) : "", LCANaive ( 11, 8 ) )
print LCA ( 3,13 ) : "", LCANaive ( 3, 13 ) )
return 0
","Reverse vowels in a given string 
 C ++ program to reverse order of vowels ; utility function to check untill vowel ; Function to reverse order of vowels ; Storing the vowels separately ; Placing the vowels in the reverse order in the string ; Driver function
",0
784,"block_sz assign to integer
depth assign to array of integers of length MAXN
parent assign to integer array of size MAXN
create integer jump_parent with MAXN element
adj assign to vector of integers of size MAXN
addEdge is a void function with integer arguments u and v that push v into adjarray ofu 
push u into adjarray ofv 
if u is v, return u from function LCANaive with integer arguments u and v
if deptharray ofu  is greater than deptharray ofv , swap u and v
set v to parentarray ofv 
return LCANaive(u,v)
void function dfs with integer arguments cur and prev, with deptharray ofcur  assign to deptharray ofprev  + 1
set parentarray ofcur  to prev
if deptharray ofcur  modulo block_sz is 0, jump_parentarray ofcur  assign to parentarray ofcur 
else jump_parentarray ofcur  assign to jump_parentarray ofprev 
untill i assign to 0 to length of adjarray ofcur  exclusive, if adjarray ofcur array ofi  is not prev, call dfs with arguments adjarray ofcur array ofi , cur
if deptharray ofu  is greater than deptharray ofv , swap u and v
set v to jump_parentarray ofv 
return LCANaive(u,v)
void function preprocess with integer argument height and block_sz assign to square root of height
deptharray of0  assign to -1
call dfs with arguments 1, 0
declare main with integers argc, char constant *argvarray of  as arguments, addingEdge with 1, 2 as arguments
addEdge assign to 1
addEdge assign to 1 and 4
addEdge assign to 2dge with 5 elements
addEdge assign to 2dge with 6 elements
addEdge assign to 3dge with 7 elements
addEdge assign to 4, 8
addEdge assign to 4, 9
addEdge assign to 9 and 10
addEdge assign to 9 and 11
addEdge(7, 12)
addEdge(7, 13)
create integer height with height assign to 4
preprocessheight
print LCA ( 11,8 ) : "" print LCASQRT(11, 8 )
print LCA ( 3,13 ) : "", LCASQRT(3, 13) )
return 0
","Sqrt ( or Square Root ) Decomposition 
 Set 2 ( LCA of Tree in O ( sqrt ( height ) ) time ) 
 C ++ program to find LCA using Sqrt decomposition ; block size assign to sqrt ( height ) ; stores depth untill each node ; stores first parent untill each node ; stores first ancestor in previous block ; precalculating the required parameters associated with every node ; marking depth of cur node ; marking parent of cur node ; making jump_parent of cur node ; if it is first node of the block then its jump_parent is its cur parent ; if it is not the first node of this block then its jump_parent is jump_parent of its parent ; propogating the marking down the subtree ; using sqrt decomposition trick ; maintaining depth array of v   > depth array of u   ; climb to its jump parent ; u and v have same jump_parent ; precalclating 1 ) depth . 2 ) parent . 3 ) jump_parent untill each node ; Driver function to call the above functions ; adding edges to the tree ; here we are directly taking height assign to 4 according to the given tree but we can pre - calculate height assign to max depth in one more dfs
",1
785,"block_sz assign to integer
depth assign to array of integers of length MAXN
parent assign to integer array of size MAXN
create integer jump_parent with MAXN element
adj assign to vector of integers of size MAXN
addEdge is a void function with integer arguments u and v that push v into adjarray ofu 
push u into adjarray ofv 
if u is v, return u from function LCANaive with integer arguments u and v
if deptharray ofu  is greater than deptharray ofv , swap u and v
set v to parentarray ofv 
return LCANaive(u,v)
void function dfs with integer arguments cur and prev, with deptharray ofcur  assign to deptharray ofprev  + 1
set parentarray ofcur  to prev
if deptharray ofcur  modulo block_sz is 0, jump_parentarray ofcur  assign to parentarray ofcur 
else jump_parentarray ofcur  assign to jump_parentarray ofprev 
untill i assign to 0 to length of adjarray ofcur  exclusive, if adjarray ofcur array ofi  is not prev, call dfs with arguments adjarray ofcur array ofi , cur
if deptharray ofu  is greater than deptharray ofv , swap u and v
set v to jump_parentarray ofv 
return LCANaive(u,v)
void function preprocess with integer argument height and block_sz assign to square root of height
deptharray of0  assign to -1
call dfs with arguments 1, 0
declare main with integers argc, char constant *argvarray of  as arguments, addingEdge with 1, 2 as arguments
addEdge assign to 1
addEdge assign to 1 and 4
addEdge assign to 2dge with 5 elements
addEdge assign to 2dge with 6 elements
addEdge assign to 3dge with 7 elements
addEdge assign to 4, 8
addEdge assign to 4, 9
addEdge assign to 9 and 10
addEdge assign to 9 and 11
addEdge(7, 12)
addEdge(7, 13)
create integer height with height assign to 4
preprocessheight
print LCA ( 11,8 ) : "" print LCASQRT(11, 8 )
print LCA ( 3,13 ) : "", LCASQRT(3, 13) )
return 0
","Number of Subsequences with Even and Odd Sum 
 C ++ implementation ; Returns the count of odd and even subsequences ; Variables to store the count of even subsequences and odd subsequences ; Initialising count_even and count_odd to 0 since as there is no subsequence beuntille the iteration with even or odd count . ; Find sum of all subsequences with even count and odd count and storing them as we iterate . ; if the number is even ; if the number is odd ; Driver code ; Calling the function
",0
786,"declare main with integer variable N assign to 3
print pow(2, N + 1) - 2
return 0
","Expected Number of Trials to get N Consecutive Heads 
 C ++ implementation of the above approach ; Driver Code ; Formula untill number of trails untill N consecutive heads
",1
787,"declare main with integer variable N assign to 3
print pow(2, N + 1) - 2
return 0
","Find the minimum cost to reach destination using a train 
 A Dynamic Programming based solution to find min cost to reach station N - 1 from station 0. ; This function returns the smallest possible cost to reach station N - 1 from station 0. ; dist array of i   stores minimum cost to reach station i from station 0. ; Go through every station and check if using it as an intermediate station gives better path ; Driver program to test above function
",0
788,"declare countOfNum with ll ints n, a, b, cnt_of_a, cnt_of_ab, sum as arguments, returning ll int
set cnt_of_a to n / a
set cnt_of_b to n / b
set sum to cnt_of_b + cnt_of_a
cnt_of_ab assign to n / ( a * b )
sum assign to sum - cnt_of_ab
return sum
sumOfNum assign to ll int n, a assign to ll int b assign to ll int i
sum assign to 0
set  ll int > ans
untill i assign to a to n inclusive, insert i into ans
untill i assign to b to n inclusive, insert i into ans
untill auto it assign to ans. begin ( ) ; itnot equal to ans. end ( ) ; it ++ ), sum assign to sum + it
return sum
declare integer main ( ) and ll integer N assign to 88
declare integer A assign to 11
declare integer B assign to 8
declare integer count assign to countOfNum ( N, A, B )
declare integer sumofnum assign to sumOfNum ( N, A, B )
print sumofnum modulo count
return 0
","Find and Count total factors of co 
 C ++ implementation of the above approach ; Function to return the count of numbers which are divisible by both A and B in the range array of 1 , N   in constant time ; Compute the count of numbers divisible by A in the range array of 1 , N   ; Compute the count of numbers divisible by B in the range array of 1 , N   ; Adding the counts which are divisible by A and B ; The above value might contain repeated values which are divisible by both A and B . Thereuntille , the count of numbers which are divisible by both A and B are found ; The count computed above is subtracted to compute the final count ; Function to return the sum of numbers which are divisible by both A and B in the range array of 1 , N   ; Set to store the numbers so that the numbers are not repeated ; For loop to find the numbers which are divisible by A and insert them into the set ; For loop to find the numbers which are divisible by A and insert them into the set ; For loop to iterate through the set and find the sum ; Driver code
",1
789,"declare countOfNum with ll ints n, a, b, cnt_of_a, cnt_of_ab, sum as arguments, returning ll int
set cnt_of_a to n / a
set cnt_of_b to n / b
set sum to cnt_of_b + cnt_of_a
cnt_of_ab assign to n / ( a * b )
sum assign to sum - cnt_of_ab
return sum
sumOfNum assign to ll int n, a assign to ll int b assign to ll int i
sum assign to 0
set  ll int > ans
untill i assign to a to n inclusive, insert i into ans
untill i assign to b to n inclusive, insert i into ans
untill auto it assign to ans. begin ( ) ; itnot equal to ans. end ( ) ; it ++ ), sum assign to sum + it
return sum
declare integer main ( ) and ll integer N assign to 88
declare integer A assign to 11
declare integer B assign to 8
declare integer count assign to countOfNum ( N, A, B )
declare integer sumofnum assign to sumOfNum ( N, A, B )
print sumofnum modulo count
return 0
","Count of substrings from given Ternary strings containing characters at least once 
 C ++ program untill above approach ; Function to count the number of substrings consists of 0 , 1 , and 2 ; Initialize frequency array of size 3 ; Stores the resultant count ; Traversing string str ; Update frequency array ; If all the characters are present counting number of substrings possible ; Update number of substrings ; Return the number of substrings ; Driver Code
",0
790,"declare double get ( double L, double R )  double x assign to 1.0 / L
y assign to double with y assign to 1.0 / ( R + 1.0 )
return ( x - y )
declare integer main ( ), L assign to 6 and R assign to 12
ans assign to get ( L, R )
print fixed print setprecision ( 2 ) print ans
return 0
","Find Range Value of the Expression 
 C ++ implementation of the approach ; Function to return the value of the given expression ; Value of the first term ; Value of the last term ; Driver code ; Get the result
",1
791,"declare double get ( double L, double R )  double x assign to 1.0 / L
y assign to double with y assign to 1.0 / ( R + 1.0 )
return ( x - y )
declare integer main ( ), L assign to 6 and R assign to 12
ans assign to get ( L, R )
print fixed print setprecision ( 2 ) print ans
return 0
","Find most significant set bit of a number 
 CPP program to find MSB number untill given n . ; To find the position of the most significant set bit ; To return the the value of the number with set bit at k - th position ; Driver code
",0
792,"MAX assign to 100000
create vector v with int > v
declare consecutiveOnes with integer x as argument, set p to 0
untill x is greater than 0, return true if x modulo 2 is 1 and p is 1
set p to x modulo 2
divide x by 2
return false
void function preCompute ( ) if i assign to 0, i assign to MAX, if consecutiveOnes ( i ) ), push_back ( i ) v
create integer nextValid with integer n, it assign to upper_bound ( v. begin ( ), v. end ( ), n ) - v. begin ( ) )
create integer val with val assign to v array of it  
return val
print peruntillmQueries ( int queries array of  , int q ) and untill i assign to 0 to q exclusive, print nextValid ( queries array of i   ) and "" STRNEWLINE ""
declare integer main ( ), integer queries array of   assign to  4, 6
q assign to integer with q assign to sizeof ( queries ) / sizeof ( int )
call preCompute ( )
peruntillmQueries ( queries,q)
return 0
","Find next greater element with no consecutive 1 in it 's binary representation 
 C ++ implementation of the approach ; To store the pre - computed integers ; Function that returns true if the binary representation of x contains consecutive 1 s ; To store the previous bit ; Check whether the previous bit and the current bit are both 1 ; Update previous bit ; Go to the next bit ; Function to pre - compute the valid numbers from 0 to MAX ; Store all the numbers which do not have consecutive 1 s ; Function to return the minimum number greater than n which does not contain consecutive 1 s ; Search untill the next greater element with no consecutive 1 s ; Function to peruntillm the queries ; Driver code ; Pre - compute the numbers ; Peruntillm the queries
",1
793,"MAX assign to 100000
create vector v with int > v
declare consecutiveOnes with integer x as argument, set p to 0
untill x is greater than 0, return true if x modulo 2 is 1 and p is 1
set p to x modulo 2
divide x by 2
return false
void function preCompute ( ) if i assign to 0, i assign to MAX, if consecutiveOnes ( i ) ), push_back ( i ) v
create integer nextValid with integer n, it assign to upper_bound ( v. begin ( ), v. end ( ), n ) - v. begin ( ) )
create integer val with val assign to v array of it  
return val
print peruntillmQueries ( int queries array of  , int q ) and untill i assign to 0 to q exclusive, print nextValid ( queries array of i   ) and "" STRNEWLINE ""
declare integer main ( ), integer queries array of   assign to  4, 6
q assign to integer with q assign to sizeof ( queries ) / sizeof ( int )
call preCompute ( )
peruntillmQueries ( queries,q)
return 0
","Sort Matrix in alternating ascending and descending order rowwise 
 C ++ implementation to print row of matrix in ascending or descending order alternatively ; Iterate matrix rowwise ; Sort even rows in ascending order ; compare adjacent elements ; swap adjacent element ; Sort even rows in descending order ; compare adjacent elements ; swap adjacent element ; Printing the final Output ; Driver code
",0
794,"create integer changeToOnes (string str), l, ctr with ctr assign to 0
l assign to length of str
untill i assign to l - 1 to 0 inclusive, increment ctr by 1
else break
return l - ctr
removeZeroesFromFront is a new string variable with name str
create integer i with i assign to 0
untill i  str. length ( ) and str array of i   assign to '0' increment i
if i is str. length ( ), s assign to ""0""
else s assign to substr ( i, str. length ( ) - i )
return s
declare integer main ( ), string str assign to ""10010111""
set str to removeZeroesFromFront ( str )
print changeToOnes ( str)
return 0
","Minimum given operations required to convert a given binary string to all 1 's 
 C ++ implementation of the approach ; Function to return the number of operations required ; ctr will store the number of consecutive ones at the end of the given binary string ; Loop to find number of 1 s at the end of the string ; If the current character is 1 ; If we encounter the first 0 from the LSB position then we 'll break the loop ; Number of operations required is ( l - ctr ) ; Function to remove leading zeroes from the string ; Loop until s array of i   becomes not equal to 1 ; If we reach the end of the string , it means that string contains only 0 's ; Return the string without leading zeros ; Driver code ; Removing the leading zeroes
",1
795,"create integer changeToOnes (string str), l, ctr with ctr assign to 0
l assign to length of str
untill i assign to l - 1 to 0 inclusive, increment ctr by 1
else break
return l - ctr
removeZeroesFromFront is a new string variable with name str
create integer i with i assign to 0
untill i  str. length ( ) and str array of i   assign to '0' increment i
if i is str. length ( ), s assign to ""0""
else s assign to substr ( i, str. length ( ) - i )
return s
declare integer main ( ), string str assign to ""10010111""
set str to removeZeroesFromFront ( str )
print changeToOnes ( str)
return 0
","Check if it is possible to rearrange a binary string with alternate 0 s and 1 s 
 CPP program to check if we can rearrange a string such that it has alternate 0 s and 1 s . ; function to check the binary string ; length of string ; count zero 's ; count one 's ; if length is even ; if length is odd ; Driver code
",0
796,"MinDeletion assign to integer with MinDeletion assign to a array of  , n assign to integer, desdered_map assign to integer, integer assign to map assign to integer assign to int
untill i assign to 0 to n exclusive, map array of a array of i       ++
ans assign to integer with ans assign to 0
untill i : map, x assign to i. first
create integer frequency with frequency assign to i. second
if x assign to frequency, increment ans by frequency - x
else ans assign to ans + frequency
return ans
declare integer main ( ) and integer array a with size   assign to  2, 3, 2, 3, 4, 4, 4, 4, 5
create integer n with n assign to sizeof ( a ) / sizeof ( a array of 0   )
print MinDeletion ( a, n )
return 0
","Minimum deletions required such that any number X will occur exactly X times 
 C ++ implementation of the approach ; Function to return the minimum deletions required ; To store the frequency of the array elements ; Store frequency of each element ; To store the minimum deletions required ; Value ; It 's frequency ; If number less than or equal to it 's frequency ; Delete extra occurrences ; Delete every occurrence of x ; Driver code
",1
797,"MinDeletion assign to integer with MinDeletion assign to a array of  , n assign to integer, desdered_map assign to integer, integer assign to map assign to integer assign to int
untill i assign to 0 to n exclusive, map array of a array of i       ++
ans assign to integer with ans assign to 0
untill i : map, x assign to i. first
create integer frequency with frequency assign to i. second
if x assign to frequency, increment ans by frequency - x
else ans assign to ans + frequency
return ans
declare integer main ( ) and integer array a with size   assign to  2, 3, 2, 3, 4, 4, 4, 4, 5
create integer n with n assign to sizeof ( a ) / sizeof ( a array of 0   )
print MinDeletion ( a, n )
return 0
","Sort an array according to count of set bits 
 C ++ program to sort an array according to count of set bits using std :: sort ( ) ; a utility function that returns total set bits count in an integer ; Function to sort according to bit count This function assumes that there are 32 bits in an integer . ; Traverse through all bit counts ( Note that we sort array in decreasing order ) ; Utility function to print an array ; Driver Code
",0
798,"declare integer variable maxCountAB with string s array of  , integer n, integers A assign to 0, B assign to 0, BA assign to 0 and ans assign to 0
untill i assign to 0 to n exclusive, set string S to s array of i  
create integer L with L assign to size of S
untill j assign to 0 to L - 1 exclusive, if S. at (j ) assign to'A'and S. at ( j + 1 ) assign to'B ', increment ans
if S. at ( 0 ) assign to'B'and S. at ( L - 1 ) assign to'A ', increment BA
else if S. at ( 0 ) is'B', increment B
else if S. at ( L - 1) is'A', increment A
if BA is 0, increment ans by min ( B, A )
else if A + B is 0, increment ans by BA - 1
else ans assign to ans + BA + min ( B, A )
return ans
declare integer main ( ), string s array of   assign to ABCA "", "" BOOK "", "" BAND ""
create integer n with n assign to sizeof ( s ) / sizeof ( s array of 0   )
print maxCountAB ( s, n )
return 0
","Concatenate strings in any order to get Maximum Number of "" AB "" 
 C ++ implementation of above approach ; Function to find maximum number of ABs ; variable A , B , AB untill count strings that end with ' A ' but not end with ' B ' , ' B ' but does not end with ' A ' and ' B ' and ends with ' A ' respectively . ; ' AB ' is already present in string beuntille concatenate them ; count of strings that begins with ' B ' and ends with 'A ; count of strings that begins with ' B ' but does not end with ' A ' ; count of strings that ends with ' A ' but not end with ' B ' ; updating the value of ans and add extra count of ' AB ' ; Driver Code
",1
799,"declare integer variable maxCountAB with string s array of  , integer n, integers A assign to 0, B assign to 0, BA assign to 0 and ans assign to 0
untill i assign to 0 to n exclusive, set string S to s array of i  
create integer L with L assign to size of S
untill j assign to 0 to L - 1 exclusive, if S. at (j ) assign to'A'and S. at ( j + 1 ) assign to'B ', increment ans
if S. at ( 0 ) assign to'B'and S. at ( L - 1 ) assign to'A ', increment BA
else if S. at ( 0 ) is'B', increment B
else if S. at ( L - 1) is'A', increment A
if BA is 0, increment ans by min ( B, A )
else if A + B is 0, increment ans by BA - 1
else ans assign to ans + BA + min ( B, A )
return ans
declare integer main ( ), string s array of   assign to ABCA "", "" BOOK "", "" BAND ""
create integer n with n assign to sizeof ( s ) / sizeof ( s array of 0   )
print maxCountAB ( s, n )
return 0
","Print Nth Stepping or Autobiographical number 
 C ++ implementation to find NaTMth stepping natural Number ; Function to find the Nth stepping natural number ; Declare the queue ; Enqueue 1 , 2 , ... , 9 in this order ; Peruntillm K operation on queue ; Get the ith Stepping number ; Peruntillm Dequeue from the Queue ; If x mod 10 is not equal to 0 ; then Enqueue 10 x + ( x mod 10 ) - 1 ; Enqueue 10 x + ( x mod 10 ) ; If x mod 10 is not equal to 9 ; then Enqueue 10 x + ( x mod 10 ) + 1 ; Return the dequeued number of the K - th operation as the Nth stepping number ; Driver Code ; initialise K
",0
800,"declare MinOperations with integers n, x, arr, total assign to 0
untill i assign to 0 to n exclusive, change the value of int to difference assign to arr array of i   - x
set total to total + difference
arr array of i   assign to x
untill i assign to 1 to n exclusive, set LeftNeigbouringSum to arr array of i   + arr array of i - 1  
if LeftNeigbouringSum is greater than x, set current_diff to LeftNeigbouringSum - x
arr array of i   assign to max ( 0, arr array of i   - current_diff )
set total to total + current_diff
return total
declare integer main ( ) and integer X assign to 1
create integer array arr with arr assign to  1, 6, 1, 2, 0, 4
N assign to sizeof ( arr ) / sizeof ( int )
print MinOperations ( N, X, arr )
return 0
","Minimum operations to make sum of neighbouring elements <assign to X 
 C ++ implementation of the approach ; Function to return the minimum number of operations required ; To store total operations required ; First make all elements equal to x which are currenctly greater ; Left scan the array ; Update the current element such that neighbouring sum is < x ; Driver code
",1
801,"declare MinOperations with integers n, x, arr, total assign to 0
untill i assign to 0 to n exclusive, change the value of int to difference assign to arr array of i   - x
set total to total + difference
arr array of i   assign to x
untill i assign to 1 to n exclusive, set LeftNeigbouringSum to arr array of i   + arr array of i - 1  
if LeftNeigbouringSum is greater than x, set current_diff to LeftNeigbouringSum - x
arr array of i   assign to max ( 0, arr array of i   - current_diff )
set total to total + current_diff
return total
declare integer main ( ) and integer X assign to 1
create integer array arr with arr assign to  1, 6, 1, 2, 0, 4
N assign to sizeof ( arr ) / sizeof ( int )
print MinOperations ( N, X, arr )
return 0
","Finding a Non Transitive Co 
 C ++ program to find possible non transitive triplets btw L and R ; Function to return gcd of a and b ; function to check untill gcd ; a and b are coprime if their gcd is 1. ; Checks if any possible triplet ( a , b , c ) satisfying the condition that ( a , b ) is coprime , ( b , c ) is coprime but ( a , c ) isnt ; Generate and check untill all possible triplets between L and R ; if we find any such triplets set flag to true ; flag assign to True indicates that a pair exists between L and R ; Driver code ; finding possible Triplet between 2 and 10 ; finding possible Triplet between 23 and 46
",0
802,"declare findNumbers with integer arr array of  , integer n, sumN assign to ( n * ( n + 1 ) ) / 2 as arguments, returning void
create integer sumSqN with sumSqN assign to ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6
create integers sum, sumSq, i, with sum assign to 0, sumSq assign to 0
untill i assign to 0 to n exclusive, add arr array of i   to sum
set sumSq to sumSq + ( pow ( arr array of i  , 2 ) )
declare integer B assign to ( ( sumSq - sumSqN ) / ( sum - sumN ) ) + sumN - sum ) / 2
declare integer A assign to sum - sumN + B
print A
print A
print B
print B
declare integer main ( ), integer arr array of   assign to  1, 2, 2, 3, 4  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
call findNumbers ( arr, n )
return 0
","Find the repeating and the missing number using two equations 
 C ++ implementation of the approach ; Function to print the required numbers ; Sum of first n natural numbers ; Sum of squares of first n natural numbers ; To store the sum and sum of squares of the array elements ; Driver code
",1
803,"declare findNumbers with integer arr array of  , integer n, sumN assign to ( n * ( n + 1 ) ) / 2 as arguments, returning void
create integer sumSqN with sumSqN assign to ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6
create integers sum, sumSq, i, with sum assign to 0, sumSq assign to 0
untill i assign to 0 to n exclusive, add arr array of i   to sum
set sumSq to sumSq + ( pow ( arr array of i  , 2 ) )
declare integer B assign to ( ( sumSq - sumSqN ) / ( sum - sumN ) ) + sumN - sum ) / 2
declare integer A assign to sum - sumN + B
print A
print A
print B
print B
declare integer main ( ), integer arr array of   assign to  1, 2, 2, 3, 4  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
call findNumbers ( arr, n )
return 0
","Largest area square in an array when elements can be shuffled 
 C ++ implementation of the approach ; Function that returns true if it is possible to make a square with side equal to l ; To store the count of elements greater than or equal to l ; Increment the count ; If the count becomes greater than or equal to l ; Function to return the maximum area of the square that can be obtained ; If square is possible with side length m ; Try to find a square with smaller side length ; Return the area ; Driver code
",0
804,"return 0 if temp. length ( )  str. length ( )
else if str array of i   is not temp array of i   return 0
return 1
sort string lexicographicallyString ( string input array of  , integer n, string str ), sort input, input + n )
untill i assign to 0 to n exclusive, temp assign to input array of i  
if is_prefix ( temp, str ) returns temp
return "" - 1""
declare integer main ( ) and string arr array of   assign to "" apple "", "" appe "", "" apl "", "" aapl "", "" appax ""
create string S with S assign to app
create integer N with N assign to 5
print lexicographicallyString ( arr, N, S )
return 0
","Lexicographically smallest string with given string as prefix 
 C ++ program untill the above approach ; Function to find the whether the string temp starts with str or not ; Base Case ; Check untill the corresponding characters in temp & str ; Function to find lexicographic smallest string consisting of the string str as prefix ; Sort the given array string arr array of   ; If the i - th string contains given string as a prefix , then print the result ; If no string exists then return "" - 1"" ; Driver Code
",1
805,"return 0 if temp. length ( )  str. length ( )
else if str array of i   is not temp array of i   return 0
return 1
sort string lexicographicallyString ( string input array of  , integer n, string str ), sort input, input + n )
untill i assign to 0 to n exclusive, temp assign to input array of i  
if is_prefix ( temp, str ) returns temp
return "" - 1""
declare integer main ( ) and string arr array of   assign to "" apple "", "" appe "", "" apl "", "" aapl "", "" appax ""
create string S with S assign to app
create integer N with N assign to 5
print lexicographicallyString ( arr, N, S )
return 0
","Minimum score possible untill a player by selecting one or two consecutive array elements from given binary array 
 C ++ program untill the above approach ; Stores the minimum score untill each states as map < pair < pos , myturn > , ans > ; Function to find the minimum score after choosing element from array ; Return the stored state ; Base Case ; Player A 's turn ; Find the minimum score ; Store the current state ; Return the result ; Player B 's turn ; Find minimum score ; Store the current state ; Return the result ; Function that finds the minimum penality after choosing element from the given binary array ; Starting position of choosing element from array ; 0 denotes player A turn 1 denotes player B turn ; Function Call ; Print the answer untill player A and B ; Minimum penalty ; Calculate sum of all arr elements ; Print the minimum score ; Driver Code
",0
806,"declare Rearrange with integer arr array of  , K, N, integer ans array of N + 1   as arguments, returning integer
f assign to integer with f assign to -1
untill i assign to 0 to N exclusive, set ans array of i   to -1
K assign to find ( arr, arr + N, K ) - arr
create vector  integer > smaller, greater
untill i assign to 0 to N exclusive, if arr array of i  is less than arr array of K , push_back ( arr array of i   )
else if arr array of i  > arr array of K  greater push_back ( arr array of i   )
low, high assign to integers with low assign to 0 and high assign to N - 1
untill low assign to high, mid assign to integer with mid assign to ( low + high ) / 2
if mid is K, set ans array of mid  to arr array of K 
set f to 1
break loop
else if mid is less than K, if smaller. size ( ) is 0, break
set ans array of mid  to smaller. back ( )
pop_back is a smaller function
low assign to mid + 1
else if greater. size ( ) is 0, break
set ans array of mid  to greater. back ( )
pop_back is a new function
high assign to mid - 1
if f is -1 print -1 print newline
return
untill i assign to 0 to N exclusive, if ans array of i   is -1, if smaller. size ( ), ans array of i   is smaller. back ( ), if ans array of i   is smaller. size ( ), increment ans array of i  
pop_back is a smaller function
else if greater. size ( ) ), ans array of i   assign to greater. back ( )
pop_back is a new function
print ans array of i   and "" ""
print newline
declare integer main ( ), integer arr array of   assign to  10, 7, 2, 5, 3, 8  ;
K assign to integer with K assign to 7
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
Rearrange ( arr, K, N)
return 0
","Rearrange Array to find K using Binary Search algorithm without sorting 
 C ++ program untill the above approach ; Function to rearrange the array ; Stores the rearranged array ; Stores whether the arrangement is possible or not ; Update K with the position of K ; Stores all elements lesser than and greater than in vector smaller and greater respectively ; Traverse the array arr array of   ; If arr array of i   is less than arr array of K   ; Else ; Iterate unil low is less than or equal to high ; Stores mid point ; If mid is equal to K ; If mid is less than K ; If mid is greater than K ; If f is - 1 ; Iterate in the range array of 1 , N   ; If ans array of i   is equal to - 1 ; Print the rearranged array ; Driver Code ; Input ; Function Call
",1
807,"declare Rearrange with integer arr array of  , K, N, integer ans array of N + 1   as arguments, returning integer
f assign to integer with f assign to -1
untill i assign to 0 to N exclusive, set ans array of i   to -1
K assign to find ( arr, arr + N, K ) - arr
create vector  integer > smaller, greater
untill i assign to 0 to N exclusive, if arr array of i  is less than arr array of K , push_back ( arr array of i   )
else if arr array of i  > arr array of K  greater push_back ( arr array of i   )
low, high assign to integers with low assign to 0 and high assign to N - 1
untill low assign to high, mid assign to integer with mid assign to ( low + high ) / 2
if mid is K, set ans array of mid  to arr array of K 
set f to 1
break loop
else if mid is less than K, if smaller. size ( ) is 0, break
set ans array of mid  to smaller. back ( )
pop_back is a smaller function
low assign to mid + 1
else if greater. size ( ) is 0, break
set ans array of mid  to greater. back ( )
pop_back is a new function
high assign to mid - 1
if f is -1 print -1 print newline
return
untill i assign to 0 to N exclusive, if ans array of i   is -1, if smaller. size ( ), ans array of i   is smaller. back ( ), if ans array of i   is smaller. size ( ), increment ans array of i  
pop_back is a smaller function
else if greater. size ( ) ), ans array of i   assign to greater. back ( )
pop_back is a new function
print ans array of i   and "" ""
print newline
declare integer main ( ), integer arr array of   assign to  10, 7, 2, 5, 3, 8  ;
K assign to integer with K assign to 7
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
Rearrange ( arr, K, N)
return 0
","Queries to find longest subsequence having no similar adjacent elements with updates 
 C ++ program untill the above approach ; Function to find the length of the longest subsequence such that no two adjacent elements are equal ; Replace element at index x with y ; Since x is 1 - indexed , decrement x by 1 ; Keep track of number of elements in subsequence ; If previous element is not same as current element ; Print the desired count ; Driver Code ; Function Call
",0
808,"declare minimumK with vector  integers > & arr, integer M, integer N, good assign to ceil ( ( N * 1.0 ) / ( ( M + 1 ) * 1.0 ) ) as arguments, returning void
untill i assign to 1 to N inclusive, K assign to i
create integer candies with candies assign to N
create integer taken with taken assign to 0
untill candies > 0, take assign to taken + min ( K, candies )
decrease candies by min ( K, candies )
untill j assign to 0 to M exclusive, consume assign to ( arr array ofj  * candies ) / 100
decrement candies by consume
if taken >assign to good print i
return
declare integer variables N assign to 13 and M assign to 1
create vector  integer > arr assign to  50
minimumK ( arr, M, N)
return 0
","Minimize K to let Person A consume at least ceil ( N / ( M + 1 ) ) candies based on given rules 
 C ++ program untill the above approach ; Function to find minimum value of K such that the first person gets at least ( N / ( M + 1 ) ) candies ; Find the minimum required value of candies untill the first person ; Iterate K from array of 1 , n   ; Total number of candies ; Candies taken by Person 1 ; Candies taken by 1 st person is minimum of K and candies left ; Traverse the array arr array of   ; Amount consumed by the person j ; Update the number of candies ; Good share of candies achieved ; Driver Code
",1
809,"declare minimumK with vector  integers > & arr, integer M, integer N, good assign to ceil ( ( N * 1.0 ) / ( ( M + 1 ) * 1.0 ) ) as arguments, returning void
untill i assign to 1 to N inclusive, K assign to i
create integer candies with candies assign to N
create integer taken with taken assign to 0
untill candies > 0, take assign to taken + min ( K, candies )
decrease candies by min ( K, candies )
untill j assign to 0 to M exclusive, consume assign to ( arr array ofj  * candies ) / 100
decrement candies by consume
if taken >assign to good print i
return
declare integer variables N assign to 13 and M assign to 1
create vector  integer > arr assign to  50
minimumK ( arr, M, N)
return 0
","Given an n x n square matrix , find sum of all sub 
 A simple C ++ program to find sum of all subsquares of size k x k ; Size of given matrix ; A simple function to find sum of all sub - squares of size k x k in a given square matrix of size n x n ; k must be smaller than or equal to n ; row number of first cell in current sub - square of size k x k ; column of first cell in current sub - square of size k x k ; Calculate and print sum of current sub - square ; Line separator untill sub - squares starting with next row ; Driver program to test above function
",0
810,"declare check with integers K, n, m, vector  integers > arr, good_share, candies assign to n, taken assign to 0
untill candies > 0, take assign to taken + min ( K, candies )
decrease candies by min ( K, candies )
untill j assign to 0 to m exclusive, consume assign to ( arr array ofj  * candies ) / 100
decrement candies by consume
return ( taken >assign to good_share )
let minimumK be a void function with vector elements arr, N, M and good_share assign to ceil ( ( N * 1.0 ) / ( ( M + 1 ) * 1.0 ) )
declare integers lo assign to 1 and hi assign to N
untill lo  hi, mid assign to int with mid assign to ( lo + hi ) / 2
if check ( mid, N, M, arr, good_share ) is true, hi assign to mid
else set lo to mid + 1
print a newline
declare integer main ( ), integers N assign to 13 and M assign to 1
create vector  integer > arr assign to  50
minimumK ( arr, N, M)
return 0
","Minimize K to let Person A consume at least ceil ( N / ( M + 1 ) ) candies based on given rules 
 C ++ program untill the above approach ; Function to check if the value of mid gives at least ( N / ( M + 1 ) ) candies or not ; Candies taken by 1 st person is minimum of K and candies left ; Traverse the given array ; Amount consumed by person j ; Update the count of candies ; Check if person 1 gets the good share of candies ; Function to find minimum value of K such that the first person gets at least ( N / ( M + 1 ) ) candies ; Find the minimum required value of candies untill the first person ; Iterate until low is less than or equal to mid ; Find the value of mid ; Check untill mid , whether it can be the possible value of K or not ; Update the value of hi ; Otherwise , update the value of lo ; Print the resultant minimum value of K ; Driver Code
",1
811,"declare check with integers K, n, m, vector  integers > arr, good_share, candies assign to n, taken assign to 0
untill candies > 0, take assign to taken + min ( K, candies )
decrease candies by min ( K, candies )
untill j assign to 0 to m exclusive, consume assign to ( arr array ofj  * candies ) / 100
decrement candies by consume
return ( taken >assign to good_share )
let minimumK be a void function with vector elements arr, N, M and good_share assign to ceil ( ( N * 1.0 ) / ( ( M + 1 ) * 1.0 ) )
declare integers lo assign to 1 and hi assign to N
untill lo  hi, mid assign to int with mid assign to ( lo + hi ) / 2
if check ( mid, N, M, arr, good_share ) is true, hi assign to mid
else set lo to mid + 1
print a newline
declare integer main ( ), integers N assign to 13 and M assign to 1
create vector  integer > arr assign to  50
minimumK ( arr, N, M)
return 0
","Sort an array according to count of set bits 
 C ++ program to implement simple approach to sort an array according to count of set bits . ; a utility function that returns total set bits count in an integer ; Function to simultaneously sort both arrays using insertion sort ( https : www . geeksuntillgeeks . org / insertion - sort / ) ; use 2 keys because we need to sort both arrays simultaneously ; Move elements of arr array of 0. . i - 1   and aux array of 0. . i - 1   , such that elements of aux array of 0. . i - 1   are greater than key1 , to one position ahead of their current position ; Function to sort according to bit count using an auxiliary array ; Create an array and store count of set bits in it . ; Sort arr array of   according to values in aux array of   ; Utility function to print an array ; Driver Code
",0
812,"calcTotalTime assign to void with calcTotalTime assign to string path and time assign to 0
create integers x, y with x assign to 0 and y assign to 0
set  pair  int, int > > s
untill i assign to 0 to size of path exclusive, p assign to x
create integer q with q assign to y
if path array of i   is'N', increment y
else if path array of i   is'S', decrement y
else if path array of i   is'E', increment x
else if path array of i   is'W', decrement x
if s. find (  p + x, q + y  ) assign to s. end ( ) ), time assign to time + 2
insert p + x, q + y
else time assign to time + 1
print time
declare integer main ( ) and string path assign to "" NSE ""
calcTotalTime is a new function
return 0
","Total time required to travel a path denoted by a given string 
 C ++ code untill the above approach ; Function to calculate time taken to travel the path ; Stores total time ; Initial position ; Stores visited segments ; Check whether segment is present in the set ; Increment the value of time by 2 ; Insert segment into the set ; Print the value of time ; Driver Code
",1
813,"calcTotalTime assign to void with calcTotalTime assign to string path and time assign to 0
create integers x, y with x assign to 0 and y assign to 0
set  pair  int, int > > s
untill i assign to 0 to size of path exclusive, p assign to x
create integer q with q assign to y
if path array of i   is'N', increment y
else if path array of i   is'S', decrement y
else if path array of i   is'E', increment x
else if path array of i   is'W', decrement x
if s. find (  p + x, q + y  ) assign to s. end ( ) ), time assign to time + 2
insert p + x, q + y
else time assign to time + 1
print time
declare integer main ( ) and string path assign to "" NSE ""
calcTotalTime is a new function
return 0
","Maximum number of elements without overlapping in a Line 
 CPP program to find maximum number of elements without overlapping in a line ; Function to find maximum number of elements without overlapping in a line ; If n assign to 1 , then answer is one ; We can always make 1 st element to cover left segment and nth the right segment ; If left segment untill ith element doesnt overlap with i - 1 th element then do left ; else try towards right if possible ; update x array of i   to right endpoint of segment covered by it ; Return the required answer ; Driver code ; Function call
",0
814,"declare findCost with integers A array of  , N, totalCost assign to 0
untill i assign to 0 to N exclusive, if A array of i   is 0, A array of i   assign to 1
increment totalCost by i
return totalCost
declare integer main ( ), integer arr array of   assign to  1, 0, 1, 0, 1, 0, 1, 0, 0, 0   ;
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print findCost ( arr, N )
return 0
","Cost required to make all array elements equal to 1 
 C ++ program untill the above approach ; Function to calculate the cost required to make all array elements equal to 1 ; Stores the total cost ; Traverse the array arr array of   ; If current element is 0 ; Convert 0 to 1 ; Add the cost ; Return the total cost ; Driver Code
",1
815,"declare findCost with integers A array of  , N, totalCost assign to 0
untill i assign to 0 to N exclusive, if A array of i   is 0, A array of i   assign to 1
increment totalCost by i
return totalCost
declare integer main ( ), integer arr array of   assign to  1, 0, 1, 0, 1, 0, 1, 0, 0, 0   ;
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print findCost ( arr, N )
return 0
","Make largest palindrome by changing at most K 
 C ++ program to get largest palindrome changing atmost K digits ; Returns maximum possible palindrome using k changes ; Initialize l and r by leftmost and rightmost ends ; first try to make string palindrome ; Replace left and right character by maximum of both ; If k is negative then we can 't make  string palindrome ; At mid character , if K > 0 then change it to 9 ; If character at lth ( same as rth ) is less than 9 ; If none of them is changed in the previous loop then subtract 2 from K and convert both to 9 ; If one of them is changed in the previous loop then subtract 1 from K ( 1 more is subtracted already ) and make them 9 ; Driver code to test above methods
",0
816,"return -1 if N is less than 3
create integer i with i assign to 0
untill i + 1  N, if arr array of i + 1    arr array of i   arr array of i   is arr array of i + 1   break
increment i
if i is 0 i is N - 1 return -1
create integer ans with ans assign to i
untill i  N - 1, if arr array of i    arr array of i + 1   arr array of i   assign to arr array of i + 1   break
increment i
if i is N - 1 return ans
return -1
declare integer main ( ), integer arr assign to 0, 1, 0
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print peakIndex ( arr, N ) and "" STRNEWLINE ""
return 0
","Find the peak index of a given array 
 C ++ program untill the above approach ; Function to find the peak index untill the given array ; Base Case ; Check untill strictly increasing array ; If the strictly increasing condition is violated , then break ; Stores the value of i , which is a potential peak index ; Second traversal , untill strictly decreasing array ; When the strictly decreasing condition is violated , then break ; If i assign to N - 1 , it means that ans is the peak index ; Otherwise , peak index doesn 't exist ; Driver Code
",1
817,"return -1 if N is less than 3
create integer i with i assign to 0
untill i + 1  N, if arr array of i + 1    arr array of i   arr array of i   is arr array of i + 1   break
increment i
if i is 0 i is N - 1 return -1
create integer ans with ans assign to i
untill i  N - 1, if arr array of i    arr array of i + 1   arr array of i   assign to arr array of i + 1   break
increment i
if i is N - 1 return ans
return -1
declare integer main ( ), integer arr assign to 0, 1, 0
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print peakIndex ( arr, N ) and "" STRNEWLINE ""
return 0
","Position of n among the numbers made of 2 , 3 , 5 & 7 
  ; If number is 2 then it is on the position pos * 2 + 1 ; If number is 3 then it is on the position pos * 2 + 2 ; If number is 5 then it is on the position pos * 2 + 3 ; If number is 7 then it is on the position pos * 2 + 4 ; Driver code
",0
818,"create void hasArrayTwoPairs ( int nums array of  , int n, int target ) sort ( nums, nums + n )
untill i assign to 0 to n exclusive, x assign to target - nums array of i  
low, high assign to integers with low assign to 0 and high assign to n - 1
untill low assign to high, mid assign to integer with mid assign to low + ( ( high - low ) / 2 )
if nums array of mid  is greater than x, set high to mid - 1
else if nums array of mid  is less than x, set low to mid + 1
else if mid is i, if ( mid - 1 >assign to 0) and nums array of mid - 1   assign to x, print nums array of i  and "", ""
print nums array of mid - 1  
return
if mid + 1 is less than n and nums array of mid + 1  is x print nums array of i  print "", ""
print nums array of mid + 1 
return
break
else print nums array of i  print "", ""
print nums array of mid 
return
print -1
declare integer main ( ), integer A assign to 0, -1, 2, -3, 1  ; declare integer array A size   assign to 0
create integer X with X assign to -2
create integer N with N assign to sizeof ( A) / sizeof ( A array of 0   )
create hasArrayTwoPairs ( A, N, X )
return 0
","Given an array A array of   and a number x , check untill pair in A array of   with sum as x 
 Set 2 
 C ++ program untill the above approach ; Function to check if the array has 2 elements whose sum is equal to the given value ; Sort the array in increasing order ; Traverse the array , nums array of   ; Store the required number to be found ; Peruntillm binary search ; Store the mid value ; If nums array of mid   is greater than x , then update high to mid - 1 ; If nums array of mid   is less than x , then update low to mid + 1 ; Otherwise ; If mid is equal i , check mid - 1 and mid + 1 ; Otherwise , print the pair and return ; If no such pair is found , then print - 1 ; Driver Code ; Function Call
",1
819,"create void hasArrayTwoPairs ( int nums array of  , int n, int target ) sort ( nums, nums + n )
untill i assign to 0 to n exclusive, x assign to target - nums array of i  
low, high assign to integers with low assign to 0 and high assign to n - 1
untill low assign to high, mid assign to integer with mid assign to low + ( ( high - low ) / 2 )
if nums array of mid  is greater than x, set high to mid - 1
else if nums array of mid  is less than x, set low to mid + 1
else if mid is i, if ( mid - 1 >assign to 0) and nums array of mid - 1   assign to x, print nums array of i  and "", ""
print nums array of mid - 1  
return
if mid + 1 is less than n and nums array of mid + 1  is x print nums array of i  print "", ""
print nums array of mid + 1 
return
break
else print nums array of i  print "", ""
print nums array of mid 
return
print -1
declare integer main ( ), integer A assign to 0, -1, 2, -3, 1  ; declare integer array A size   assign to 0
create integer X with X assign to -2
create integer N with N assign to sizeof ( A) / sizeof ( A array of 0   )
create hasArrayTwoPairs ( A, N, X )
return 0
","Count of Binary Strings of length N such that frequency of 1 ' s â– exceeds â– frequency â– of â– 0' s 
 C ++ Program to implement the above approach ; Function to calculate and return the value of Binomial Coefficient C ( n , k ) ; Since C ( n , k ) assign to C ( n , n - k ) ; Calculate the value of array of n * ( n - 1 ) * -- - * ( n - k + 1 )   / array of k * ( k - 1 ) * -- - * 1   ; Function to return the count of binary strings of length N such that frequency of 1 ' s â– exceed â– that â– of â– 0' s ; Count of N - length binary strings ; Count of N - length binary strings having equal count of 0 ' s â– and â– 1' s ; For even length strings ; Driver Code
",0
820,"declare findClosest with integers N, target as arguments, set closest to -1
declare integer variable diff assign to INT_MAX
untill i assign to 1 to sqrt ( N ), if N % i is 0, if N % i is 0, if abs ( target - i )  diff, diff assign to abs ( target - i )
set closest to i
else if abs ( target - i)  diff, diff assign to abs ( target - i )
set closest to i
if abs ( target - N / i )  diff ) diff assign to abs ( target - N / i )
set closest to N / i
print closest
declare integer main ( ), integer N assign to 16 and X assign to 5
findClosest ( N, X )
return 0
","Smallest divisor of N closest to X 
 C ++ program untill the above approach ; Function to find the divisor of N closest to the target ; Iterate till square root of N ; Check if divisors are equal ; Check if i is the closest ; Check if i is the closest ; Check if n / i is the closest ; Print the closest value ; Driver Code ; Given N & X ; Function Call
",1
821,"declare findClosest with integers N, target as arguments, set closest to -1
declare integer variable diff assign to INT_MAX
untill i assign to 1 to sqrt ( N ), if N % i is 0, if N % i is 0, if abs ( target - i )  diff, diff assign to abs ( target - i )
set closest to i
else if abs ( target - i)  diff, diff assign to abs ( target - i )
set closest to i
if abs ( target - N / i )  diff ) diff assign to abs ( target - N / i )
set closest to N / i
print closest
declare integer main ( ), integer N assign to 16 and X assign to 5
findClosest ( N, X )
return 0
","Count ways to express a number as sum of consecutive numbers 
 C ++ program to count number of ways to express N as sum of consecutive numbers . ; Utility method to compute number of ways in which N can be represented as sum of consecutive number ; constraint on values of L gives us the time Complexity as O ( N to the power 0.5 ) ; Driver Code
",0
822,"declare power with long long integers A, N, count assign to 0
if A is 1 return 0
untill N is true, increment count
N assign to N / A
return count
create void Pairs ( long long int N, long long int A, long long int B), powerA, powerB
set powerA to power ( A, N )
set powerB to power ( B, N )
declare long long integers intialB assign to B, intialA assign to A
set A to 1
untill i assign to 0 to powerA inclusive, B assign to 1
untill j assign to 0 to powerB inclusive, print i, "" "", j and a new line
return
B * intialB
A * intialA
print -1 print newline
return
declare integer main ( ), long long integers N assign to 106, A assign to 3 and B assign to 5
Pairs ( N, A, B )
return 0
","Find a pair ( a , b ) such that Aa + Bb assign to N 
 C ++ program untill the above approach ; Function to calculate the minimum power of A and B greater than N ; Stores the power of A which is greater than N ; Increment count by 1 ; Divide N by A ; Function to find a pair ( a , b ) such that A to the power a + B to the power b assign to N ; Calculate the minimum power of A greater than N ; Calculate the minimum power of B greater than N ; Make copy of A and B ; Traverse untill every pair ( i , j ) ; Check if B to the power j + A to the power i assign to N To overcome the overflow problem use B assign to N - A rather than B + A assign to N ; Increment power B by 1 ; Increment power A by 1 ; Finally print - 1 if no pair is found ; Driver Code ; Given A , B and N ; Function Call
",1
823,"declare power with long long integers A, N, count assign to 0
if A is 1 return 0
untill N is true, increment count
N assign to N / A
return count
create void Pairs ( long long int N, long long int A, long long int B), powerA, powerB
set powerA to power ( A, N )
set powerB to power ( B, N )
declare long long integers intialB assign to B, intialA assign to A
set A to 1
untill i assign to 0 to powerA inclusive, B assign to 1
untill j assign to 0 to powerB inclusive, print i, "" "", j and a new line
return
B * intialB
A * intialA
print -1 print newline
return
declare integer main ( ), long long integers N assign to 106, A assign to 3 and B assign to 5
Pairs ( N, A, B )
return 0
","Find weight of MST in a complete graph with edge 
 C ++ Program to find weight of minimum spanning tree in a complete graph where edges have weight either 0 or 1 ; To store the edges of the given graph ; A utility function to peruntillm DFS Traversal ; Check those vertices which are stored in the set ; Vertices are included if the weight of edge is 0 ; A utility function to find the weight of Minimum Spanning Tree ; To count the connected components ; Inserting the initial vertices in the set ; Traversing vertices stored in the set and Run DFS Traversal untill each vertices ; Incrementing the zero weight connected components ; DFS Traversal untill every vertex remove ; Driver 's Code ; Insert edges ; Function call find the weight of Minimum Spanning Tree
",0
824,"declare findNonMultiples with integer arr array of  , integer n, integer k as arguments, set and integers > multiples
untill i assign to 0 to n exclusive, if multiples. find ( arr array of i   ) assign to multiples. end ( ) ), untill j assign to 1, j assign to k / arr array of i  , insert ( arr array of i   * j ) into multiples
return k - multiples. size ( )
return findNonMultiples ( arr, N, R ) - findNonMultiples ( arr, N, L - 1)
declare integer main ( ), integer arr array of   assign to  2, 3, 4, 5, 6  ;
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
let L, R be integers with L assign to 1 and R assign to 20
print countValues ( arr, N, L, R)
return 0
","Count numbers from a given range that are not divisible by any of the array elements 
 C ++ program untill the above approach ; Function to find the non - multiples till k ; Stores all unique multiples ; Iterate the array ; For finding duplicates only once ; Inserting all multiples into the set ; Returning only the count of numbers that are not divisible by any of the array elements ; Function to count the total values in the range array of L , R   ; Count all values in the range using exclusion principle ; Driver Code ; Function Call
",1
825,"declare findNonMultiples with integer arr array of  , integer n, integer k as arguments, set and integers > multiples
untill i assign to 0 to n exclusive, if multiples. find ( arr array of i   ) assign to multiples. end ( ) ), untill j assign to 1, j assign to k / arr array of i  , insert ( arr array of i   * j ) into multiples
return k - multiples. size ( )
return findNonMultiples ( arr, N, R ) - findNonMultiples ( arr, N, L - 1)
declare integer main ( ), integer arr array of   assign to  2, 3, 4, 5, 6  ;
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
let L, R be integers with L assign to 1 and R assign to 20
print countValues ( arr, N, L, R)
return 0
","Count of right shifts untill each array element to be in its sorted position 
 C ++ Program to implement the approach ; Function to find the right shifts required untill each element to reach its sorted array position in A array of   ; Stores required number of shifts untill each element ; If the element is at sorted position ; Otherwise ; Calculate right shift ; Print the respective shifts ; Driver Code
",0
826,"declare minCollectingSpeed as integer vector  integers > & piles, integer H, ans assign to -1
low assign to integer with low assign to 1, high
high assign to * max element ( piles. begin ( ), piles. end ( ) ) )
untill low assign to high, K assign to integer with K assign to low + ( high - low ) / 2
create integer time with time assign to 0
untill ai : piles, time assign to time + ( ai + K - 1 ) / K
if time is less than or equal to H, set ans to K
high assign to K - 1
else low assign to K + 1
print ans
declare integer main ( ), vector, integer arr assign to  3, 6, 7, 11  ;
create integer H with H assign to 8
minCollectingSpeed ( arr, H )
return 0
","Minimum number of coins to be collected per hour to empty N piles in at most H hours 
 C ++ program untill the above approach ; Function to find the minimum number of coins to be collected per hour to empty N piles in H hours ; Stores the minimum coins to be removed per hour ; Find the maximum array element ; Peruntillm Binary Search ; Store the mid value of the range in K ; Find the total time taken to empty N piles by removing K coins per hour ; If total time does not exceed H ; Otherwise ; Print the required result ; Driver Code ; Function Call
",1
827,"declare minCollectingSpeed as integer vector  integers > & piles, integer H, ans assign to -1
low assign to integer with low assign to 1, high
high assign to * max element ( piles. begin ( ), piles. end ( ) ) )
untill low assign to high, K assign to integer with K assign to low + ( high - low ) / 2
create integer time with time assign to 0
untill ai : piles, time assign to time + ( ai + K - 1 ) / K
if time is less than or equal to H, set ans to K
high assign to K - 1
else low assign to K + 1
print ans
declare integer main ( ), vector, integer arr assign to  3, 6, 7, 11  ;
create integer H with H assign to 8
minCollectingSpeed ( arr, H )
return 0
","Minimum range increment operations to Sort an array 
 C ++ program to find minimum range increments to sort an array ; Function to find minimum range increments to sort an array ; If current element is found greater than last element Increment all terms in range i + 1 to n - 1 ; mn assign to arr array of i   ; Minimum in range i to n - 1 ; Driver Code
",0
828,"declare integer cntDisPairs ( integer arr array of  , integer N, integer K )  integer cntPairs assign to 0
sort arr, arr + N
create integer i with i assign to 0
create integer j with j assign to N - 1
untill i  j, increment i if arr array of i   + arr array of j   is K, untill i  j and arr array of i   is arr array of i + 1  
untill i  j and arr array of j   assign to arr array of j - 1  , decrement j
increment cntPairs by 1
increment i
decrement j
else if arr array of i   + arr array of j    K, increment i
else, decrement j
return cntPairs
declare integer main ( ), integer arr array of   assign to  5, 6, 5, 7, 7, 8  ;
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
K assign to integer with K assign to 13
print cntDisPairs ( arr, N, K )
","Count distinct pairs with given sum 
 C ++ program to implement the above approach ; Function to count distinct pairs in array whose sum equal to K ; Stores count of distinct pairs whose sum equal to K ; Sort the array ; Stores index of the left pointer ; Stores index of the right pointer ; Calculate count of distinct pairs whose sum equal to K ; If sum of current pair is equal to K ; Remove consecutive duplicate array elements ; Update i ; Remove consecutive duplicate array elements ; Update j ; Update cntPairs ; Update i ; Update j ; if sum of current pair less than K ; Update i ; Update j ; Driver Code
",1
829,"declare integer cntDisPairs ( integer arr array of  , integer N, integer K )  integer cntPairs assign to 0
sort arr, arr + N
create integer i with i assign to 0
create integer j with j assign to N - 1
untill i  j, increment i if arr array of i   + arr array of j   is K, untill i  j and arr array of i   is arr array of i + 1  
untill i  j and arr array of j   assign to arr array of j - 1  , decrement j
increment cntPairs by 1
increment i
decrement j
else if arr array of i   + arr array of j    K, increment i
else, decrement j
return cntPairs
declare integer main ( ), integer arr array of   assign to  5, 6, 5, 7, 7, 8  ;
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
K assign to integer with K assign to 13
print cntDisPairs ( arr, N, K )
","Construct two N 
 C ++ program untill the above approach ; Function to generate two arrays satisfying the given conditions ; Declare the two arrays A and B ; Iterate from range array of 1 , 2 * n   ; Assign consecutive numbers to same indices of the two arrays ; Print the first array ; Print the second array , B ; Driver Code ; Function Call
",0
830,"declare integer cntDisPairs ( integer arr array of  , integer N, integer K )  integer cntPairs assign to 0
create an array of ints, ints, cntFre
untill i assign to 0 to N exclusive, increment cntFre array of arr array of i    
untill auto it : cntFre, i assign to it. first
if 2 * i is K, increment cntFre array of i   by 2
else if cntFre array of K - i , increment cntPairs by 1
cntPairs assign to cntPairs / 2
return cntPairs
declare integer main ( ), integer arr array of   assign to  5, 6, 5, 7, 7, 8  ;
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
K assign to integer with K assign to 13
print cntDisPairs ( arr, N, K )
","Count distinct pairs with given sum 
 C ++ program to implement the above approach ; Function to count distinct pairs in array whose sum equal to K ; Stores count of distinct pairs whose sum equal to K ; Store frequency of each distinct element of the array ; Update frequency of arr array of i   ; Traverse the map ; Stores key value of the map ; If i is the half of K ; If frequency of i greater than 1 ; Update cntPairs ; Update cntPairs ; Driver Code
",1
831,"declare integer cntDisPairs ( integer arr array of  , integer N, integer K )  integer cntPairs assign to 0
create an array of ints, ints, cntFre
untill i assign to 0 to N exclusive, increment cntFre array of arr array of i    
untill auto it : cntFre, i assign to it. first
if 2 * i is K, increment cntFre array of i   by 2
else if cntFre array of K - i , increment cntPairs by 1
cntPairs assign to cntPairs / 2
return cntPairs
declare integer main ( ), integer arr array of   assign to  5, 6, 5, 7, 7, 8  ;
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
K assign to integer with K assign to 13
print cntDisPairs ( arr, N, K )
","Pascal 's Triangle 
 C ++ program untill Pascals Triangle A O ( n to the power 2 ) time and O ( 1 ) extra space function untill Pascal 's Triangle ; used to represent C ( line , i ) ; The first value in a line is always 1 ; Driver code
",0
832,"untill i assign to 0 to Q exclusive, x assign to Queries array of i   array of 0  
create integer y with y assign to Queries array of i   array of 1  
arr array of x - 1   assign to y
count assign to integer with count assign to 1
untill j assign to 1 to N exclusive, increment count by 1
print count print''
declare integer main ( ), integer arr assign to  1, 1, 2, 5, 2 , integer array arr assign to  1, 1, 2, 5, 2
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create integer Q with Q assign to 2
Queries assign to integer array of size Q and 2 with Queries assign to   1, 3 ,  4, 2
let N, Q, arr, Queries be longestSubsequences
return 0
","Queries to find longest subsequence having no similar adjacent elements with updates 
 C ++ program untill the above approach ; Function to find the length of the longest subsequence such that no two adjacent elements are equal ; Replace element at index x with y ; Since x is 1 - indexed , decrement x by 1 ; Keep track of number of elements in subsequence ; If previous element is not same as current element ; Print the desired count ; Driver Code ; Function Call
",1
833,"untill i assign to 0 to Q exclusive, x assign to Queries array of i   array of 0  
create integer y with y assign to Queries array of i   array of 1  
arr array of x - 1   assign to y
count assign to integer with count assign to 1
untill j assign to 1 to N exclusive, increment count by 1
print count print''
declare integer main ( ), integer arr assign to  1, 1, 2, 5, 2 , integer array arr assign to  1, 1, 2, 5, 2
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create integer Q with Q assign to 2
Queries assign to integer array of size Q and 2 with Queries assign to   1, 3 ,  4, 2
let N, Q, arr, Queries be longestSubsequences
return 0
","Diameter of a Binary Indexed Tree with N nodes 
  ; Function to find diameter of BIT with N + 1 nodes ; L is size of subtree just beuntille subtree in which N lies ; H is the height of subtree just beuntille subtree in which N lies ; Base Cases ; Size of subtree are power of 2 ; 3 Cases as explained in Approach ; Driver Code
",0
834,"declare longestSubsequence with integers N, Q, arr, Queries, 2 dimensionales, with count assign to 1
untill i assign to 1 to N exclusive, increment count by 1
untill i assign to 0 to Q exclusive, x assign to Queries array of i   array of 0  
create integer y with y assign to Queries array of i   array of 1  
if x is greater than 1 then decrement count by 1 if arr array of x - 1  is not arr array of x - 2  
if arr array of x - 2   is not y, increment count by 1
if x is less than N, if arr array of x   is not arr array of x - 1  , count is equal to count - 1
if y is not arr array of x  , increment count by 1
print count print''
arr array of x - 1   assign to y
declare integer main ( ), integer arr assign to  1, 1, 2, 5, 2 , integer array arr assign to  1, 1, 2, 5, 2
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create integer Q with Q assign to 2
Queries assign to integer array of size Q and 2 with Queries assign to   1, 3 ,  4, 2
let N, Q, arr, Queries be longestSubsequences
return 0
","Queries to find longest subsequence having no similar adjacent elements with updates 
 C ++ program untill the above approach ; Traverse the array arr array of   ; If previous element is not same as current element ; Traverse the queries ; Replace element at index x with y ; Recalculate untill index x ; Subtract contribution of element at index x ; Add contribution of y ; Recalculate untill index x + 1 ; Subtract contribution of element at index x + 1 ; Adds contribution of y ; Replace the element ; Driver Code ; Function Call
",1
835,"declare longestSubsequence with integers N, Q, arr, Queries, 2 dimensionales, with count assign to 1
untill i assign to 1 to N exclusive, increment count by 1
untill i assign to 0 to Q exclusive, x assign to Queries array of i   array of 0  
create integer y with y assign to Queries array of i   array of 1  
if x is greater than 1 then decrement count by 1 if arr array of x - 1  is not arr array of x - 2  
if arr array of x - 2   is not y, increment count by 1
if x is less than N, if arr array of x   is not arr array of x - 1  , count is equal to count - 1
if y is not arr array of x  , increment count by 1
print count print''
arr array of x - 1   assign to y
declare integer main ( ), integer arr assign to  1, 1, 2, 5, 2 , integer array arr assign to  1, 1, 2, 5, 2
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create integer Q with Q assign to 2
Queries assign to integer array of size Q and 2 with Queries assign to   1, 3 ,  4, 2
let N, Q, arr, Queries be longestSubsequences
return 0
","Reverse a doubly circular linked list 
 C ++ implementation to revesre a doubly circular linked list ; structure of a node of linked list ; function to create and return a new node ; Function to insert at the end ; If the list is empty , create a single node circular and doubly list ; Find last node ; Start is going to be next of new_node ; Make new node previous of start ; Make last preivous of new node ; Make new node next of old last ; Uitlity function to revesre a doubly circular linked list ; Initialize a new head pointer ; get pointer to the the last node ; set ' curr ' to last node ; traverse list in backward direction ; insert ' curr ' at the end of the list starting with the ' new _ head ' pointer ; head pointer of the reversed list ; function to display a doubly circular list in untillward and backward direction ; Driver program to test above
",0
836,"declare sum with integer arr array of  , integer n as arguments, set map to integers, vector to integers > > mp
untill i assign to 0 to n exclusive, print mp array of arr array of i    . push_back ( i )
ans assign to integer array of size n
untill i assign to 0 to n exclusive, sum assign to 0
untill auto it : mp array of arr array of i     )  sum + abs ( it - i )
set ans array of i   to sum
untill i assign to 0 to n exclusive, print ans array of i  and "" ""
return
declare integer main ( ), integer arr array of   assign to  1, 3, 1, 1, 2  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
sum assign to sum ( arr, n )
return 0
","Sum of absolute differences of indices of occurrences of each array element 
 C ++ program untill the above approach ; Function to find sum of differences of indices of occurrences of each unique array element ; Stores indices of each array element ; Store the indices ; Stores the sums ; Traverse the array ; Find sum untill each element ; Iterate over the Map ; Calculate sum of occurrences of arr array of i   ; Store sum untill current element ; Print answer untill each element ; Driver Code ; Given array ; Given size ; Function call
",1
837,"declare sum with integer arr array of  , integer n as arguments, set map to integers, vector to integers > > mp
untill i assign to 0 to n exclusive, print mp array of arr array of i    . push_back ( i )
ans assign to integer array of size n
untill i assign to 0 to n exclusive, sum assign to 0
untill auto it : mp array of arr array of i     )  sum + abs ( it - i )
set ans array of i   to sum
untill i assign to 0 to n exclusive, print ans array of i  and "" ""
return
declare integer main ( ), integer arr array of   assign to  1, 3, 1, 1, 2  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
sum assign to sum ( arr, n )
return 0
","Program to find area of a Circular Segment 
 C ++ Program to find area of segment of a circle ; Function to find area of segment ; Calculating area of sector ; Calculating area of triangle ; Driver Code
",0
838,"declare string variable conVowUpp with string & str, N assign to str. length ( )
untill i assign to 0 to N exclusive, if str array of i   assign to'a'str array of i   assign to'e'str array of i   assign to'o'str array of i   assign to'u ', str array of i   assign to str array of i   -'a'+'A '
return str
declare integer main ( ), string str assign to "" eutopia ""
print conVowUpp ( str)
","Convert vowels into upper case character in a given string 
 C ++ program to implement the above approach ; Function to convert vowels into uppercase ; Stores the length of str ; Driver Code
",1
839,"declare string variable conVowUpp with string & str, N assign to str. length ( )
untill i assign to 0 to N exclusive, if str array of i   assign to'a'str array of i   assign to'e'str array of i   assign to'o'str array of i   assign to'u ', str array of i   assign to str array of i   -'a'+'A '
return str
declare integer main ( ), string str assign to "" eutopia ""
print conVowUpp ( str)
","gOOGLE cASE of a given sentence 
 CPP program to convert given sentence to camel case . ; Function to remove spaces and convert into camel case ; check untill spaces in the sentence ; conversion into upper case ; If not space , copy character ; return string to main ; Driver Code
",0
840,"create map  int, int > mp
create integers N, P
create boolean helper (int mid)  int cnt assign to 0
untill i : mp, temp assign to i. second
untill temp >assign to mid, decrease temp by mid
increment cnt
return cnt >assign to N
untill i assign to 0 to P exclusive, mp array of arr array of i    is a new array of integers with value i 0 and i  P exclusive, incrementing i by 1
declare integers start assign to 0, end assign to P, ans assign to 0
untill start assign to end, mid assign to int with mid assign to start + ( end - start ) / 2 )
if mid is not 0 and helper ( mid ), ans assign to mid
set start to mid + 1
else if mid is 0, set start to mid + 1
else set end to mid - 1
return ans
declare integer variables main, N, P, with N assign to 3 and P assign to 10
create integer array arr with arr assign to  1, 2, 2, 1, 1, 3, 3, 3, 2, 4
print findMaximumDays ( arr)
return 0
","Maximize number of days untill which P chocolates can be distributed consecutively to N people 
 C ++ program to implement the above approach ; Stores the frequency of each type of chocolate ; Function to check if chocolates can be eaten untill ' mid ' no . of days ; If cnt exceeds N , return true ; Function to find the maximum number of days untill which chocolates can be eaten ; Store the frequency of each type of chocolate ; Initialize start and end with 0 and P respectively ; Calculate mid ; Check if chocolates can be distributed untill mid days ; Check if chocolates can be distributed untill more than mid consecutive days ; Driver code ; Function call
",1
841,"create map  int, int > mp
create integers N, P
create boolean helper (int mid)  int cnt assign to 0
untill i : mp, temp assign to i. second
untill temp >assign to mid, decrease temp by mid
increment cnt
return cnt >assign to N
untill i assign to 0 to P exclusive, mp array of arr array of i    is a new array of integers with value i 0 and i  P exclusive, incrementing i by 1
declare integers start assign to 0, end assign to P, ans assign to 0
untill start assign to end, mid assign to int with mid assign to start + ( end - start ) / 2 )
if mid is not 0 and helper ( mid ), ans assign to mid
set start to mid + 1
else if mid is 0, set start to mid + 1
else set end to mid - 1
return ans
declare integer variables main, N, P, with N assign to 3 and P assign to 10
create integer array arr with arr assign to  1, 2, 2, 1, 1, 3, 3, 3, 2, 4
print findMaximumDays ( arr)
return 0
","Program to find transpose of a matrix 
  ; Converts A array of   array of   to its transpose ; Driver Code
",0
842,"declare countSubarrays with integers a array of  , n, k as arguments, set ans to 0
create vector  integer > pref
push_back is a pref function
untill i assign to 0 to n exclusive, push_back ( ( a array of i   + pref array of i   ) % k )
untill i assign to 1 to n inclusive, increment ans by 1 if pref array ofj  - pref array of i - 1   + k ) % k assign to j - i + 1
print ans print''
declare integer main ( ), integer arr array of   assign to  2, 3, 5, 3, 1, 5  ;
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create integer K with K assign to 4
countSubarrays ( arr, N, K )
return 0
","Count subarrays having sum modulo K same as the length of the subarray 
 C ++ program of the above approach ; Function that counts the subarrays having sum modulo k equal to the length of subarray ; Stores the count of subarrays ; Stores prefix sum of the array ; Calculate prefix sum array ; Generate all the subarrays ; Check if this subarray is a valid subarray or not ; Total count of subarrays ; Driver Code ; Given arr array of   ; Size of the array ; Given K ; Function Call
",1
843,"declare countSubarrays with integers a array of  , n, k as arguments, set ans to 0
create vector  integer > pref
push_back is a pref function
untill i assign to 0 to n exclusive, push_back ( ( a array of i   + pref array of i   ) % k )
untill i assign to 1 to n inclusive, increment ans by 1 if pref array ofj  - pref array of i - 1   + k ) % k assign to j - i + 1
print ans print''
declare integer main ( ), integer arr array of   assign to  2, 3, 5, 3, 1, 5  ;
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create integer K with K assign to 4
countSubarrays ( arr, N, K )
return 0
","Program to check untill ISBN 
 CPP program to check if a given ISBN is valid or not ; length must be 10 ; Computing weighted sum of first 9 digits ; Checking last digit . ; If last digit is ' X ' , add 10 to sum , else add its value . ; Return true if weighted sum of digits is divisible by 11. ; Driver code
",0
844,"declare countSubarrays with integers a array of  , n, k as arguments, set desdered_map to integers, integers > cnt
create long long integer ans with ans assign to 0
create vector  integer > pref
push_back is a pref function
untill i assign to 0 to n exclusive, push_back ( ( a array of i   + pref array of i   ) % k )
set cnt array of 0   to 1
untill i assign to 1 to n inclusive, remIdx assign to i - k
if remIdx >assign to 0, cnt array of pref array of remIdx   - remIdx % k + k ) % k   --
increment ans by cnt array of ( pref array of i   - i % k + k ) % k  
increment cnt array of ( pref array of i   - i % k + k ) % k  
print ans print''
declare integer main ( ), integer arr array of   assign to  2, 3, 5, 3, 1, 5  ;
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create integer K with K assign to 4
countSubarrays ( arr, N, K )
return 0
","Count subarrays having sum modulo K same as the length of the subarray 
 C ++ program of the above approach ; Function that counts the subarrays s . t . sum of elements in the subarray modulo k is equal to size of subarray ; Stores the count of ( pref array of i   - i ) % k ; Stores the count of subarray ; Stores prefix sum of the array ; Find prefix sum array ; Base Condition ; Remove the index at present after K indices from the current index ; Update the answer untill subarrays ending at the i - th index ; Add the calculated value of current index to count ; Print the count of subarrays ; Driver Code ; Given arr array of   ; Size of the array ; Given K ; Function Call
",1
845,"declare countSubarrays with integers a array of  , n, k as arguments, set desdered_map to integers, integers > cnt
create long long integer ans with ans assign to 0
create vector  integer > pref
push_back is a pref function
untill i assign to 0 to n exclusive, push_back ( ( a array of i   + pref array of i   ) % k )
set cnt array of 0   to 1
untill i assign to 1 to n inclusive, remIdx assign to i - k
if remIdx >assign to 0, cnt array of pref array of remIdx   - remIdx % k + k ) % k   --
increment ans by cnt array of ( pref array of i   - i % k + k ) % k  
increment cnt array of ( pref array of i   - i % k + k ) % k  
print ans print''
declare integer main ( ), integer arr array of   assign to  2, 3, 5, 3, 1, 5  ;
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create integer K with K assign to 4
countSubarrays ( arr, N, K )
return 0
","Ways to write N as sum of two or more positive integers 
 Set 
 C ++ implementation of above approach ; Function to find the number of partitions of N ; Base case ; Driver code
",0
846,"declare integer check ( string & s, integer k )  integer n assign to size of s
untill i assign to 0 to k exclusive, return false if j assign to i ; j  n ; j +assign to k )
c assign to 0
untill i assign to 0 to k exclusive, increment c by 1 if s array of i   is '0'
else c assign to c
if c is 0, return true
else return false
declare integer main ( ) and string s assign to ""101010""
create integer k with k assign to 2
if check ( s, k ) is true, print Yes
else print No
return 0
","Check if all substrings of length K of a Binary String has equal count of 0 s and 1 s 
 C ++ program untill the above approach ; Function to check if the substring of length K has equal 0 and 1 ; Traverse the string ; Check if every K - th character is the same or not ; Traverse substring of length K ; If current character is 0 ; Increment count ; Otherwise ; Decrement count ; Check untill equal 0 s and 1 s ; Driver code
",1
847,"declare integer check ( string & s, integer k )  integer n assign to size of s
untill i assign to 0 to k exclusive, return false if j assign to i ; j  n ; j +assign to k )
c assign to 0
untill i assign to 0 to k exclusive, increment c by 1 if s array of i   is '0'
else c assign to c
if c is 0, return true
else return false
declare integer main ( ) and string s assign to ""101010""
create integer k with k assign to 2
if check ( s, k ) is true, print Yes
else print No
return 0
","Queries on XOR of greatest odd divisor of the range 
  ; Precompute the prefix XOR of greatest odd divisor ; Finding the Greatest Odd divisor ; Finding prefix XOR ; Return XOR of the range ; Driven Program
",0
848,"create boolean isSame ( string str, integer n ), create map, integer, integer, integer, with value mp
untill i assign to 0 to length of str exclusive, mp array of str array ofi  -'a'    - increment i
return true if it is a new line
return false
declare integer main ( ), string str assign to "" ccabcba ""
create integer n with n assign to 4
if isSame ( str, n ) ) print Yes
else print No
print a newlin
","Check if characters of a given string can be used to untillm any N equal strings 
 C ++ program untill the above approach ; Function to check if the freq of any character is divisible by N ; Stores the frequency of characters ; If frequency of a character is not divisible by n ; If no character has frequency at least N ; Driver Code ; Function Call
",1
849,"create boolean isSame ( string str, integer n ), create map, integer, integer, integer, with value mp
untill i assign to 0 to length of str exclusive, mp array of str array ofi  -'a'    - increment i
return true if it is a new line
return false
declare integer main ( ), string str assign to "" ccabcba ""
create integer n with n assign to 4
if isSame ( str, n ) ) print Yes
else print No
print a newlin
","Find a specific pair in Matrix 
 A Naive method to find maximum value of mat array of d   array of e   - ma array of a   array of b   such that d > a and e > b ; The function returns maximum value A ( d , e ) - A ( a , b ) over all choices of indexes such that both d > a and e > b . ; stores maximum value ; Consider all possible pairs mat array of a   array of b   and mat array of d   array of e   ; Driver program to test above function
",0
850,"return a * x * x + b * x + c
print findRoot ( double a, double b, double c, double low, double high ) and double x
untill fabs ( high - low ) > eps ), x assign to ( low + high ) / 2
if func ( a, b, c, low ) * func ( a, b, c, x ) assign to 0 )  high assign to x
else low assign to x
return x
if func ( a, b, c, A ) * func ( a, b, c, B ) > 0 print No solution
else print fixed print setprecision ( 4 ) print findRoot ( a, b, c, A, B )
declare integer main ( ), double a assign to 2, b assign to -3, c assign to -2, A assign to 0, B assign to 3
solve a, b, c, A, B
return 0
","Find the root of given non decreasing function between A and B 
 C ++ program untill the above approach ; Given function ; Function to find the root of the given non - decreasing Function ; To get the minimum possible answer untill the root ; Find mid ; Search in array of low , x   ; Search in array of x , high   ; Return the required answer ; Function to find the roots of the given equation within range array of a , b   ; If root doesn 't exists ; Else find the root upto 4 decimal places ; Driver Code ; Given range ; Function Call
",1
851,"return a * x * x + b * x + c
print findRoot ( double a, double b, double c, double low, double high ) and double x
untill fabs ( high - low ) > eps ), x assign to ( low + high ) / 2
if func ( a, b, c, low ) * func ( a, b, c, x ) assign to 0 )  high assign to x
else low assign to x
return x
if func ( a, b, c, A ) * func ( a, b, c, B ) > 0 print No solution
else print fixed print setprecision ( 4 ) print findRoot ( a, b, c, A, B )
declare integer main ( ), double a assign to 2, b assign to -3, c assign to -2, A assign to 0, B assign to 3
solve a, b, c, A, B
return 0
","Selection Sort 
 C ++ program untill implementation of selection sort ; swap function ; sort function ; One by one move boundary of unsorted subarray ; Find the minimum element in unsorted array ; Swap the found minimum element with the first element ; Function to print an array ; Driver program to test above functions
",0
852,"create boolean possible ( ll mid, vector  ll > & a ), ll n assign to a. size ( )
set ll total to ( n * ( n - 1 ) ) / 2
set need to ( total + 1 ) / 2
set ll count to 0
set start to 0 and end to 1
untill end  n, increment end if a array of end  - a array of start   assign to mid, increment end
else, count assign to count + ( end - start - 1)
increment start
if end assign to n and start  end and a array of end - 1   - a array of start   assign to mid, set ll t to end - start - 1
increment count by ( t * ( t + 1 ) / 2 ) )
if count >assign to need return true
else return false
ll findMedian is a new vector of ll and a and a new vector of ll n assign to size of a
low, high assign to a array of n - 1   - a array of 0  
untill low assign to high, ll mid assign to ( low + high ) / 2
if possible ( mid, a ) ), high assign to mid - 1
else low assign to mid + 1
return high + 1
declare integer main ( ), vector, ll > a assign to  1, 7, 5, 2  ;
sort a. begin ( ), a. end ( ) )
print findMedian ( a ) and newline
","Median of difference of all pairs from an Array 
 C ++ Program to implement the above approach ; Function check if mid can be median index of the difference array ; Size of the array ; Total possible no of pair possible ; The index of the element in the difference of all pairs from the array ; Count the number of pairs having difference <assign to mid ; If the difference between end and first element is less then or equal to mid ; Checking untill the no of element less than or equal to mid is greater than median or not ; Function to calculate the median of differences of all pairs from the array ; Size of the array ; Initialising the low and high ; Binary search ; Calculate mid ; If mid can be the median of the array ; Returning the median of the differences of pairs from the array ; Driver Code
",1
853,"create boolean possible ( ll mid, vector  ll > & a ), ll n assign to a. size ( )
set ll total to ( n * ( n - 1 ) ) / 2
set need to ( total + 1 ) / 2
set ll count to 0
set start to 0 and end to 1
untill end  n, increment end if a array of end  - a array of start   assign to mid, increment end
else, count assign to count + ( end - start - 1)
increment start
if end assign to n and start  end and a array of end - 1   - a array of start   assign to mid, set ll t to end - start - 1
increment count by ( t * ( t + 1 ) / 2 ) )
if count >assign to need return true
else return false
ll findMedian is a new vector of ll and a and a new vector of ll n assign to size of a
low, high assign to a array of n - 1   - a array of 0  
untill low assign to high, ll mid assign to ( low + high ) / 2
if possible ( mid, a ) ), high assign to mid - 1
else low assign to mid + 1
return high + 1
declare integer main ( ), vector, ll > a assign to  1, 7, 5, 2  ;
sort a. begin ( ), a. end ( ) )
print findMedian ( a ) and newline
","Make all array elements equal by replacing triplets with their Bitwise XOR 
 C ++ program to implement the above approach ; Function to find triplets such that replacing them with their XOR make all array elements equal ; If N is even ; Calculate xor of array elements ; Traverse the array ; Update xor ; If xor is not equal to 0 ; Selecting the triplets such that elements of the pairs ( arr array of 0   , arr array of 1   ) , ( arr array of 2   , arr array of 3   ) . . . can be made equal ; Selecting the triplets such that all array elements can be made equal to arr array of N - 1   ; Selecting the triplets such that elements of the pairs ( arr array of 0   , arr array of 1   ) , ( arr array of 2   , arr array of 3   ) . . . can be made equal ; Selecting the triplets such that all array elements can be made equal to arr array of N - 1   ; Driver Code ; Given array ; Size of array ; Function call
",0
854,"void UniversalSubset ( vector  string > A, vector  string > B )  integer n1 assign to A. size ( )
create integer n2 with n2 assign to size of B
create vector res with string > res
create integer array A_fre with size n1, 26
untill i assign to 0 to n1 exclusive, set A_fre array of i   array of j   to 0
untill i assign to 0 to n1 exclusive, increment j by 1, A array of i   array of A array of i   array of j   -'a' 
create integer B_fre with size 26 with B_fre assign to 0
untill i assign to 0 to n2 exclusive, arr assign to int array of size 26 with 0 elements
untill j assign to 0 to size of j, increment arr array of B array of i  array of j   -'a'   
a'  assign to max ( B_fre array of B array of i   array of j   -'a' , arr array of B array of i   array of j   -'a'  )
untill i assign to 0 to n1 exclusive, flag assign to 0
untill j assign to 0 to 26 exclusive, if A_fre array of i  array of j   B_fre array of j  , flag assign to 1
break loop
if flag is 0, push_back res. push_back ( A array of i   )
if size of res is true, print res array of i   array of j  
print "" ""
else print "" - 1""
declare integer main ( ), vector, string > A assign to geeksuntillgeeks "", topcoder "", leetcode ""
create vector  string > B assign to geek "", "" ee ""
create UniversalSubset ( A, B )
return 0
","Print all Strings from array A array of   having all strings from array B array of   as subsequence 
 C ++ Program to implement the above approach ; Function to find strings from A array of   having all strings in B array of   as subsequence ; Calculate respective sizes ; Stores the answer ; Stores the frequency of each character in strings of A array of   ; Compute the frequencies of characters of all strings ; Stores the frequency of each character in strings of B array of   each character of a string in B array of   ; If the frequency of a character in B array of   exceeds that in A array of   ; A string exists in B array of   which is not a proper subset of A array of i   ; If all strings in B array of   are proper subset of A array of   ; Push the string in resultant vector ; If any string is found ; Print those strings ; Otherwise ; Driver code
",1
855,"void UniversalSubset ( vector  string > A, vector  string > B )  integer n1 assign to A. size ( )
create integer n2 with n2 assign to size of B
create vector res with string > res
create integer array A_fre with size n1, 26
untill i assign to 0 to n1 exclusive, set A_fre array of i   array of j   to 0
untill i assign to 0 to n1 exclusive, increment j by 1, A array of i   array of A array of i   array of j   -'a' 
create integer B_fre with size 26 with B_fre assign to 0
untill i assign to 0 to n2 exclusive, arr assign to int array of size 26 with 0 elements
untill j assign to 0 to size of j, increment arr array of B array of i  array of j   -'a'   
a'  assign to max ( B_fre array of B array of i   array of j   -'a' , arr array of B array of i   array of j   -'a'  )
untill i assign to 0 to n1 exclusive, flag assign to 0
untill j assign to 0 to 26 exclusive, if A_fre array of i  array of j   B_fre array of j  , flag assign to 1
break loop
if flag is 0, push_back res. push_back ( A array of i   )
if size of res is true, print res array of i   array of j  
print "" ""
else print "" - 1""
declare integer main ( ), vector, string > A assign to geeksuntillgeeks "", topcoder "", leetcode ""
create vector  string > B assign to geek "", "" ee ""
create UniversalSubset ( A, B )
return 0
","Remaining array element after repeated removal of the smallest element from pairs with absolute difference of 2 or 0 
 C ++ program untill the above approach ; Function to find the last remaining array element after repeatedly removing the smallest from pairs having absolute difference 2 or 0 ; Sort the given array in ascending order ; Traverse the array ; If difference between adjacent elements is not equal to 0 or 2 ; If operations can be peruntillmed ; Driver Code
",0
856,"declare findPair with integers a array of   and n, min_dist assign to INT_MAX
index_a assign to integer with index_a assign to -1, index_b assign to -1
untill i assign to 0 to n exclusive, increment j if j % a array ofj   is 0 a array ofj   % a array of i   is 0, set min_dist to j - i
set index_a to i
set index_b to j
if index_a is -1 print ( "" - 1"" )
else print "" ( ""  a array of index_a   "", "" a array of index_b    "" ) ""
declare integer main ( ) and integer array a with size   assign to  2, 3, 4, 5, 6
n assign to sizeof ( a ) / sizeof ( a )
call findPair with arguments a and n
","Closest pair in an Array such that one number is multiple of the other 
 C ++ program untill the above approach ; Function to find the minimum distance pair where one is the multiple of the other ; Initialize the variables ; Iterate untill all the elements ; Loop to make pairs ; Check untill minimum distance ; Check if one is a multiple of other ; Update the distance ; Store indexes ; If no such pair exists ; Print the answer ; Driver Code ; Given array arr array of   ; Function Call
",1
857,"declare findPair with integers a array of   and n, min_dist assign to INT_MAX
index_a assign to integer with index_a assign to -1, index_b assign to -1
untill i assign to 0 to n exclusive, increment j if j % a array ofj   is 0 a array ofj   % a array of i   is 0, set min_dist to j - i
set index_a to i
set index_b to j
if index_a is -1 print ( "" - 1"" )
else print "" ( ""  a array of index_a   "", "" a array of index_b    "" ) ""
declare integer main ( ) and integer array a with size   assign to  2, 3, 4, 5, 6
n assign to sizeof ( a ) / sizeof ( a )
call findPair with arguments a and n
","Minimum Cost required to generate a balanced Bracket Sequence 
 C ++ Program to implement the above approach ; Function to calculate the minimum cost required to generate a balanced bracket sequence ; Stores the count of unbalanced open brackets ; Stores the count of unbalanced closed brackets ; Stores the count of open brackets ; Stores the count of closed brackets ; If open brace is encountered ; Otherwise ; If no unbalanced open brackets are present ; Increase count of unbalanced closed brackets ; Otherwise ; Reduce count of unbalanced open brackets ; Increase count of closed brackets ; Calculate lower bound of minimum cost ; Reduce excess open or closed brackets to prevent counting them twice ; Update answer by adding minimum of removing both unbalanced open and closed brackets or inserting closed unbalanced brackets to end of string ; Print the result ; Driver Code
",0
858,"untill i assign to L to R inclusive, temp assign to i
c assign to integer with c assign to 10
create integer flag with flag assign to 0
untill temp > 0, if temp modulo 10 >assign to c, set flag to 1
break loop
c assign to temp modulo 10
divide temp by 10
if flag is 0, print i and "" ""
let L, R be integers with L assign to 10 and R assign to 15
printNum ( L, R )
return 0
","Print all numbers in given range having digits in strictly increasing order 
 C ++ program untill the above approach ; Function to print all numbers in the range array of L , R   having digits in strictly increasing order ; Iterate over the range ; Iterate over the digits ; Check if the current digit is >assign to the previous digit ; If the digits are in ascending order ; Driver Code ; Given range L and R ; Function Call
",1
859,"untill i assign to L to R inclusive, temp assign to i
c assign to integer with c assign to 10
create integer flag with flag assign to 0
untill temp > 0, if temp modulo 10 >assign to c, set flag to 1
break loop
c assign to temp modulo 10
divide temp by 10
if flag is 0, print i and "" ""
let L, R be integers with L assign to 10 and R assign to 15
printNum ( L, R )
return 0
","Check if a given string can be converted to another by given possible swaps 
 C ++ program to implement the above approach ; Stores length of str1 ; Stores length of str2 ; Stores distinct characters of str1 ; Stores distinct characters of str2 ; Stores frequency of each character of str1 ; Traverse the string str1 ; Update frequency of str1 array of i   ; Traverse the string str1 ; Insert str1 array of i   into st1 ; Traverse the string str2 ; Insert str1 array of i   into st1 ; If distinct characters in str1 and str2 are not same ; Stores frequency of each character of str2 ; Traverse the string str2 ; Update frequency of str2 array of i   ; Sort hash1 array of   array ; Sort hash2 array of   array ; Traverse hash1 array of   and hash2 array of   ; If hash1 array of i   not equal to hash2 array of i   ; Driver Code
",0
860,"if right is less than or equal to left, return INT_MAX
mid assign to integer with mid assign to left + ( right - left ) / 2
if arr array of mid + 1   - arr array of mid   is not diff, return ( arr array of mid   + diff )
if mid > 0 and arr array of mid   - arr array of mid - 1   is not diff, return ( arr array of mid - 1   + diff )
if arr array of mid  is arr array of 0   + mid * diff, return findMissing ( arr, mid + 1, right, diff )
return findMissing ( arr, left, mid - 1, diff )
declare missingElement with integer arr array of  , integer n, sort ( arr, arr + n ) as arguments
diff assign to integer with diff assign to ( arr array of n - 1   - arr array of 0   ) / n
return findMissing ( arr, 0, n - 1, diff )
declare integer main ( ), integer arr array of   assign to  2, 8, 6, 10  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print missingElement ( arr, n )
return 0
","Find the missing number in unordered Arithmetic Progression 
 C ++ program untill the above approach ; Function to find the missing element ; Fix left and right boundary untill binary search ; Find index of middle element ; Check if the element just after the middle element is missing ; Check if the element just beuntille mid is missing ; Check if the elements till mid follow the AP , then recur untill right half ; Else recur untill left half ; Function to find the missing element in AP series ; Sort the array arr array of   ; Calculate Common Difference ; Binary search untill the missing ; Driver Code ; Given array arr array of   ; Function Call
",1
861,"if right is less than or equal to left, return INT_MAX
mid assign to integer with mid assign to left + ( right - left ) / 2
if arr array of mid + 1   - arr array of mid   is not diff, return ( arr array of mid   + diff )
if mid > 0 and arr array of mid   - arr array of mid - 1   is not diff, return ( arr array of mid - 1   + diff )
if arr array of mid  is arr array of 0   + mid * diff, return findMissing ( arr, mid + 1, right, diff )
return findMissing ( arr, left, mid - 1, diff )
declare missingElement with integer arr array of  , integer n, sort ( arr, arr + n ) as arguments
diff assign to integer with diff assign to ( arr array of n - 1   - arr array of 0   ) / n
return findMissing ( arr, 0, n - 1, diff )
declare integer main ( ), integer arr array of   assign to  2, 8, 6, 10  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print missingElement ( arr, n )
return 0
","Program to find the largest and smallest ASCII valued characters in a string 
 C ++ program to find largest and smallest characters in a string . ; function that return the largest alphabet . ; initializing max alphabet to ' a ' ; find largest alphabet ; returning largest element ; function that return the smallest alphabet ; initializing smallest alphabet to ' z ' ; find smallest alphabet ; returning smallest alphabet ; Driver Code ; Character array ; Calculating size of the string ; calling functions and print returned value
",0
862,"declare power with integers x, y as arguments, returning integer
if y is 0, return 1
temp assign to power ( x, y / 2 )
if y modulo 2 is 0, return temp * temp
else return x * temp * temp
nthRootSearch is a new integer function with integer arguments low, high, N and K, if low is less than or equal to high, mid is a new integer variable with value low + high / 2
if power ( mid, K ) assign to N ) and power ( mid + 1, K ) > N ) return mid
else if power ( mid, K )  N, return nthRootSearch ( mid + 1, high, N, K )
else return nthRootSearch ( low, mid - 1, N, K )
return low
declare integer main ( ), integer N assign to 16 and K assign to 4
print nthRootSearch ( 0, N, N, N, K )
return 0
","Floor value Kth root of a number using Recursive Binary Search 
 C ++ program untill the above approach ; Function to calculate x raised to the power y in O ( logn ) ; Function to find the Kth root of the number N using BS ; If the range is still valid ; Find the mid - value of range ; Base Case ; Condition to check if the left search space is useless ; Driver Code ; Given N and K ; Function Call
",1
863,"declare power with integers x, y as arguments, returning integer
if y is 0, return 1
temp assign to power ( x, y / 2 )
if y modulo 2 is 0, return temp * temp
else return x * temp * temp
nthRootSearch is a new integer function with integer arguments low, high, N and K, if low is less than or equal to high, mid is a new integer variable with value low + high / 2
if power ( mid, K ) assign to N ) and power ( mid + 1, K ) > N ) return mid
else if power ( mid, K )  N, return nthRootSearch ( mid + 1, high, N, K )
else return nthRootSearch ( low, mid - 1, N, K )
return low
declare integer main ( ), integer N assign to 16 and K assign to 4
print nthRootSearch ( 0, N, N, N, K )
return 0
","Check if right triangle possible from given area and hypotenuse 
 C ++ program to check existence of right triangle . ; Prints three sides of a right triangle from given area and hypotenuse if triangle is possible , else prints - 1. ; Descriminant of the equation ; applying the linear equation untillmula to find both the roots ; Driver code
",0
864,"sort in integers get_subset_count ( int arr array of  , K, N ) and sort ( arr, arr + N )
declare integers left and right
set left to 0
set right to N - 1
ans assign to integer with ans assign to 0
untill left assign to right, increment ans by 1 and ( right - left ) if arr array of left  + arr array of right    K, increment ans by 1
increment left
else, right assign to right
return ans
declare integer main ( ), integer arr array of   assign to  2, 4, 5, 7  ;
K assign to integer with K assign to 8
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print get_subset_count ( arr, K, N)
return 0
","Count of subsets having sum of min and max element less than K 
 C ++ program to print count of subsets S such that min ( S ) + max ( S ) < K ; Function that return the count of subset such that min ( S ) + max ( S ) < K ; Sorting the array ; ans stores total number of subsets ; add all possible subsets between i and j ; Decrease the sum ; Driver code
",1
865,"sort in integers get_subset_count ( int arr array of  , K, N ) and sort ( arr, arr + N )
declare integers left and right
set left to 0
set right to N - 1
ans assign to integer with ans assign to 0
untill left assign to right, increment ans by 1 and ( right - left ) if arr array of left  + arr array of right    K, increment ans by 1
increment left
else, right assign to right
return ans
declare integer main ( ), integer arr array of   assign to  2, 4, 5, 7  ;
K assign to integer with K assign to 8
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print get_subset_count ( arr, K, N)
return 0
","Print all elements in sorted order from row and column wise sorted matrix 
 A C ++ program to Print all elements in sorted order from row and column wise sorted matrix ; A utility function to youngify a Young Tableau . This is different from standard youngify . It assumes that the value at mat array of 0   array of 0   is infinite . ; Find the values at down and right sides of mat array of i   array of j   ; If mat array of i   array of j   is the down right corner element , return ; Move the smaller of two values ( downVal and rightVal ) to mat array of i   array of j   and recur untill smaller value ; A utility function to extract minimum element from Young tableau ; This function uses extractMin ( ) to print elements in sorted order ; driver program to test above function
",0
866,"minMaxDiff assign to integer with arr array of  , n, k assign to integer, max_adj_dif assign to INT_MIN
untill i assign to 0 to n - 1 exclusive, max_adj_dif assign to max ( max_adj_dif, abs ( arr array of i   - arr array of i + 1   ) )
if max_adj_dif is 0, return 0
create integer best with best assign to 1
declare integer worst assign to max_adj_dif
mid, required assign to integers
untill best  worst, mid assign to best + worst / 2
set required to 0
untill i assign to 0 to n - 1 exclusive, increment required by ( abs ( arr array of i   - arr array of i + 1   ) - 1 ) / mid
if required is greater than k, set best to mid + 1
else worst assign to mid
return worst
declare integer main ( ), integer arr assign to  3, 12, 25, 50  ; declare integer array arr assign to  3, 12, 25, 50
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create integer k with k assign to 7
print minMaxDiff ( arr, n, k )
return 0
","Minimize the maximum difference of adjacent elements after at most K insertions 
 C ++ Program to find the minimum of maximum differerence between adjacent elements after at most K insertions ; Calculate the maximum adjacent difference ; If the maximum adjacent difference is already zero ; best and worst specifies range of the maximum adjacent difference ; To store the no of insertions required untill respective values of mid ; If the number of insertions required exceeds K ; Otherwise ; Driver code
",1
867,"minMaxDiff assign to integer with arr array of  , n, k assign to integer, max_adj_dif assign to INT_MIN
untill i assign to 0 to n - 1 exclusive, max_adj_dif assign to max ( max_adj_dif, abs ( arr array of i   - arr array of i + 1   ) )
if max_adj_dif is 0, return 0
create integer best with best assign to 1
declare integer worst assign to max_adj_dif
mid, required assign to integers
untill best  worst, mid assign to best + worst / 2
set required to 0
untill i assign to 0 to n - 1 exclusive, increment required by ( abs ( arr array of i   - arr array of i + 1   ) - 1 ) / mid
if required is greater than k, set best to mid + 1
else worst assign to mid
return worst
declare integer main ( ), integer arr assign to  3, 12, 25, 50  ; declare integer array arr assign to  3, 12, 25, 50
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create integer k with k assign to 7
print minMaxDiff ( arr, n, k )
return 0
","Sum of all the prime divisors of a number 
 C ++ program to find sum of prime divisors of N ; Function to check if the number is prime or not . ; Corner cases ; This is checked so that we can skip middle five numbers in below loop ; function to find sum of prime divisors of N ; return type of sqrt function if float ; both factors are same ; both factors are not same ( i and n / i ) ; Driver code
",0
868,"declare checkMin with integer arr array of  , len as arguments, returning integer, set smallest to INT_MAX, secondSmallest to INT_MAX
untill i assign to 0 to len exclusive, if arr array of i   is less than smallest, set secondSmallest to smallest
let smallest be arr array of i  
else if arr array of i   is less than secondSmallest, set secondSmallest to arr array of i  
if 2 * smallest assign to secondSmallest, print Yes
else print No
declare integer main ( ), integer arr array of   assign to  2, 3, 4, 5  ;
create integer len with len assign to sizeof ( arr ) / sizeof ( arr array of 0   )
checkMin is a new function
","Check if minimum element in array is less than or equals half of every other element 
 C ++ implementation to Check if the minimum element in the array is greater than or equal to half of every other elements ; Function to Check if the minimum element in the array is greater than or equal to half of every other element ; Initialise the variables to store smallest and second smallest ; Check if current element is smaller than smallest , the current smallest will become secondSmallest and current element will be the new smallest ; Check if current element is smaller than secondSmallest simply update the latter ; Driver code
",1
869,"declare checkMin with integer arr array of  , len as arguments, returning integer, set smallest to INT_MAX, secondSmallest to INT_MAX
untill i assign to 0 to len exclusive, if arr array of i   is less than smallest, set secondSmallest to smallest
let smallest be arr array of i  
else if arr array of i   is less than secondSmallest, set secondSmallest to arr array of i  
if 2 * smallest assign to secondSmallest, print Yes
else print No
declare integer main ( ), integer arr array of   assign to  2, 3, 4, 5  ;
create integer len with len assign to sizeof ( arr ) / sizeof ( arr array of 0   )
checkMin is a new function
","Count set bits in an integer 
 C ++ program to demonstrate __builtin_popcount ( ) ; Driver code
",0
870,"createHash is a void function with int arguments > & hash and maxElement, set prev and curr to 1
insert prev into hash
insert curr into hash
untill curr assign to maxElement, temp assign to curr + prev
insert temp in hash
set prev to curr
set curr to temp
declare fibonacci with integer arr array of  , integer n, max_val assign to * max_element ( arr, arr + n ) as arguments
create integer set with int > hash
createHash ( hash, max_val )
minimum assign to integer with minimum assign to INT_MAX
create integer maximum with maximum assign to INT_MIN
untill i assign to 0 to n exclusive, if hash. find ( arr array of i   ) is not hash. end ( ) ), minimum assign to min ( minimum, arr array of i   )
let maximum be maximum ( maximum, arr array of i   )
print minimum, "", "", maximum and a new line
declare integer main ( ) and integer arr array of   assign to  1, 2, 3, 4, 5, 6, 7
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
fibonacci ( arr, n )
return 0
","Largest and smallest Fibonacci numbers in an Array 
 C ++ program to find minimum and maximum fibonacci number in given array ; Function to create hash table to check Fibonacci numbers ; Insert initial two numbers in the hash table ; Sum of previous two numbers ; Update the variable each time ; Function to find minimum and maximum fibonacci number in given array ; Find maximum value in the array ; Creating a set containing all Fibonacci numbers up to maximum value in the array ; For storing the Minimum and Maximum Fibonacci number ; Check if current element is a fibonacci number ; Update the maximum and minimum accordingly ; Driver code
",1
871,"createHash is a void function with int arguments > & hash and maxElement, set prev and curr to 1
insert prev into hash
insert curr into hash
untill curr assign to maxElement, temp assign to curr + prev
insert temp in hash
set prev to curr
set curr to temp
declare fibonacci with integer arr array of  , integer n, max_val assign to * max_element ( arr, arr + n ) as arguments
create integer set with int > hash
createHash ( hash, max_val )
minimum assign to integer with minimum assign to INT_MAX
create integer maximum with maximum assign to INT_MIN
untill i assign to 0 to n exclusive, if hash. find ( arr array of i   ) is not hash. end ( ) ), minimum assign to min ( minimum, arr array of i   )
let maximum be maximum ( maximum, arr array of i   )
print minimum, "", "", maximum and a new line
declare integer main ( ) and integer arr array of   assign to  1, 2, 3, 4, 5, 6, 7
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
fibonacci ( arr, n )
return 0
","Lexicographically smallest and largest anagrams of a string containing another string as its substring 
 C ++ program untill the above approach ; Function to find the lexicographically smallest anagram of string which contains another string ; Initializing the map and set ; Iterating over s1 ; Storing the frequency of characters present in s1 ; Storing the distinct characters present in s1 ; Decreasing the frequency of characters from M that are already present in s2 ; Traversing alphabets in sorted order ; If current character of set is not equal to current character of s2 ; If element is equal to current character of s2 ; Checking untill second distinct character in s2 ; s2 array of j   will store second distinct character ; Return the answer ; Function to find the lexicographically largest anagram of string which contains another string ; Getting the lexicographically smallest anagram ; d1 stores the prefix ; d2 stores the suffix ; Return the result ; Driver Code ; Given two strings ; Function Calls
",0
872,"create boolean isValidLen with string s, integer len, integer k, n assign to size of s
create ansdered_map  char, integer > mp
right assign to integer with right assign to 0
untill right is less than len, increment mp array of s array of right  
increment right
if size of mp is less than or equal to k, return true
untill right is less than n, increment mp array of s array of right  
decrement mp array of s array of right - len  
if mp array of s array of right - len     is 0, erase ( s array of right - len   )
if size of mp is less than or equal to k, return true
increment right
return size of mp, k
create integer maxLenSubStr ( string s, integer k) and set, create char > uni
insert x in uni
if size of uni  k return -1
create integer n with n assign to size of s
declare integers lo assign to -1, hi assign to n + 1
untill hi - lo > 1, mid assign to int with mid assign to lo + hi >> 1
if isValidLen ( s, mid, k ) ), lo assign to mid
else hi assign to mid
return lo
declare integer main ( ) and string s assign to "" aabacbebebebe ""
create integer k with k assign to 3
print maxLenSubStr ( s, k )
return 0
","Longest substring with K unique characters using Binary Search 
 C ++ implementation of the approach ; Function that returns true if there is a substring of length len with <assign to k unique characters ; Size of the string ; Map to store the characters and their frequency ; Update the map untill the first substring ; Check untill the rest of the substrings ; Add the new character ; Remove the first character of the previous window ; Update the map ; Function to return the length of the longest substring which has K unique characters ; Check if the complete string contains K unique characters ; Size of the string ; Apply binary search ; Driver code
",1
873,"create boolean isValidLen with string s, integer len, integer k, n assign to size of s
create ansdered_map  char, integer > mp
right assign to integer with right assign to 0
untill right is less than len, increment mp array of s array of right  
increment right
if size of mp is less than or equal to k, return true
untill right is less than n, increment mp array of s array of right  
decrement mp array of s array of right - len  
if mp array of s array of right - len     is 0, erase ( s array of right - len   )
if size of mp is less than or equal to k, return true
increment right
return size of mp, k
create integer maxLenSubStr ( string s, integer k) and set, create char > uni
insert x in uni
if size of uni  k return -1
create integer n with n assign to size of s
declare integers lo assign to -1, hi assign to n + 1
untill hi - lo > 1, mid assign to int with mid assign to lo + hi >> 1
if isValidLen ( s, mid, k ) ), lo assign to mid
else hi assign to mid
return lo
declare integer main ( ) and string s assign to "" aabacbebebebe ""
create integer k with k assign to 3
print maxLenSubStr ( s, k )
return 0
","Counting sets of 1 s and 0 s in a binary matrix 
 CPP program to compute number of sets in a binary matrix . ; no of columns ; no of rows ; function to calculate the number of non empty sets of cell ; stores the final answer ; traverses row - wise ; traverses column wise ; at the end subtract n * m as no of single sets have been added twice . ; driver program to test the above function .
",0
874,"declare isSquarePossible with integer arr array of  , integer n, integer l, cnt assign to 0
untill i assign to 0 to n exclusive, increment cnt by 1 if arr array of i   >assign to l
if cnt >assign to l return true
return false
declare integer variable maxArea with integer arr array of  , integer n, integer l assign to 0 and r assign to n
create integer len with len assign to 0
untill l assign to r, set m to l + ( ( r - l ) / 2 )
if isSquarePossible ( arr, n, m ) is true, len assign to m
l assign to m + 1
else r assign to m - 1
return ( len * len )
declare integer main ( ), integer arr array of   assign to  1, 3, 4, 5, 5  ;
n assign to sizeof ( arr ) / sizeof ( int )
print maxArea ( arr, n )
return 0
","Largest area square in an array when elements can be shuffled 
 C ++ implementation of the approach ; Function that returns true if it is possible to make a square with side equal to l ; To store the count of elements greater than or equal to l ; Increment the count ; If the count becomes greater than or equal to l ; Function to return the maximum area of the square that can be obtained ; If square is possible with side length m ; Try to find a square with smaller side length ; Return the area ; Driver code
",1
875,"declare isSquarePossible with integer arr array of  , integer n, integer l, cnt assign to 0
untill i assign to 0 to n exclusive, increment cnt by 1 if arr array of i   >assign to l
if cnt >assign to l return true
return false
declare integer variable maxArea with integer arr array of  , integer n, integer l assign to 0 and r assign to n
create integer len with len assign to 0
untill l assign to r, set m to l + ( ( r - l ) / 2 )
if isSquarePossible ( arr, n, m ) is true, len assign to m
l assign to m + 1
else r assign to m - 1
return ( len * len )
declare integer main ( ), integer arr array of   assign to  1, 3, 4, 5, 5  ;
n assign to sizeof ( arr ) / sizeof ( int )
print maxArea ( arr, n )
return 0
","Insert minimum number in array so that sum of array becomes prime 
 C ++ program to find minimum number to insert in array so their sum is prime ; Array to store primes ; function to calculate primes using sieve of eratosthenes ; Find prime number greater than a number ; To return prime number greater than n ; check if num is prime ; increment num ; To find number to be added so sum of array is prime ; call sieveOfEratostheneses to calculate primes ; To find sum of array elements ; To find prime number greater then sum ; Return difference of sum and num ; Driver Code
",0
876,"declare insertNames with string arr array of  , integer n as arguments, returning void, setting certaindered_set to undered_set with string > set
untill i assign to 0 to n exclusive, print No STRNEWLINE
insert arr array of i  
else print Yes STRNEWLINE
create integer main, create integer arr with arr assign to geeks "", "" untill "", "" geeks ""
create integer n with n assign to sizeof ( arr ) / sizeof ( string )
insertNames ( arr, n )
return 0
","Check duplicates in a stream of strings 
 C ++ implementation of the approach ; Function to insert the names and check whether they appear untill the first time ; To store the names of the employees ; If current name is appearing untill the first time ; Driver code
",1
877,"declare insertNames with string arr array of  , integer n as arguments, returning void, setting certaindered_set to undered_set with string > set
untill i assign to 0 to n exclusive, print No STRNEWLINE
insert arr array of i  
else print Yes STRNEWLINE
create integer main, create integer arr with arr assign to geeks "", "" untill "", "" geeks ""
create integer n with n assign to sizeof ( arr ) / sizeof ( string )
insertNames ( arr, n )
return 0
","Find the sum of first N odd Fibonacci numbers 
 CPP program to Find the sum of first N odd Fibonacci numbers ; Function to calculate sum of first N odd Fibonacci numbers ; base values ; Driver code
",0
878,"declare countLessThan with integer arr array of  , integer n, integer key, l assign to 0 and r assign to n - 1
index assign to integer with index assign to -1
untill l assign to r, set m to ( l + r ) / 2
if arr array of m   is less than key, set l to m + 1
set index to m
else r assign to m - 1
return index + 1
declare countGreaterThan with integer arr array of  , integer n, integer key, l assign to 0 and r assign to n - 1
index assign to integer with index assign to -1
untill l assign to r, set m to ( l + r ) / 2
if arr array of m   assign to key, l assign to m + 1
else r assign to m - 1
set index to m
if index is -1, return 0
return ( n - index )
countTriplets is a new function with integer arguments n, a + n
sort b, b + n
sort c, c + n
create integer count with count assign to 0
untill i assign to 0 to n exclusive, current assign to b array of i  
create integers a_index assign to -1, c_index assign to -1
low assign to integer with low assign to countLessThan ( a, n, current )
create integer high with high assign to countGreaterThan ( c, n, current )
increment count by low * high
return count
declare integer main ( ), integer array a with size   assign to  1, 5
create integer b with b assign to  2, 4  ;
create integer c with c assign to  3, 6  ;
size assign to integer with size assign to sizeof ( a ) / sizeof ( a array of 0   )
print countTriplets ( size, a, b, c )
return 0
","Count the triplets such that A array of i   < B array of j   < C array of k   
 C ++ implementation of the approach ; Function to return the count of elements in arr array of   which are less than the given key ; Modified binary search ; Function to return the count of elements in arr array of   which are greater than the given key ; Modified binary search ; Function to return the count of the required triplets ; Sort all three arrays ; Iterate untill all the elements of array B ; Count of elements in A array of   which are less than the chosen element from B array of   ; Count of elements in C array of   which are greater than the chosen element from B array of   ; Update the count ; Driver code
",1
879,"declare countLessThan with integer arr array of  , integer n, integer key, l assign to 0 and r assign to n - 1
index assign to integer with index assign to -1
untill l assign to r, set m to ( l + r ) / 2
if arr array of m   is less than key, set l to m + 1
set index to m
else r assign to m - 1
return index + 1
declare countGreaterThan with integer arr array of  , integer n, integer key, l assign to 0 and r assign to n - 1
index assign to integer with index assign to -1
untill l assign to r, set m to ( l + r ) / 2
if arr array of m   assign to key, l assign to m + 1
else r assign to m - 1
set index to m
if index is -1, return 0
return ( n - index )
countTriplets is a new function with integer arguments n, a + n
sort b, b + n
sort c, c + n
create integer count with count assign to 0
untill i assign to 0 to n exclusive, current assign to b array of i  
create integers a_index assign to -1, c_index assign to -1
low assign to integer with low assign to countLessThan ( a, n, current )
create integer high with high assign to countGreaterThan ( c, n, current )
increment count by low * high
return count
declare integer main ( ), integer array a with size   assign to  1, 5
create integer b with b assign to  2, 4  ;
create integer c with c assign to  3, 6  ;
size assign to integer with size assign to sizeof ( a ) / sizeof ( a array of 0   )
print countTriplets ( size, a, b, c )
return 0
","Check whether Arithmetic Progression can be untillmed from the given array 
 C ++ program to check if a given array can untillm arithmetic progression ; Returns true if a permutation of arr array of 0. . n - 1   can untillm arithmetic progression ; Find the smallest and and update second smallest ; Find second smallest ; Check if the duplicate element found or not ; If duplicate found then return false ; Find the difference between smallest and second smallest ; As we have used smallest and second smallest , so we should now only check untill n - 2 elements ; Driven Program
",0
880,"if length of s is 0, print 0
ans assign to integer with ans assign to 0
create integers o, c with o assign to 0 and c assign to 0
untill i assign to 0 to length of s, i  s. length ( ), i ++ ) if s array of i   is'(') o ++, if s array of i   is'), increment c
if o is not c, return -1
create integer a with size size ( s ) )
if s array of0  is'(' ), a array of 0   is'(') ; else a array of 0   is a array of i - 1   + 1 ; else a array of i   is a array of i - 1   - 1 ; return ans ; s is a new string array of integers ( ( ) ) ) ) ; print costToBa
","Cost to Balance the parentheses 
 CPP code to calculate the minimum cost to make the given parentheses balanced ; To store absolute count of balanced and unbalanced parenthesis ; o ( open bracket ) stores count of ' ( ' and c ( close bracket ) stores count of ' ) ' ; Driver code
",1
881,"if length of s is 0, print 0
ans assign to integer with ans assign to 0
create integers o, c with o assign to 0 and c assign to 0
untill i assign to 0 to length of s, i  s. length ( ), i ++ ) if s array of i   is'(') o ++, if s array of i   is'), increment c
if o is not c, return -1
create integer a with size size ( s ) )
if s array of0  is'(' ), a array of 0   is'(') ; else a array of 0   is a array of i - 1   + 1 ; else a array of i   is a array of i - 1   - 1 ; return ans ; s is a new string array of integers ( ( ) ) ) ) ; print costToBa
","Sgn value of a polynomial 
 CPP program to find sign value of a polynomial ; returns value of poly array of 0   x ( n - 1 ) + poly array of 1   x ( n - 2 ) + . . + poly array of n - 1   ; Evaluate value of polynomial using Horner 's method ; Returns sign value of polynomial ; Driver program to test above function . ; Let us evaluate value of 2 x3 - 6 x2 + 2 x - 1 untill x assign to 3
",0
882,"middleOfThree assign to integer with a, b, c assign to integer, x assign to a - b
create integer y with y assign to b - c
create integer z with z assign to a - c
if x * y is greater than 0, return b
else if x * z is greater than 0, return c
else return a
declare integer main ( ), integers a assign to 20, b assign to 30, c assign to 40
print middleOfThree ( a, b, c )
return 0
","Middle of three using minimum comparisons 
 CPP program to find middle of three distinct numbers ; Function to find the middle of three number ; x is positive if a is greater than b . x is negative if b is greater than a . ; Similar to x ; Similar to x and y . ; Checking if b is middle ( x and y both are positive ) ; Checking if c is middle ( x and z both are positive ) ; Driver Code
",1
883,"middleOfThree assign to integer with a, b, c assign to integer, x assign to a - b
create integer y with y assign to b - c
create integer z with z assign to a - c
if x * y is greater than 0, return b
else if x * z is greater than 0, return c
else return a
declare integer main ( ), integers a assign to 20, b assign to 30, c assign to 40
print middleOfThree ( a, b, c )
return 0
","Smallest divisor of N closest to X 
 C ++ program untill the above approach ; Function to find the divisor of N closest to the target ; Iterate till square root of N ; Check if divisors are equal ; Check if i is the closest ; Check if i is the closest ; Check if n / i is the closest ; Print the closest value ; Driver Code ; Given N & X ; Function Call
",0
884,"declare missing4 with integer arr array of  , n as arguments, returning integer helper array of 4  
untill i assign to 0 to n exclusive, temp assign to abs ( arr array of i   )
if temp assign to n, arr array of temp - 1  *assign to ( -1 )
else if temp > n, if temp % n is not 0, helper array of temp % n - 1   assign to -1
else helper array of ( temp % n ) + n - 1   assign to -1
print ( i + 1 ) and "" "" if arr array of i   is greater than 0, if arr array of i   is greater than 0, then print ""
untill i assign to 0 to 4 exclusive, print ( n + i + 1 ) and "" ""
return
declare integer main ( ) and integer array arr with arr assign to  1, 7, 3, 12, 5, 10, 8, 4, 9
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
missing4 ( arr, n )
return 0
","Find four missing numbers in an array containing elements from 1 to N 
 CPP program to find missing 4 elements in an array of size N where elements are in range from 1 to N + 4. ; Finds missing 4 numbers in O ( N ) time and O ( 1 ) auxiliary space . ; To keep track of 4 possible numbers greater than length of input array In Java , helper is automatically initialized as 0. ; Traverse the input array and mark visited elements either by marking them as negative in arr array of   or in helper array of   . ; If element is smaller than or equal to length , mark its presence in arr array of   ; Mark presence in helper array of   ; Print all those elements whose presence is not marked . ; Driver code
",1
885,"declare missing4 with integer arr array of  , n as arguments, returning integer helper array of 4  
untill i assign to 0 to n exclusive, temp assign to abs ( arr array of i   )
if temp assign to n, arr array of temp - 1  *assign to ( -1 )
else if temp > n, if temp % n is not 0, helper array of temp % n - 1   assign to -1
else helper array of ( temp % n ) + n - 1   assign to -1
print ( i + 1 ) and "" "" if arr array of i   is greater than 0, if arr array of i   is greater than 0, then print ""
untill i assign to 0 to 4 exclusive, print ( n + i + 1 ) and "" ""
return
declare integer main ( ) and integer array arr with arr assign to  1, 7, 3, 12, 5, 10, 8, 4, 9
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
missing4 ( arr, n )
return 0
","Maximum sum such that no two elements are adjacent 
 c ++ program untill the above approach ; Function to return max sum such that no two elements are adjacent ; current max excluding i ; current max including i ; return max of incl and excl ; Driver program to test above functions
",0
886,"if K modulo 2 is 0, print K / 2 and "" ""
untill i assign to 0 to N - 1 exclusive, print K and "" ""
print "" STRNEWLINE ""
exit 0
create vector a integer with a value ( N, K + 1 ) / 2 )
untill i assign to 0 to N / 2 exclusive, if a. back ( ) is 1, pop_back ( ), a.
else
untill ( integer ) a. size ( )  N )  push_back ( K )
print i and "" "" to the standard output
print "" STRNEWLINE ""
declare integer main ( ), K assign to 2 and N assign to 4
let lexiMiddleSmallest ( K, N ) be lexiMiddleSmallest
return 0
","Permutation present at the middle of lexicographic ordering of permutations of at most length N made up integers up to K 
 C ++ program untill the above approach ; Function that finds the middle the lexicographical smallest sequence ; If K is even ; First element is K / 2 ; Remaining elements of the sequence are all integer K ; Stores the sequence when K is odd ; Iterate over the range array of 0 , N / 2   ; Check if the sequence ends with in 1 or not ; Remove the sequence ending in 1 ; If it doesn 't end in 1 ; Decrement by 1 ; Insert K to the sequence till its size is N ; Print the sequence stored in the vector ; Driver Code
",1
887,"if K modulo 2 is 0, print K / 2 and "" ""
untill i assign to 0 to N - 1 exclusive, print K and "" ""
print "" STRNEWLINE ""
exit 0
create vector a integer with a value ( N, K + 1 ) / 2 )
untill i assign to 0 to N / 2 exclusive, if a. back ( ) is 1, pop_back ( ), a.
else
untill ( integer ) a. size ( )  N )  push_back ( K )
print i and "" "" to the standard output
print "" STRNEWLINE ""
declare integer main ( ), K assign to 2 and N assign to 4
let lexiMiddleSmallest ( K, N ) be lexiMiddleSmallest
return 0
","Remove characters from a String that appears exactly K times 
 C ++ program to remove characters from a String that appears exactly K times ; Function to reduce the string by removing the characters which appears exactly k times ; Hash table initialised to 0 ; Increment the frequency of the character ; To store answer ; Next index in reduced string ; Append the characters which appears exactly k times ; Driver code ; Function call
",0
888,"declare findLastElement with integer arr array of  , integer N, sort ( arr, arr + N ) as arguments
create integer i with i assign to 0
untill i assign to 1 to N exclusive, print "" - 1"" print newline
return
print arr array of N - 1 
declare integer main ( ), integer arr array of   assign to  2, 4, 6, 8, 0, 8  ;
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
declare findLastElement with arr, N as arguments
return 0
","Remaining array element after repeated removal of the smallest element from pairs with absolute difference of 2 or 0 
 C ++ program untill the above approach ; Function to find the last remaining array element after repeatedly removing the smallest from pairs having absolute difference 2 or 0 ; Sort the given array in ascending order ; Traverse the array ; If difference between adjacent elements is not equal to 0 or 2 ; If operations can be peruntillmed ; Driver Code
",1
889,"declare findLastElement with integer arr array of  , integer N, sort ( arr, arr + N ) as arguments
create integer i with i assign to 0
untill i assign to 1 to N exclusive, print "" - 1"" print newline
return
print arr array of N - 1 
declare integer main ( ), integer arr array of   assign to  2, 4, 6, 8, 0, 8  ;
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
declare findLastElement with arr, N as arguments
return 0
","Difference between Insertion sort and Selection sort 
 C ++ program untill the insertion sort ; Function to sort an array using insertion sort ; Move elements of arr array of 0. . i - 1   , that are greater than key to one position ahead of their current position ; Function to print an array of size N ; Print the array ; Driver Code ; Function Call
",0
890,"create void maxDivisions ( int arr array of  , int N, int X) sort ( arr, arr + N, greater  int > ( ) )
create integer maxSub with maxSub assign to 0
size assign to integer with size assign to 0
untill i assign to 0 to N exclusive, increment size by 1
if arr array of i   * size >assign to X, increment maxSub
set size to 0
print maxSub
declare integer main ( ), integer arr array of   assign to  1, 3, 3, 7  ;
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create integer X with X assign to 3
maxDivisions ( arr, N, X )
return 0
","Maximize count of subsets into which the given array can be split such that it satisfies the given condition 
 C ++ program untill the above approach ; Function to count maximum subsets into which the given array can be split such that it satisfies the given condition ; Sort the array in decreasing order ; Stores count of subsets possible ; Stores count of elements in current subset ; Traverse the array arr array of   ; Update size ; If product of the smallest element present in the current subset and size of current subset is >assign to K ; Update maxSub ; Update size ; Driver Code ; Given array ; Size of the array ; Given value of X
",1
891,"create void maxDivisions ( int arr array of  , int N, int X) sort ( arr, arr + N, greater  int > ( ) )
create integer maxSub with maxSub assign to 0
size assign to integer with size assign to 0
untill i assign to 0 to N exclusive, increment size by 1
if arr array of i   * size >assign to X, increment maxSub
set size to 0
print maxSub
declare integer main ( ), integer arr array of   assign to  1, 3, 3, 7  ;
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create integer X with X assign to 3
maxDivisions ( arr, N, X )
return 0
","Check if the first and last digit of the smallest number untillms a prime 
 C ++ implementation of above approach ; function to check prime ; Function to generate smallest possible number with given digits ; Declare a hash array of size 10 and initialize all the elements to zero ; store the number of occurrences of the digits in the given array into the hash table ; Traverse the hash in ascending order to print the required number ; Print the number of times a digits occurs ; extracting the first digit ; extracting the last digit ; printing the prime combinations ; Driver code
",0
892,"create void maxPossibleSum with arr array of  , N, sort ( arr, arr + N )
create integer sum with sum assign to 0
create integer j with j assign to N - 3
untill j >assign to 0, increment sum by arr array ofj 
decrement j by 3
print sum
declare integer main ( ) and integer array arr with arr assign to  7, 4, 5, 2, 3, 1, 5, 9
create integer N with N assign to 8
maxPossibleSum ( arr, N )
return 0
","Maximize sum of second minimums in all quadruples of a given array 
 C ++ program untill the above approach ; Function to find maximum possible sum of second minimums in each quadruple ; Sort the array ; Add the second minimum ; Print maximum possible sum ; Driver Code ; Given array ; Size of the array
",1
893,"create void maxPossibleSum with arr array of  , N, sort ( arr, arr + N )
create integer sum with sum assign to 0
create integer j with j assign to N - 3
untill j >assign to 0, increment sum by arr array ofj 
decrement j by 3
print sum
declare integer main ( ) and integer array arr with arr assign to  7, 4, 5, 2, 3, 1, 5, 9
create integer N with N assign to 8
maxPossibleSum ( arr, N )
return 0
","Slope of perpendicular to line 
 C ++ program find slope of perpendicular line ; Function to find the Slope of other line ; Driver code
",0
894,"declare insertionSort with integer arr array of  , integer n as arguments, returning integers i, key and j
untill i assign to 1 to n exclusive, set key to arr array of i  
set j to i - 1
untill j >assign to 0 and arr array ofj   > key, set arr array of j + 1   to arr array of j  
set j to j - 1
arr array of j + 1   assign to key
printArray is a new array of integers arr array of   and n and a new array of integers i
untill i assign to 0 to n exclusive, print arr array of i   and "" ""
print a new line
declare integer main ( ), integer arr array of   assign to  12, 11, 13, 5, 6  ;
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
call insertionSort ( arr, N )
printArray ( arr, N )
return 0
","Difference between Insertion sort and Selection sort 
 C ++ program untill the insertion sort ; Function to sort an array using insertion sort ; Move elements of arr array of 0. . i - 1   , that are greater than key to one position ahead of their current position ; Function to print an array of size N ; Print the array ; Driver Code ; Function Call
",1
895,"declare insertionSort with integer arr array of  , integer n as arguments, returning integers i, key and j
untill i assign to 1 to n exclusive, set key to arr array of i  
set j to i - 1
untill j >assign to 0 and arr array ofj   > key, set arr array of j + 1   to arr array of j  
set j to j - 1
arr array of j + 1   assign to key
printArray is a new array of integers arr array of   and n and a new array of integers i
untill i assign to 0 to n exclusive, print arr array of i   and "" ""
print a new line
declare integer main ( ), integer arr array of   assign to  12, 11, 13, 5, 6  ;
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
call insertionSort ( arr, N )
printArray ( arr, N )
return 0
","Compute modulus division by a power 
  ; This function will return n % d . d must be one of : 1 , 2 , 4 , 8 , 16 , 32 , ... ; Driver Code ; d must be a power of 2
",0
896,"declare getPairs with integer arr array of  , N, K as arguments, set count to 0
untill i assign to 0 to N exclusive, increment count by 1 if int j assign to i + 1 ; j  N ; j ++ ) increment count
print count
declare integer main ( ), integer arr assign to  5, 6, 2, 1  ;
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create integer K with K assign to 2
getPairs ( arr, N, K )
return 0
","Count pairs ( i , j ) from given array such that i K * arr array of j   
 C ++ program untill the above approach ; Function to find the count required pairs ; Stores count of pairs ; Traverse the array ; Check if the condition is satisfied or not ; Driver Code ; Function Call
",1
897,"declare getPairs with integer arr array of  , N, K as arguments, set count to 0
untill i assign to 0 to N exclusive, increment count by 1 if int j assign to i + 1 ; j  N ; j ++ ) increment count
print count
declare integer main ( ), integer arr assign to  5, 6, 2, 1  ;
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create integer K with K assign to 2
getPairs ( arr, N, K )
return 0
","Check if two strings are same ignoring their cases 
 Function to compare two strings ignoring their cases ; length of first string ; length of second string ; if length is not same simply return false since both string can not be same if length is not equal ; loop to match one by one all characters of both string ; if current characters of both string are same , increase value of i to compare next character ; if any character of first string is some special character or numeric character and not same as corresponding character of second string then return false ; do the same untill second string ; this block of code will be executed if characters of both strings are of different cases ; compare characters by ASCII value ; if characters matched , increase the value of i to compare next char ; if all characters of the first string are matched with corresponding characters of the second string , then return true ; Function to print the same or not same if strings are equal or not equal ; Driver Code
",0
898,"merge assign to integer with merge assign to arr assign to integer array, temp assign to integer array, l assign to integer assign to integer assign to m assign to integer assign to integer assign to r assign to integer assign to i assign to integer assign to l
create integer j with j assign to m + 1
cnt assign to integer with cnt assign to 0
untill l assign to 0 to m inclusive, found assign to false
untill j assign to r, if arr array of i  >assign to K * arr array of j  , found assign to true
else break
increment j
if found is true, increment cnt by j - ( m + 1 )
decrement j
k assign to integer with k assign to l
i assign to l
j assign to m + 1
untill i assign to m and j assign to r, temp array of k ++   assign to arr array of i ++  
else temp array of k ++   assign to arr array of j ++  
untill i assign to m, temp array of k ++   assign to arr array of i ++  
untill j assign to r, temp array of k ++   assign to arr array of j ++  
untill i assign to l to r inclusive arr array of i   assign to temp array of i  
return cnt
mergeSortUtil assign to integer with arr array of  , temp assign to integer, l assign to integer, r assign to integer, cnt assign to integer assign to 0
if l is less than r, set m to ( l + r ) / 2
increment cnt by mergeSortUtil ( arr, temp, l, m, K )
increment cnt by mergeSortUtil ( arr, temp, m + 1, r, K )
increment cnt by merge ( arr, temp, l, m, r, K )
return cnt
mergeSort assign to integer array of size array of  , N, K, temp assign to integer array of size N
print mergeSortUtil ( arr, temp, 0, N - 1, K )
declare integer main ( ), integer arr assign to  5, 6, 2, 5  ; declare integer array arr assign to  5, 6, 2, 5
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create integer K with K assign to 2
mergeSort ( arr, N, K )
return 0
","Count pairs ( i , j ) from given array such that i K * arr array of j   
 C ++ program untill the above approach ; Function to merge two sorted arrays ; i : index to left subarray ; j : index to right subarray ; Stores count of pairs that satisfy the given condition ; Traverse to check untill the valid conditions ; If condition satisfies ; All elements in the right side of the left subarray also satisfies ; Sort the two given arrays and store in the resultant array ; Elements which are left in the left subarray ; Elements which are left in the right subarray ; Return the count obtained ; Function to partition array into two halves ; Same as ( l + r ) / 2 , but avoids overflow untill large l and h ; Sort first and second halves ; Call the merging function ; Function to print the count of required pairs using Merge Sort ; Driver code ; Function Call
",1
899,"merge assign to integer with merge assign to arr assign to integer array, temp assign to integer array, l assign to integer assign to integer assign to m assign to integer assign to integer assign to r assign to integer assign to i assign to integer assign to l
create integer j with j assign to m + 1
cnt assign to integer with cnt assign to 0
untill l assign to 0 to m inclusive, found assign to false
untill j assign to r, if arr array of i  >assign to K * arr array of j  , found assign to true
else break
increment j
if found is true, increment cnt by j - ( m + 1 )
decrement j
k assign to integer with k assign to l
i assign to l
j assign to m + 1
untill i assign to m and j assign to r, temp array of k ++   assign to arr array of i ++  
else temp array of k ++   assign to arr array of j ++  
untill i assign to m, temp array of k ++   assign to arr array of i ++  
untill j assign to r, temp array of k ++   assign to arr array of j ++  
untill i assign to l to r inclusive arr array of i   assign to temp array of i  
return cnt
mergeSortUtil assign to integer with arr array of  , temp assign to integer, l assign to integer, r assign to integer, cnt assign to integer assign to 0
if l is less than r, set m to ( l + r ) / 2
increment cnt by mergeSortUtil ( arr, temp, l, m, K )
increment cnt by mergeSortUtil ( arr, temp, m + 1, r, K )
increment cnt by merge ( arr, temp, l, m, r, K )
return cnt
mergeSort assign to integer array of size array of  , N, K, temp assign to integer array of size N
print mergeSortUtil ( arr, temp, 0, N - 1, K )
declare integer main ( ), integer arr assign to  5, 6, 2, 5  ; declare integer array arr assign to  5, 6, 2, 5
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create integer K with K assign to 2
mergeSort ( arr, N, K )
return 0
","Reach A and B by multiplying them with K and K to the power 2 at every step 
 CPP program to determine if A and B can be reached starting from 1 , 1 following the given steps . ; function to check is it is possible to reach A and B starting from 1 and 1 ; find the cuberoot of the number ; divide the number by cuberoot ; if it is a perfect cuberoot and divides a and b ; Driver code
",0
900,"declare minRemovals with integer A array of  , integer N as arguments, sorting A, A + N
create integer mx with mx assign to A array of N - 1  
create integer sum with sum assign to 1
untill i assign to 0 to N exclusive, add A array of i   to sum
if sum - mx >assign to mx, print 0 and "" STRNEWLINE ""
else print 2 * mx - sum print "" STRNEWLINE ""
declare integer main ( ), integer A assign to  3, 3, 2 , integer array A assign to  3
create integer N with N assign to sizeof ( A) / sizeof ( A array of 0   )
minRemovals ( A, N )
return 0
","Minimize consecutive removals of elements of the same type to empty given array 
 C ++ implementation of the above approach ; Function to count minimum consecutive removals of elements of the same type ; Sort the array ; Stores the maximum element present in the array ; Stores sum of the array ; Calculate sum of the array ; Driver Code ; Function call
",1
901,"declare minRemovals with integer A array of  , integer N as arguments, sorting A, A + N
create integer mx with mx assign to A array of N - 1  
create integer sum with sum assign to 1
untill i assign to 0 to N exclusive, add A array of i   to sum
if sum - mx >assign to mx, print 0 and "" STRNEWLINE ""
else print 2 * mx - sum print "" STRNEWLINE ""
declare integer main ( ), integer A assign to  3, 3, 2 , integer array A assign to  3
create integer N with N assign to sizeof ( A) / sizeof ( A array of 0   )
minRemovals ( A, N )
return 0
","Find the Longest Increasing Subsequence in Circular manner 
 C ++ implementation to find LIS in circular way ; Utility function to find LIS using Dynamic programming ; Initialize LIS values untill all indexes ; Compute optimized LIS values in bottom up manner ; Set j on the basis of current window i . e . first element of the current window ; Pick maximum of all LIS values ; Function to find Longest Increasing subsequence in Circular manner ; Make a copy of given array by appending same array elements to itself ; Peruntillm LIS untill each window of size n ; Driver program to test above function
",0
902,"declare rearrangeArray with integers a array of  , n, sort ( a, a + n ) as arguments
untill i assign to 0 to n - 1 exclusive, swap a array of i   and a array of i + 1  
if a array of n - 1   is n, swap a array of n - 1   and a array of n - 2  
untill i assign to 0 to n exclusive, print a array of i  and "" ""
declare integer main ( ), integer arr assign to  1, 5, 3, 2, 4  ;
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create rearrangeArray ( arr, N )
return 0
","Rearrange given array such that no array element is same as its index 
 C ++ program untill the above approach ; Function to rearrange the array a array of   such that none of the array elements is same as its index ; Sort the array ; Traverse the indices array of 0 , N - 2   of the given array ; Check if the current element is equal to its index ; If found to be true , swap current element with the next element ; Check if the last element is same as its index ; If found to be true , swap current element with the previous element ; Print the modified array ; Driver Code ; Function Call
",1
903,"declare rearrangeArray with integers a array of  , n, sort ( a, a + n ) as arguments
untill i assign to 0 to n - 1 exclusive, swap a array of i   and a array of i + 1  
if a array of n - 1   is n, swap a array of n - 1   and a array of n - 2  
untill i assign to 0 to n exclusive, print a array of i  and "" ""
declare integer main ( ), integer arr assign to  1, 5, 3, 2, 4  ;
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create rearrangeArray ( arr, N )
return 0
","Find a pair with the given difference 
 C ++ program to find a pair with the given difference ; The function assumes that the array is sorted ; Initialize positions of two elements ; Search untill a pair ; Driver program to test above function
",0
904,"minOperations assign to integer with f assign to 0 assign to integer
untill i assign to 0 to n exclusive, if arr1 array of i  not equal to arr2 array of i  , set f to 1
break loop
if f is 0, return 0
if i >assign to n j >assign to n, return 0
if arr1 array of i   arr2 array of j  , return 1 + minOperations ( arr1, arr2, i + 1, j + 1, n )
return maximum of minOperations ( arr1, arr2, i, j + 1, n ), minOperations ( arr1, arr2, i + 1, j, n ) )
declare minOperationsUtil with integer arr array of  , integer n, and brr array of n   as arguments
untill i assign to 0 to n exclusive, brr array of i   assign to arr array of i  
sort ( brr, brr + n )
create integer f with f assign to 0
untill i assign to 0 to n exclusive, if arr array of i  not equal to brr array of i  , set f to 1
break loop
if f is 1 print minOperations ( arr, brr, 0, 0, n )
else print ""0""
declare integer main ( ), integer arr array of   assign to  4, 7, 2, 3, 9
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
minOperationsUtil ( arr, n )
","Count minimum number of moves to front or end to sort an array 
 C ++ program untill the above approach ; Function that counts the minimum moves required to covert arr array of   to brr array of   ; Base Case ; If arr array of i   < arr array of j   ; Include the current element ; Otherwise , excluding the current element ; Function that counts the minimum moves required to sort the array ; If both the arrays are equal ; No moves required ; Otherwise ; Print minimum operations required ; Driver code
",1
905,"minOperations assign to integer with f assign to 0 assign to integer
untill i assign to 0 to n exclusive, if arr1 array of i  not equal to arr2 array of i  , set f to 1
break loop
if f is 0, return 0
if i >assign to n j >assign to n, return 0
if arr1 array of i   arr2 array of j  , return 1 + minOperations ( arr1, arr2, i + 1, j + 1, n )
return maximum of minOperations ( arr1, arr2, i, j + 1, n ), minOperations ( arr1, arr2, i + 1, j, n ) )
declare minOperationsUtil with integer arr array of  , integer n, and brr array of n   as arguments
untill i assign to 0 to n exclusive, brr array of i   assign to arr array of i  
sort ( brr, brr + n )
create integer f with f assign to 0
untill i assign to 0 to n exclusive, if arr array of i  not equal to brr array of i  , set f to 1
break loop
if f is 1 print minOperations ( arr, brr, 0, 0, n )
else print ""0""
declare integer main ( ), integer arr array of   assign to  4, 7, 2, 3, 9
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
minOperationsUtil ( arr, n )
","Coin Change 
 DP 
 Recursive C program untill coin change problem . ; Returns the count of ways we can sum S array of 0. . . m - 1   coins to get sum n ; If n is 0 then there is 1 solution ( do not include any coin ) ; If n is less than 0 then no solution exists ; If there are no coins and n is greater than 0 , then no solution exist ; count is sum of solutions ( i ) including S array of m - 1   ( ii ) excluding S array of m - 1   ; Driver program to test above function
",0
906,"declare canTransuntillm with string & s, string & t as arguments, changing n to length of s
create vector  int > occur array of 26  
untill x assign to 0 to n exclusive, ch assign to s array ofx  -'a'
push_back ( x ) is a new line
create vector idx with size 26, 0
create boolean poss with poss assign to true
untill x assign to 0 to n exclusive, ch assign to t array ofx  -'a'
if idx array of ch  >assign to occur array of ch   size ( ) ), poss assign to false
break loop
untill small assign to 0 to ch exclusive, if idx array of small  is less than or equal to size ( ) and occur array of small   array of idx array of small     is less than or equal to poss, set poss to false
break loop
increment idx array of ch  
if poss is true, print Yes
else print No
declare integer main ( ), integers s, t
s assign to "" hdecb ""
t assign to "" cdheb ""
let canTransuntillm be a function that accepts s, t and returns a value
return 0
","Check if a string can be transuntillmed to another by sorting substrings 
 C ++ Program to implement the above approach ; Function to check if str1 can be transuntillmed to t by sorting substrings ; Occur array of i   stores the indices of char ( ' a ' + i ) in string s ; idx array of i   stores the next available index of char ( ' a ' + i ) in occur array of i   ; If this char is not available anymore ; Conversion not possible ; If one of the smaller characters is available and occurs beuntille ; Conversion not possible ; Print the answer ; Driver Code
",1
907,"declare canTransuntillm with string & s, string & t as arguments, changing n to length of s
create vector  int > occur array of 26  
untill x assign to 0 to n exclusive, ch assign to s array ofx  -'a'
push_back ( x ) is a new line
create vector idx with size 26, 0
create boolean poss with poss assign to true
untill x assign to 0 to n exclusive, ch assign to t array ofx  -'a'
if idx array of ch  >assign to occur array of ch   size ( ) ), poss assign to false
break loop
untill small assign to 0 to ch exclusive, if idx array of small  is less than or equal to size ( ) and occur array of small   array of idx array of small     is less than or equal to poss, set poss to false
break loop
increment idx array of ch  
if poss is true, print Yes
else print No
declare integer main ( ), integers s, t
s assign to "" hdecb ""
t assign to "" cdheb ""
let canTransuntillm be a function that accepts s, t and returns a value
return 0
","Find Square Root under Modulo p 
 Set 1 ( When p is in untillm of 4 * i + 3 ) 
 An efficient C ++ program to find square root under modulo p when p is 7 , 11 , 19 , 23 , 31 , ... etc . ; Utility function to do modular exponentiation . It returns ( x to the power y ) % p . ; int res assign to 1 ; Initialize result x assign to x % p ; Update x if it is more than or equal to p ; If y is odd , multiply x with result ; y must be even now y assign to y >> 1 ; y assign to y / 2 ; Returns true if square root of n under modulo p exists Assumption : p is of the untillm 3 * i + 4 where i >assign to 1 ; Try "" + ( n to the power ( ( p â– + â– 1 ) / 4 ) ) "" ; Try "" - ( n â– to the power â– ( ( p â– + â– 1 ) / 4 ) ) "" ; If none of the above two work , then square root doesn 't exist ; Driver program to test
",0
908,"declare integer variable inversionCount with string & s as arguments, returning integer freq array of 26  assign to 0
create integer inv with inv assign to 0
untill i assign to 0 to length of s exclusive, temp assign to 0
untill j assign to 0 to s array of i   -'a'), temp assign to temp + freq array of j  
increment inv by ( i - temp )
increment freq array of s array of i   -'a' 
return inv
declare haveRepeated with string & S1, string & S2 as arguments, set freq to 0
return true if freq array of i -'a'  > 0
increment freq array of i -'a' 
untill i assign to 0 to 26 exclusive, freq array of i   assign to 0
return true if freq array of i -'a'  > 0
increment freq array of i -'a' 
return false
declare checkToMakeEqual with string S1, S2 as arguments, set freq to 0
untill i assign to 0 to length of S1 exclusive, increment freq array of S1 array of i  -'a '   
flag assign to boolean with flag assign to 0
untill i assign to 0 to length of S2 exclusive, if freq array of S2 array of i   -'a'  is 0, set flag to true
break loop
freq array of S2 array of i  -'a'  --
if flag is true, print No STRNEWLINE
return
declare integer variable invCount1 assign to inversionCount ( S1 )
declare integer variable invCount2 assign to inversionCount ( S2 )
if invCount1 is invCount2 or (invCount1 & 1 ) is invCount2 & 1 ) or haveRepeated ( S1, S2 ) ), print Yes STRNEWLINE
else print ""No STRNEWLINE ""
declare integer main ( ), string S1 assign to "" abbca "", S2 assign to "" acabb ""
call checkToMakeEqual ( S1, S2 )
return 0
","Check whether two strings can be made equal by reversing substring of equal length from both strings 
 C ++ program untill the above approach ; function to count inversion count of the string ; untill storing frequency ; Add all the characters which are less than the ith character beuntille i . ; adding the count to inversion count ; updating the character in the frequency array ; function to check whether any of the string have a repeated character ; function to check whether the string S1 and S2 can be made equal by reversing sub strings of same size in both strings ; frequency array to check whether both string have same character or not ; adding the frequency ; ; if the character is not in S1 ; decrementing the frequency ; If both string doesnot have same characters or not ; finding inversion count of both strings ; If inversion count is same , or have same parity or if any of the string have a repeated character then the answer is Yes else No ; driver code
",1
909,"declare integer variable inversionCount with string & s as arguments, returning integer freq array of 26  assign to 0
create integer inv with inv assign to 0
untill i assign to 0 to length of s exclusive, temp assign to 0
untill j assign to 0 to s array of i   -'a'), temp assign to temp + freq array of j  
increment inv by ( i - temp )
increment freq array of s array of i   -'a' 
return inv
declare haveRepeated with string & S1, string & S2 as arguments, set freq to 0
return true if freq array of i -'a'  > 0
increment freq array of i -'a' 
untill i assign to 0 to 26 exclusive, freq array of i   assign to 0
return true if freq array of i -'a'  > 0
increment freq array of i -'a' 
return false
declare checkToMakeEqual with string S1, S2 as arguments, set freq to 0
untill i assign to 0 to length of S1 exclusive, increment freq array of S1 array of i  -'a '   
flag assign to boolean with flag assign to 0
untill i assign to 0 to length of S2 exclusive, if freq array of S2 array of i   -'a'  is 0, set flag to true
break loop
freq array of S2 array of i  -'a'  --
if flag is true, print No STRNEWLINE
return
declare integer variable invCount1 assign to inversionCount ( S1 )
declare integer variable invCount2 assign to inversionCount ( S2 )
if invCount1 is invCount2 or (invCount1 & 1 ) is invCount2 & 1 ) or haveRepeated ( S1, S2 ) ), print Yes STRNEWLINE
else print ""No STRNEWLINE ""
declare integer main ( ), string S1 assign to "" abbca "", S2 assign to "" acabb ""
call checkToMakeEqual ( S1, S2 )
return 0
","Count ways to represent a number as sum of perfect squares 
 C ++ program untill the above approach ; Store perfect squares less than or equal to N ; Utility function to calculate perfect squares less than or equal to N ; Function to find the number of ways to represent a number as sum of perfect squares ; Handle the base cases ; Include the i - th index element ; Exclude the i - th index element ; Return the result ; Driver Code ; Given Input ; Precalculate perfect squares <assign to N ; Function Call
",0
910,"sortArr assign to int a array of  , int n, int i, k
k assign to ( integer ) log2 ( n )
set k to pow ( 2, k )
untill k is greater than 0, swap a array of i   and a array of i + k   )
set k to k / 2
print a array of i   and "" ""
declare integer main with a value of  5, 20, 30, 40, 36, 33, 25, 15, 10  arrarray of  
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
sortArr ( arr, n )
return 0
","Sort a Bitonic Array 
 C ++ program untill the above approach ; Function to Sort a Bitonic array in constant space ; Initialize the value of k ; In each iteration compare elements k distance apart and swap if they are not in order ; k is reduced to half after every iteration ; Print the array elements ; Driver Code ; Given array arr array of   ; Function Call
",1
911,"sortArr assign to int a array of  , int n, int i, k
k assign to ( integer ) log2 ( n )
set k to pow ( 2, k )
untill k is greater than 0, swap a array of i   and a array of i + k   )
set k to k / 2
print a array of i   and "" ""
declare integer main with a value of  5, 20, 30, 40, 36, 33, 25, 15, 10  arrarray of  
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
sortArr ( arr, n )
return 0
","Count distinct pairs with given sum 
 C ++ program to implement the above approach ; Function to count distinct pairs in array whose sum equal to K ; Stores count of distinct pairs whose sum equal to K ; Store frequency of each distinct element of the array ; Update frequency of arr array of i   ; Traverse the map ; Stores key value of the map ; If i is the half of K ; If frequency of i greater than 1 ; Update cntPairs ; Update cntPairs ; Driver Code
",0
912,"declare maximumSum with integer arr array of  , integer n, integer k, elt assign to n / k as arguments, returning integer
create integer sum with sum assign to 0
sort arr, arr + n
create integer count with count assign to 0
create integer i with i assign to n - 1
untill count  k, increment sum by arr array of i 
decrement i
increment count
set count to 0
set i to 0
untill count  k, increment sum by arr array of i 
increment i by elt - 1
increment count
print sum and "" STRNEWLINE ""
declare integer main ( ) and integer array Arr with size   assign to  1, 13, 7, 17, 6, 5
create integer K with K assign to 2
size assign to integer with size assign to sizeof ( Arr ) / sizeof ( Arr array of 0   )
let maximumSum ( Arr, size, K ) be a maximumSum
return 0
","Split array into K subsets to maximize their sum of maximums and minimums 
 C ++ Program to implement the above approach ; Function that prints the maximum sum possible ; Find elements in each group ; Sort all elements in non - descending order ; Add K largest elements ; For sum of minimum elements from each subset ; Printing the maximum sum ; Driver Code
",1
913,"declare maximumSum with integer arr array of  , integer n, integer k, elt assign to n / k as arguments, returning integer
create integer sum with sum assign to 0
sort arr, arr + n
create integer count with count assign to 0
create integer i with i assign to n - 1
untill count  k, increment sum by arr array of i 
decrement i
increment count
set count to 0
set i to 0
untill count  k, increment sum by arr array of i 
increment i by elt - 1
increment count
print sum and "" STRNEWLINE ""
declare integer main ( ) and integer array Arr with size   assign to  1, 13, 7, 17, 6, 5
create integer K with K assign to 2
size assign to integer with size assign to sizeof ( Arr ) / sizeof ( Arr array of 0   )
let maximumSum ( Arr, size, K ) be a maximumSum
return 0
","Modify array such that the array does not contain any common divisors other than 1 
 C ++ program untill the above approach ; Function to check if it is possible to modify the array such that there is no common factor between array elements except 1 ; Stores GCD of the array ; Calculate GCD of the array ; If the current divisor is smaller than X ; Divide GCD by the current divisor ; If possible ; Print the modified array ; Otherwise ; Driver Code ; Given array ; Size of the array
",0
914,"declare findMinSum with integer arr array of  , K, L, size, if K * L is greater than size, return -1
minsum assign to integer with minsum assign to 0
sort arr, arr + size
untill i assign to 0 to K exclusive, increment minsum by arr array of i  
return minsum
declare integer main ( ) and integer array arr with size   assign to  2, 15, 5, 1, 35, 16, 67, 10
create integer K with K assign to 3
create integer L with L assign to 2
length assign to integer with length assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print findMinSum ( arr, K, L, length )
return 0
","Minimize sum of smallest elements from K subsequences of length L 
 C ++ Program to find the minimum possible sum of the smallest elements from K subsequences ; Function to find the minimum sum ; Sort the array ; Calculate sum of smallest K elements ; Return the sum ; Driver Code
",1
915,"declare findMinSum with integer arr array of  , K, L, size, if K * L is greater than size, return -1
minsum assign to integer with minsum assign to 0
sort arr, arr + size
untill i assign to 0 to K exclusive, increment minsum by arr array of i  
return minsum
declare integer main ( ) and integer array arr with size   assign to  2, 15, 5, 1, 35, 16, 67, 10
create integer K with K assign to 3
create integer L with L assign to 2
length assign to integer with length assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print findMinSum ( arr, K, L, length )
return 0
","Minimum number of subsets with distinct elements 
 A hashing based solution to find the minimum number of subsets of a set such that every subset contains distinct elements . ; Function to count subsets such that all subsets have distinct elements . ; Traverse the input array and store frequencies of elements ; Find the maximum value in map . ; Driver code
",0
916,"declare findKthSmallest with integer arr array of  , integer n, integer k, max assign to 0
untill i assign to 0 to n exclusive, set max to arr array of i  
counter assign to integer array of size max + 1 with counter assign to 0
create integer smallest with smallest assign to 0
untill i assign to 0 to n exclusive, counter array of arr array of i     is equal to counter array of arr array of i       ++
untill num assign to 1 to max inclusive, increment smallest by counter array of num  
if smallest >assign to k, return num
declare integer array arr size   assign to  7, 1, 4, 4, 20, 15, 8
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create integer K with K assign to 5
print findKthSmallest ( arr, N, K)
return 0
","Kth smallest or largest element in unsorted Array 
 Set 4 
 C ++ program untill the above approach ; Function to find the Kth smallest element in Unsorted Array ; Initialize the max Element as 0 ; Iterate arr array of   and find the maximum element in it ; Frequency array to store the frequencies ; Counter variable ; Counting the frequencies ; Iterate through the freq array of   ; Check if num is present in the array ; Increment the counter with the frequency of num ; Checking if we have reached the Kth smallest element ; Return the Kth smallest element ; Driver Code ; Given array ; Function Call
",1
917,"declare findKthSmallest with integer arr array of  , integer n, integer k, max assign to 0
untill i assign to 0 to n exclusive, set max to arr array of i  
counter assign to integer array of size max + 1 with counter assign to 0
create integer smallest with smallest assign to 0
untill i assign to 0 to n exclusive, counter array of arr array of i     is equal to counter array of arr array of i       ++
untill num assign to 1 to max inclusive, increment smallest by counter array of num  
if smallest >assign to k, return num
declare integer array arr size   assign to  7, 1, 4, 4, 20, 15, 8
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create integer K with K assign to 5
print findKthSmallest ( arr, N, K)
return 0
","Count of interesting primes upto N 
 C ++ program to find the number of interesting primes up to N . ; Function to find all prime numbers ; Create a boolean array "" prime array of 0 . . n   "" and initialize all entries as true . A value in prime array of i   will finally be false if i is Not a prime . ; If prime array of p   is not changed , then it is a prime ; Update all multiples of p greater than or equal to the square of it ; Store all prime numbers ; Function to check if a number is perfect square or not ; To store all primes ; To store all interseting primes ; Store all perfect squares ; Store all perfect quadruples ; Store all interseting primes ; Return count of interseting primes ; Driver code
",0
918,"create void lexNumbers ( integer n ), vector, string > s
untill i assign to 1 to n inclusive, push_back s. to_string ( i ) )
sort s from start to end
create vector  integer>ans
untill i assign to 0 to n exclusive, push_back ( stoi ( s array of i   ) ) )
untill i assign to 0 to n exclusive, print ans array of i  and "" ""
declare integer main ( ) and integer n assign to 15
create lexNumbers ( n )
return 0
","Generate all numbers up to N in Lexicographical Order 
 C ++ Program to implement the above approach ; Function to print all the numbers up to n in lexicographical order ; Driver Program
",1
919,"create void lexNumbers ( integer n ), vector, string > s
untill i assign to 1 to n inclusive, push_back s. to_string ( i ) )
sort s from start to end
create vector  integer>ans
untill i assign to 0 to n exclusive, push_back ( stoi ( s array of i   ) ) )
untill i assign to 0 to n exclusive, print ans array of i  and "" ""
declare integer main ( ) and integer n assign to 15
create lexNumbers ( n )
return 0
","Maximize count of elements that can be selected having minimum difference between their sum and K 
 C ++ implementation of the above approach ; Function to count maximum number of elements that can be selected ; Sort the array ; Traverse the array ; Add current element to the sum ; IF sum exceeds k ; Increment count ; Return the count ; Driver Code ; Function call
",0
920,"if i is even, i is less than N, increment k, if a array of i   array of k   is greater than a array of i   array of k  , temp assign to a array of i   array of j  
a array of i   array of j   assign to a array of i   array of k  
a array of i   array of k   assign to temp
if a array of i   array of j    a array of i   array of k  , temp assign to a array of i   array of j  , j  , j, j, j, j, j, j, j, j, j, j, j, k, k, k, k,
a array of i   array of j   assign to a array of i   array of k  
a array of i   array of k   assign to temp
untill i assign to 0 to N exclusive, printf ( "" % d "", a array of i   array of j   )
printf is a newline
a assign to  5, 7, 3, 4 , 9, 5, 8, 2 , 6, 3, 8, 1 , 5, 8, 9, 3
func assign to func assign to a
return 0
","Sort Matrix in alternating ascending and descending order rowwise 
 C ++ implementation to print row of matrix in ascending or descending order alternatively ; Iterate matrix rowwise ; Sort even rows in ascending order ; compare adjacent elements ; swap adjacent element ; Sort even rows in descending order ; compare adjacent elements ; swap adjacent element ; Printing the final Output ; Driver code
",1
921,"if i is even, i is less than N, increment k, if a array of i   array of k   is greater than a array of i   array of k  , temp assign to a array of i   array of j  
a array of i   array of j   assign to a array of i   array of k  
a array of i   array of k   assign to temp
if a array of i   array of j    a array of i   array of k  , temp assign to a array of i   array of j  , j  , j, j, j, j, j, j, j, j, j, j, j, k, k, k, k,
a array of i   array of j   assign to a array of i   array of k  
a array of i   array of k   assign to temp
untill i assign to 0 to N exclusive, printf ( "" % d "", a array of i   array of j   )
printf is a newline
a assign to  5, 7, 3, 4 , 9, 5, 8, 2 , 6, 3, 8, 1 , 5, 8, 9, 3
func assign to func assign to a
return 0
","Program to check if matrix is lower triangular 
 Program to check lower triangular matrix . ; Function to check matrix is in lower triangular untillm or not . ; Driver function . ; Function call
",0
922,"create map  int, int > g array of 200005  
create set of integers with value s, ns
declare dfs with integer x as argument, returning vector, returning integer, with v assign to v
clear is a new function
clear assign to ns. clear assign to clear
untill g array of x  array of it  , push_back v
else insert it into ns
s assign to ns
untill i : v, dfs ( i )
void function weightOfMST with integer argument N and integer variable cnt assign to 0
untill i assign to 1 to N inclusive, insert i into s
untill s. size ( ), increment cnt
create integer t with t assign to * s. begin ( )
erase t
dfs assign to t
print cnt - 1
declare integer main ( ), N assign to 6 and M assign to 11
edges assign to integer array of size array of   array of   assign to   1, 3 ,  1, 4 ,  1, 6 ,  2, 3 ,  2, 5 ,  3, 4 ,  3, 5 ,  3, 5 ,  3, 6 ,  3, 6
untill i assign to 0 to M exclusive, u assign to edges array of i   array of 0  
create integer v with v assign to edges array of i   array of 1  
set g array of u   array of v   to 1
set g array of v   array of u   to 1
print weightOfMST ( N)
return 0
","Find weight of MST in a complete graph with edge 
 C ++ Program to find weight of minimum spanning tree in a complete graph where edges have weight either 0 or 1 ; To store the edges of the given graph ; A utility function to peruntillm DFS Traversal ; Check those vertices which are stored in the set ; Vertices are included if the weight of edge is 0 ; A utility function to find the weight of Minimum Spanning Tree ; To count the connected components ; Inserting the initial vertices in the set ; Traversing vertices stored in the set and Run DFS Traversal untill each vertices ; Incrementing the zero weight connected components ; DFS Traversal untill every vertex remove ; Driver 's Code ; Insert edges ; Function call find the weight of Minimum Spanning Tree
",1
923,"create map  int, int > g array of 200005  
create set of integers with value s, ns
declare dfs with integer x as argument, returning vector, returning integer, with v assign to v
clear is a new function
clear assign to ns. clear assign to clear
untill g array of x  array of it  , push_back v
else insert it into ns
s assign to ns
untill i : v, dfs ( i )
void function weightOfMST with integer argument N and integer variable cnt assign to 0
untill i assign to 1 to N inclusive, insert i into s
untill s. size ( ), increment cnt
create integer t with t assign to * s. begin ( )
erase t
dfs assign to t
print cnt - 1
declare integer main ( ), N assign to 6 and M assign to 11
edges assign to integer array of size array of   array of   assign to   1, 3 ,  1, 4 ,  1, 6 ,  2, 3 ,  2, 5 ,  3, 4 ,  3, 5 ,  3, 5 ,  3, 6 ,  3, 6
untill i assign to 0 to M exclusive, u assign to edges array of i   array of 0  
create integer v with v assign to edges array of i   array of 1  
set g array of u   array of v   to 1
set g array of v   array of u   to 1
print weightOfMST ( N)
return 0
","Minimum number of given moves required to reach ( 1 , 1 ) from ( X , Y ) 
 C ++ program untill the above approach ; Function to count the number of steps required to convert ( x , y ) to ( 1 , 1 ) ; Store the required result ; Iterate untill both x and y are not equal to 0 ; If x is greater than y ; Update count and value of x ; Otherwise ; Update count and value of y ; If both x and y > 1 ; Print the result ; Driver Code ; Given X and Y
",0
924,"declare integer variable countPairs with vector  integers > A, vector  integers > B, n assign to size of A
sort A
sort B. begin ( ), B. end ( ) )
create integers ans, i with ans assign to 0 and i
untill i assign to 0 to n exclusive, increment ans by 1 if A array of i   > B array of ans  
return ans
declare integer main ( ), vector A assign to  30, 28, 45, 22  ; declare integer variable A assign to  30, 28, 45, 22
create vector  int > B assign to  35, 25, 22, 48  ;
print countPairs ( A, B )
return 0
","Count of distinct possible pairs such that the element from A is greater than the element from B 
 C ++ Program to count number of distinct pairs possible from the two arrays such that element selected from one array is always greater than the one selected from the other array ; Function to return the count of pairs ; Driver code
",1
925,"declare integer variable countPairs with vector  integers > A, vector  integers > B, n assign to size of A
sort A
sort B. begin ( ), B. end ( ) )
create integers ans, i with ans assign to 0 and i
untill i assign to 0 to n exclusive, increment ans by 1 if A array of i   > B array of ans  
return ans
declare integer main ( ), vector A assign to  30, 28, 45, 22  ; declare integer variable A assign to  30, 28, 45, 22
create vector  int > B assign to  35, 25, 22, 48  ;
print countPairs ( A, B )
return 0
","Check untill Majority Element in a sorted array 
  ; 
",0
926,"declare integer maxMod ( integer arr array of  , integer n )  integer maxVal assign to * max_element ( arr, arr + n )
create integer secondMax with secondMax assign to 0
untill i assign to 0 to n exclusive, set arr array of i   maxVal and arr array of i   > secondMax, set secondMax to arr array of i  
return secondMax
declare integer main ( ), integer arr array of   assign to  2, 4, 1, 5, 3, 6  ;
n assign to sizeof ( arr ) / sizeof ( int )
print maxMod ( arr, n )
return 0
","Maximum possible remainder when an element is divided by other element in the array 
 C ++ implementation of the approach ; Function to return the maximum mod value untill any pair from the array ; Find the second maximum element from the array ; Driver code
",1
927,"declare integer maxMod ( integer arr array of  , integer n )  integer maxVal assign to * max_element ( arr, arr + n )
create integer secondMax with secondMax assign to 0
untill i assign to 0 to n exclusive, set arr array of i   maxVal and arr array of i   > secondMax, set secondMax to arr array of i  
return secondMax
declare integer main ( ), integer arr array of   assign to  2, 4, 1, 5, 3, 6  ;
n assign to sizeof ( arr ) / sizeof ( int )
print maxMod ( arr, n )
return 0
","Counts Path in an Array 
 C ++ implementation of the above approach ; Find the number of ways to reach the end ; Base case ; Recursive structure ; Driver code
",0
928,"if x > n y > m, return false
sort A, A + n
sort ( B, B + m )
if A array of x - 1   B array of m - y   return true
else return false
declare integer main ( ) and integer array A with size   assign to  1, 1, 1, 1, 1, 1, 1, 1
create integer B with B assign to  2, 2  ;
n assign to sizeof ( A ) / sizeof ( int )
m assign to sizeof ( B ) / sizeof ( int )
create integers x, y with x assign to 3 and y assign to 1
if isPossible ( A, B, n, m, x, y ) is true, print Yes
else print No
return 0
","Choose X elements from A array of   and Y elements from B array of   which satisfy the given condition 
 C ++ implementation of the approach ; Function to that returns true if it possible to choose the elements ; If elements can 't be chosen ; Sort both the arrays ; If xth smallest element of A array of   is smaller than the yth greatest element of B array of   ; Driver code
",1
929,"if x > n y > m, return false
sort A, A + n
sort ( B, B + m )
if A array of x - 1   B array of m - y   return true
else return false
declare integer main ( ) and integer array A with size   assign to  1, 1, 1, 1, 1, 1, 1, 1
create integer B with B assign to  2, 2  ;
n assign to sizeof ( A ) / sizeof ( int )
m assign to sizeof ( B ) / sizeof ( int )
create integers x, y with x assign to 3 and y assign to 1
if isPossible ( A, B, n, m, x, y ) is true, print Yes
else print No
return 0
","Maximize count of Decreasing Consecutive Subsequences from an Array 
 C ++ program to implement the above approach ; Function to find the maximum number number of required subsequences ; HashMap to store number of arrows available with height of arrow as key ; Stores the maximum count of possible subsequences ; Stores the count of possible subsequences ; Check if i - th element can be part of any of the previous subsequence ; Count of subsequences possible with arr array of i   as the next element ; If more than one such subsequence exists ; Include arr array of i   in a subsequence ; Otherwise ; Increase count of subsequence possible with arr array of i   - 1 as the next element ; Start a new subsequence ; Increase count of subsequence possible with arr array of i   - 1 as the next element ; Return the answer ; Driver Code
",0
930,"declare Min_Replace with integers arr array of  , n, k as arguments, sorting ( arr, arr + n)
create integer freq array of MAX 
set all contents of freq to 0
create integer p with p assign to 0
set freq array of p   to 1
untill i assign to 1 to n exclusive, increment freq array of p   if arr array of i   is arr array of i - 1  
else increment freq array of ++ p  
sort ( freq, freq + n, greater  integer > ( ) ) )
ans assign to integer with ans assign to 0
untill i assign to k to p inclusive, increment ans by freq array of i  
return ans
declare integer main ( ) and integer arr array of   assign to  1, 2, 7, 8, 2, 3, 2, 3  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create integer k with k assign to 2
print Min_Replace ( arr, n, k )
return 0
","Find minimum changes required in an array untill it to contain k distinct elements 
 CPP program to minimum changes required in an array untill k distinct elements . ; Function to minimum changes required in an array untill k distinct elements . ; Store the frequency of each element ; Store the frequency of elements ; Sort frequencies in descending order ; To store the required answer ; Return the required answer ; Driver code
",1
931,"declare Min_Replace with integers arr array of  , n, k as arguments, sorting ( arr, arr + n)
create integer freq array of MAX 
set all contents of freq to 0
create integer p with p assign to 0
set freq array of p   to 1
untill i assign to 1 to n exclusive, increment freq array of p   if arr array of i   is arr array of i - 1  
else increment freq array of ++ p  
sort ( freq, freq + n, greater  integer > ( ) ) )
ans assign to integer with ans assign to 0
untill i assign to k to p inclusive, increment ans by freq array of i  
return ans
declare integer main ( ) and integer arr array of   assign to  1, 2, 7, 8, 2, 3, 2, 3  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create integer k with k assign to 2
print Min_Replace ( arr, n, k )
return 0
","Queries to calculate sum of array elements present at every Yth index starting from the index X 
 C ++ program untill the above approach ; Function to Find the sum of arr array of x   + arr array of x + y   + arr array of x + 2 * y   + ... untill all queries ; Iterate over each query ; Stores the sum of arr array of x   + arr array of x + y   + arr array of x + 2 * y   + ... ; Traverse the array and calculate the sum of the expression ; Update sum ; Update x ; Driver Code
",0
932,"declare Segment with integers x array of  , l array of  , n, if n is 1 return 1
ans assign to integer with ans assign to 2
untill i assign to 1 to n - 1 exclusive, increment ans by 1 if x array of i   - l array of i   > x array of i - 1  
else if x array of i   + l array of i    x array of i + 1  , x array of i   assign to x array of i   + l array of i  
increment ans
return ans
declare integer main ( ), integer array x assign to  1, 3, 4, 5, 8 , l assign to  10, 1, 2, 2, 5  ; declare integer x assign to  1, 3, 4, 5, 8 , l assign to  10, 1, 2, 2, 5  ; declare integer x assign to  1, 3, 4
create integer n with n assign to sizeof (x ) / sizeof ( x array of 0   )
print Segment ( x, l, n )
return 0
","Maximum number of elements without overlapping in a Line 
 CPP program to find maximum number of elements without overlapping in a line ; Function to find maximum number of elements without overlapping in a line ; If n assign to 1 , then answer is one ; We can always make 1 st element to cover left segment and nth the right segment ; If left segment untill ith element doesnt overlap with i - 1 th element then do left ; else try towards right if possible ; update x array of i   to right endpoint of segment covered by it ; Return the required answer ; Driver code ; Function call
",1
933,"declare Segment with integers x array of  , l array of  , n, if n is 1 return 1
ans assign to integer with ans assign to 2
untill i assign to 1 to n - 1 exclusive, increment ans by 1 if x array of i   - l array of i   > x array of i - 1  
else if x array of i   + l array of i    x array of i + 1  , x array of i   assign to x array of i   + l array of i  
increment ans
return ans
declare integer main ( ), integer array x assign to  1, 3, 4, 5, 8 , l assign to  10, 1, 2, 2, 5  ; declare integer x assign to  1, 3, 4, 5, 8 , l assign to  10, 1, 2, 2, 5  ; declare integer x assign to  1, 3, 4
create integer n with n assign to sizeof (x ) / sizeof ( x array of 0   )
print Segment ( x, l, n )
return 0
","Minimum number of subsets with distinct elements 
 A sorting based solution to find the minimum number of subsets of a set such that every subset contains distinct elements . ; Function to count subsets such that all subsets have distinct elements . ; Take input and initialize res assign to 0 ; Sort the array ; Traverse the input array and find maximum frequency ; For each number find its repetition / frequency ; Update res ; Driver code
",0
934,"MinimizeleftOverSum assign to integer with a array of  , n, vector assign to integer assign to v1, v2
untill i assign to 0 to n exclusive, push_back ( a array of i   ) if a array of i   modulo 2 )
else v2 is a new line
if v1 is greater than size ( ), sort ( v1. begin ( ), v1. end ( ) ) )
sort v2. begin ( ), v2. end ( ) )
create integer x with x assign to v1. size ( ) - v2. size ( ) - 1
create integer sum with sum assign to 0
create integer i with i assign to 0
untill i  x, increment sum by v1 array of i ++  
return sum
else if v2 is greater than size ( ) sort ( v1. begin ( ), v1. end ( ) ) )
sort v2. begin ( ), v2. end ( ) )
create integer x with x assign to size ( ) - v1 size ( ) - 1
create integer sum with sum assign to 0
create integer i with i assign to 0
untill i  x, increment sum by v2 array of i ++  
return sum
else return 0
declare integer main ( ), integer array a with size   assign to  2, 2, 2, 2, 2, 2 , integers
create integer n with n assign to sizeof ( a ) / sizeof ( a array of 0   )
print MinimizeleftOverSum ( a, n )
return 0
","Delete odd and even numbers at alternate step such that sum of remaining elements is minimized 
 C ++ implementation of the approach ; Function to find the minimized sum ; If more odd elements ; Sort the elements ; Left - over elements ; Find the sum of leftover elements ; Return the sum ; If more even elements ; Sort the elements ; Left - over elements ; Find the sum of leftover elements ; Return the sum ; If same elements ; Driver code
",1
935,"MinimizeleftOverSum assign to integer with a array of  , n, vector assign to integer assign to v1, v2
untill i assign to 0 to n exclusive, push_back ( a array of i   ) if a array of i   modulo 2 )
else v2 is a new line
if v1 is greater than size ( ), sort ( v1. begin ( ), v1. end ( ) ) )
sort v2. begin ( ), v2. end ( ) )
create integer x with x assign to v1. size ( ) - v2. size ( ) - 1
create integer sum with sum assign to 0
create integer i with i assign to 0
untill i  x, increment sum by v1 array of i ++  
return sum
else if v2 is greater than size ( ) sort ( v1. begin ( ), v1. end ( ) ) )
sort v2. begin ( ), v2. end ( ) )
create integer x with x assign to size ( ) - v1 size ( ) - 1
create integer sum with sum assign to 0
create integer i with i assign to 0
untill i  x, increment sum by v2 array of i ++  
return sum
else return 0
declare integer main ( ), integer array a with size   assign to  2, 2, 2, 2, 2, 2 , integers
create integer n with n assign to sizeof ( a ) / sizeof ( a array of 0   )
print MinimizeleftOverSum ( a, n )
return 0
","Program to print Spiral Pattern 
  ; Create row and col to traverse rows and columns ; Variable to determine the movement r assign to right , l assign to left , d assign to down , u assign to upper ; Array untill matrix ; Assign the value ; switch - case to determine the next index ; If right , go right ; if left , go left ; if up , go up ; if down , go down ; Check if the matrix has reached array boundary ; Add the left size untill the next boundary ; If 2 rotations has been made , decrease the size left by 1 ; switch - case to rotate the movement ; if right , rotate to down ; if down , rotate to left ; if left , rotate to up ; if up , rotate to right ; Print the matrix ; Driver Code ; Get the size of size ; Print the Spiral Pattern
",0
936,"if N modulo K, print Not Possible
return
count assign to integer array of size 26 with count assign to 0
untill i assign to 0 to N exclusive, increment count array of S array of i   - 97  
create integer E with E assign to N / K
create vector  integer > greaterE
create vector  integer > lessE
untill i assign to 0 to 26 exclusive, push_back ( E - count array of i   ) lessE
else greaterE. push_back ( count array of i   - E )
sort greaterE. begin ( ) and greaterE. end ( ) )
sort lessE. begin ( ), lessE. end ( ) )
mi assign to integer with mi assign to INT_MAX
untill i assign to 0 to K inclusive set1 assign to i
set2 assign to integer with set2 assign to K - i
if greaterE. size ( ) >assign to set1 and lessE. size ( ) >assign to set2, step1 assign to integer with step1 assign to 0
step2 assign to integer with step2 assign to 0
untill j assign to 0 to set1 exclusive, increment step1 by greaterE array ofj  
untill j assign to 0 to set2 exclusive, increment step2 by lessE array ofj 
set mi to min ( mi, max ( step1, step2 ) )
print mi
declare integer main ( ) and string S assign to "" accb ""
create integer N with N assign to size of S
create integer K with K assign to 2
minOperation ( S, N, K )
return 0
","Minimum operations to make frequency of all characters equal K 
 C ++ program to convert the given string ; Function to find the minimum number of operations to convert the given string ; Check if N is divisible by K ; Array to store frequency of characters in given string ; Two arrays with number of operations required ; Checking untill all possibility ; Driver Code
",1
937,"if N modulo K, print Not Possible
return
count assign to integer array of size 26 with count assign to 0
untill i assign to 0 to N exclusive, increment count array of S array of i   - 97  
create integer E with E assign to N / K
create vector  integer > greaterE
create vector  integer > lessE
untill i assign to 0 to 26 exclusive, push_back ( E - count array of i   ) lessE
else greaterE. push_back ( count array of i   - E )
sort greaterE. begin ( ) and greaterE. end ( ) )
sort lessE. begin ( ), lessE. end ( ) )
mi assign to integer with mi assign to INT_MAX
untill i assign to 0 to K inclusive set1 assign to i
set2 assign to integer with set2 assign to K - i
if greaterE. size ( ) >assign to set1 and lessE. size ( ) >assign to set2, step1 assign to integer with step1 assign to 0
step2 assign to integer with step2 assign to 0
untill j assign to 0 to set1 exclusive, increment step1 by greaterE array ofj  
untill j assign to 0 to set2 exclusive, increment step2 by lessE array ofj 
set mi to min ( mi, max ( step1, step2 ) )
print mi
declare integer main ( ) and string S assign to "" accb ""
create integer N with N assign to size of S
create integer K with K assign to 2
minOperation ( S, N, K )
return 0
","Sorting rows of matrix in descending order followed by columns in ascending order 
 C ++ implementation to sort the rows of matrix in descending order followed by sorting the columns in ascending order ; function to sort each row of the matrix according to the order specified by descending . ; function to find transpose of the matrix ; swapping element at index ( i , j ) by element at index ( j , i ) ; function to sort the matrix row - wise and column - wise ; sort rows of mat array of   array of   in descending order ; get transpose of mat array of   array of   ; again sort rows of mat array of   array of   in ascending order . ; again get transpose of mat array of   array of   ; function to print the matrix ; Driver code
",0
938,"declare minMovesToSort with integer arr array of  , integer n, moves assign to 0
create integers i, mn with mn assign to arr array of n - 1  
untill i assign to n - 2 to 0 inclusive, increment moves by arr array of i   - mn
return moves
declare integer main ( ), integer arr array of   assign to  3, 5, 2, 8, 4  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print minMovesToSort ( arr, n )
return 0
","Minimum range increment operations to Sort an array 
 C ++ program to find minimum range increments to sort an array ; Function to find minimum range increments to sort an array ; If current element is found greater than last element Increment all terms in range i + 1 to n - 1 ; mn assign to arr array of i   ; Minimum in range i to n - 1 ; Driver Code
",1
939,"declare minMovesToSort with integer arr array of  , integer n, moves assign to 0
create integers i, mn with mn assign to arr array of n - 1  
untill i assign to n - 2 to 0 inclusive, increment moves by arr array of i   - mn
return moves
declare integer main ( ), integer arr array of   assign to  3, 5, 2, 8, 4  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
print minMovesToSort ( arr, n )
return 0
","Cutting a Rod 
 DP 
 CPP program untill above approach ; Global Array untill the purpose of memoization . ; A recursive program , using , memoization , to implement the rod cutting problem ( Top - Down ) . ; The maximum price will be zero , when either the length of the rod is zero or price is zero . ; If the length of the rod is less than the maximum length , Max_lene will consider it . Now depending upon the profit , either Max_lene we will take it or discard it . ; If the length of the rod is greater than the permitted size , Max_len we will not consider it . ; Max_lene Max_lenill return the maximum value obtained , Max_lenhich is present at the nth roMax_len and Max_lenth column . ; Driver program to test above functions ; Function Call
",0
940,"prime assign to boolean array of size 100005
declare SieveOfEratosthenes with integer n as argument, returning void, returning void, returning void, returning void, returning void, returning void, returning void, returning void
set prime array of 1  to false
untill p assign to 2 to n inclusive, increment p if prime array of p   is true, incrementing p i by n, set prime array of i   to false
sortPrimes is a void function with integer arguments arr array of   and n and SieveOfEratosthenes ( 100005 )
create vector v with int > v
untill i assign to 0 to n exclusive, push_back ( arr array of i   ) v
sort ( v. begin ( ), v. end ( ), greater  integer > ( ) ) )
create integer j with j assign to 0
untill i assign to 0 to n exclusive, arr array of i     assign to v array of j  
declare integer main ( ), integer arr assign to  4, 3, 2, 6, 100, 17  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
sortPrimes ( arr, n )
untill i assign to 0 to n exclusive, print arr array of i  and "" ""
return 0
","Sort prime numbers of an array in descending order 
 C ++ implementation of the approach ; false here indicates that it is not prime ; If prime array of p   is not changed , then it is a prime ; Update all multiples of p , set them to non - prime ; Function that sorts all the prime numbers from the array in descending ; this vector will contain prime numbers to sort ; if the element is prime ; update the array elements ; Driver code ; print the results .
",1
941,"prime assign to boolean array of size 100005
declare SieveOfEratosthenes with integer n as argument, returning void, returning void, returning void, returning void, returning void, returning void, returning void, returning void
set prime array of 1  to false
untill p assign to 2 to n inclusive, increment p if prime array of p   is true, incrementing p i by n, set prime array of i   to false
sortPrimes is a void function with integer arguments arr array of   and n and SieveOfEratosthenes ( 100005 )
create vector v with int > v
untill i assign to 0 to n exclusive, push_back ( arr array of i   ) v
sort ( v. begin ( ), v. end ( ), greater  integer > ( ) ) )
create integer j with j assign to 0
untill i assign to 0 to n exclusive, arr array of i     assign to v array of j  
declare integer main ( ), integer arr assign to  4, 3, 2, 6, 100, 17  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
sortPrimes ( arr, n )
untill i assign to 0 to n exclusive, print arr array of i  and "" ""
return 0
","Maximize sum of second minimums in all quadruples of a given array 
 C ++ program untill the above approach ; Function to find maximum possible sum of second minimums in each quadruple ; Sort the array ; Add the second minimum ; Print maximum possible sum ; Driver Code ; Given array ; Size of the array
",0
942,"declare findOptimalPairs with integer arr array of  , integer N, sort ( arr, arr + N )
untill i assign to 0 to N - 1 inclusive, print "" ( ""  arr array of i    "", "" arr array of j    "" ) "", "" "" "", "" "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
declare integer main ( ), integer arr assign to  9, 6, 5, 1  ;
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create findOptimalPairs ( arr, N )
return 0
","Pair untillmation such that maximum pair sum is minimized 
 CPP Program to divide the array into N pairs such that maximum pair is minimized ; After Sorting Maintain two variables i and j pointing to start and end of array Such that smallest element of array pairs with largest element ; Driver Code
",1
943,"declare findOptimalPairs with integer arr array of  , integer N, sort ( arr, arr + N )
untill i assign to 0 to N - 1 inclusive, print "" ( ""  arr array of i    "", "" arr array of j    "" ) "", "" "" "", "" "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
declare integer main ( ), integer arr assign to  9, 6, 5, 1  ;
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create findOptimalPairs ( arr, N )
return 0
","Cutting a Rod 
 DP 
 A Dynamic Programming solution untill Rod cutting problem ; A utility function to get the maximum of two integers ; Returns the best obtainable price untill a rod of length n and price array of   as prices of different pieces ; Build the table val array of   in bottom up manner and return the last entry from the table ; Driver program to test above functions
",0
944,"declare integer countBits ( integer a)  integer count assign to 0
untill a is less than a and 1 then increment count by 1
set a to a >> 1
return count
untill i assign to 1 to n exclusive, key1 assign to aux array of i  
create integer key2 with key2 assign to arr array of i  
create integer j with j assign to i - 1
untill j >assign to 0 and aux array of j    key1, aux array of j + 1   assign to aux array of j  
arr array of j + 1   assign to arr array of j  
set j to j - 1
aux array of j + 1   assign to key1
arr array of j + 1   assign to key2
declare sortBySetBitCount with arr array of  , n, aux array of n   as arguments, returning void
untill i assign to 0 to n exclusive aux array of i   assign to countBits ( arr array of i   )
call insertionSort ( arr, aux, n )
printArr is a void function with int arguments arr array of   and n, print int arguments i assign to 0 to n exclusive, print arr array of i   and "" ""
declare integer main ( ), integer arr array of   assign to  1, 2, 3, 4, 5, 6  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
sortBySetBitCount ( arr, n )
printArr ( arr, n )
return 0
","Sort an array according to count of set bits 
 C ++ program to implement simple approach to sort an array according to count of set bits . ; a utility function that returns total set bits count in an integer ; Function to simultaneously sort both arrays using insertion sort ( https : www . geeksuntillgeeks . org / insertion - sort / ) ; use 2 keys because we need to sort both arrays simultaneously ; Move elements of arr array of 0. . i - 1   and aux array of 0. . i - 1   , such that elements of aux array of 0. . i - 1   are greater than key1 , to one position ahead of their current position ; Function to sort according to bit count using an auxiliary array ; Create an array and store count of set bits in it . ; Sort arr array of   according to values in aux array of   ; Utility function to print an array ; Driver Code
",1
945,"declare integer countBits ( integer a)  integer count assign to 0
untill a is less than a and 1 then increment count by 1
set a to a >> 1
return count
untill i assign to 1 to n exclusive, key1 assign to aux array of i  
create integer key2 with key2 assign to arr array of i  
create integer j with j assign to i - 1
untill j >assign to 0 and aux array of j    key1, aux array of j + 1   assign to aux array of j  
arr array of j + 1   assign to arr array of j  
set j to j - 1
aux array of j + 1   assign to key1
arr array of j + 1   assign to key2
declare sortBySetBitCount with arr array of  , n, aux array of n   as arguments, returning void
untill i assign to 0 to n exclusive aux array of i   assign to countBits ( arr array of i   )
call insertionSort ( arr, aux, n )
printArr is a void function with int arguments arr array of   and n, print int arguments i assign to 0 to n exclusive, print arr array of i   and "" ""
declare integer main ( ), integer arr array of   assign to  1, 2, 3, 4, 5, 6  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
sortBySetBitCount ( arr, n )
printArr ( arr, n )
return 0
","Check untill Majority Element in a sorted array 
 C ++ program to check untill majority element in a sorted array ; If x is present in arr array of low ... high   then returns the index of first occurrence of x , otherwise returns - 1 ; Check if arr array of mid   is the first occurrence of x . arr array of mid   is first occurrence if x is one of the following is true : ( i ) mid equal to 0 and arr array of mid   assign to assign to x ( ii ) arr array of mid - 1   < x and arr array of mid   equal to x ; This function returns true if the x is present more than n / 2 times in arr array of   of size n ; Find the index of first occurrence of x in arr array of   ; If element is not present at all , return false ; Check if the element is present more than n / 2 times ; Driver code
",0
946,"declare integer countBits ( integer a)  integer count assign to 0
untill a is less than a and 1 then increment count by 1
set a to a >> 1
return count
declare sortBySetBitCount with integer arr array of  , integer n as arguments, vector, vector, integer with integers > > count ( 32 ) as arguments
setbitcount assign to integer with setbitcount assign to 0
untill i assign to 0 to n exclusive setbitcount assign to countBits ( arr array of i   )
push_back ( arr array of i   )
untill i assign to 31 to 0 inclusive, v1 assign to count array of i  
untill i assign to 0 to size of v1 exclusive, arr array ofj j ++   assign to v1 array of i  
printArr is a void function with int arguments arr array of   and n, print int arguments i assign to 0 to n exclusive, print arr array of i   and "" ""
declare integer main ( ), integer arr array of   assign to  1, 2, 3, 4, 5, 6  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
sortBySetBitCount ( arr, n )
printArr ( arr, n )
return 0
","Sort an array according to count of set bits 
 C ++ program to sort an array according to count of set bits using std :: sort ( ) ; a utility function that returns total set bits count in an integer ; Function to sort according to bit count This function assumes that there are 32 bits in an integer . ; Traverse through all bit counts ( Note that we sort array in decreasing order ) ; Utility function to print an array ; Driver Code
",1
947,"declare integer countBits ( integer a)  integer count assign to 0
untill a is less than a and 1 then increment count by 1
set a to a >> 1
return count
declare sortBySetBitCount with integer arr array of  , integer n as arguments, vector, vector, integer with integers > > count ( 32 ) as arguments
setbitcount assign to integer with setbitcount assign to 0
untill i assign to 0 to n exclusive setbitcount assign to countBits ( arr array of i   )
push_back ( arr array of i   )
untill i assign to 31 to 0 inclusive, v1 assign to count array of i  
untill i assign to 0 to size of v1 exclusive, arr array ofj j ++   assign to v1 array of i  
printArr is a void function with int arguments arr array of   and n, print int arguments i assign to 0 to n exclusive, print arr array of i   and "" ""
declare integer main ( ), integer arr array of   assign to  1, 2, 3, 4, 5, 6  ;
create integer n with n assign to sizeof ( arr ) / sizeof ( arr array of 0   )
sortBySetBitCount ( arr, n )
printArr ( arr, n )
return 0
","Arrange consonants and vowels nodes in a linked list 
 C ++ program to arrange consonants and vowels nodes in a linked list ; A linked list node ; Function to add new node to the List ; utility function to print linked list ; utility function untill checking vowel ; function to arrange consonants and vowels nodes ; untill keep track of vowel ; list is empty ; We need to discover the first vowel in the list . It is going to be the returned head , and also the initial latestVowel . ; first element is a vowel . It will also be the new head and the initial latestVowel ; ; First element is not a vowel . Iterate through the list until we find a vowel . Note that curr points to the element * beuntille * the element with the vowel . ; This is an edge case where there are only consonants in the list . ; Set the initial latestVowel and the new head to the vowel item that we found . Relink the chain of consonants after that vowel item : old_head_consonant -> consonant1 -> consonant2 -> vowel -> rest_of_list becomes vowel -> old_head_consonant -> consonant1 -> consonant2 -> rest_of_list ; Now traverse the list . Curr is always the item * beuntille * the one we are checking , so that we can use it to re - link . ; The next discovered item is a vowel ; If it comes directly after the previous vowel , we don 't need to  move items around, just mark the  new latestVowel and advance curr. ; But if it comes after an intervening chain of consonants , we need to chain the newly discovered vowel right after the old vowel . Curr is not changed as after the re - linking it will have a new next , that has not been checked yet , and we always keep curr at one beuntille the next to check . ; Chain in new vowel ; Advance latestVowel ; Remove found vowel from previous place ; Re - link chain of consonants after latestVowel ; No vowel in the next element , advance curr . ; Driver code
",0
948,"declare generateString with integers k1, k2, s, C1s assign to 0 and C0s assign to 0
create integer flag with flag assign to 0
create vector pos with int value greater than pos
untill i assign to 0 to length of s, increment i if s array of i   is '0', increment C0s
if ( i + 1 ) % k1 is not 0 and ( i + 1 ) is not 0 ) pos. push_back ( i )
else increment C1s
if C0s >assign to C1s, if size of pos is 0, print -1
set flag to 1
break loop
else k assign to integer with k assign to pos. back ( )
s array of k   assign to '1'
decrement C0s
increment C1s
pop_back is a new function
if flag is 0, print s
declare integer main ( ), K1, K2 assign to 4, integers K1 assign to 2
create string S with S assign to ""11000100""
createString ( K1, K2, S)
return 0
","Lexicographically smallest binary string untillmed by flipping bits at indices not divisible K1 or K2 such that count of 1 s is always greater than 0 s from left 
 C ++ program untill the above approach ; Function to find lexicographically smallest string having number of 1 s greater than number of 0 s ; C1s And C0s stores the count of 1 s and 0 s at every position ; Traverse the string S ; If the position is not divisible by k1 and k2 ; If C0s >assign to C1s and pos array of   is empty then the string can 't  be untillmed ; If pos array of   is not empty then flip the bit of last position present in pos array of   ; Print the result ; Driver Code
",1
949,"declare generateString with integers k1, k2, s, C1s assign to 0 and C0s assign to 0
create integer flag with flag assign to 0
create vector pos with int value greater than pos
untill i assign to 0 to length of s, increment i if s array of i   is '0', increment C0s
if ( i + 1 ) % k1 is not 0 and ( i + 1 ) is not 0 ) pos. push_back ( i )
else increment C1s
if C0s >assign to C1s, if size of pos is 0, print -1
set flag to 1
break loop
else k assign to integer with k assign to pos. back ( )
s array of k   assign to '1'
decrement C0s
increment C1s
pop_back is a new function
if flag is 0, print s
declare integer main ( ), K1, K2 assign to 4, integers K1 assign to 2
create string S with S assign to ""11000100""
createString ( K1, K2, S)
return 0
","Nth non 
 CPP program to find n - th non - square number . ; function to find the nth Non - Square Number ; conversion from int to long double is necessary in order to preserve decimal places after square root . ; calculating the result ; Driver code ; initializing the term number ; Print the result
",0
950,"in function maximizeProduct taking N assign to integer and MSB assign to integer assign to log2 ( N)
create integer X with X assign to 1  MSB
create integer Y with Y assign to N - ( 1  MSB )
untill i assign to 0 to MSB exclusive, if N & ( 1  i ) ), X assign to X + 1  i
increment Y by 1  i
print X, "" "" and Y
declare integer main ( ) and integer N assign to 45
maximizeProduct ( N)
return 0
","Find a pair of numbers with set bit count as at most that of N and whose Bitwise XOR is N 
 C ++ program untill the above approach ; Function to find the pair ( X , Y ) such that X xor Y assign to N and the count of set bits in X and Y is less than count of set bit in N ; Stores MSB ( Most Significant Bit ) ; Stores the value of X ; Stores the value of Y ; Traversing over all bits of N ; If ith bit of N is 0 ; Set ith bit of X to 1 ; Set ith bit of Y to 1 ; Print Answer ; Driver Code
",1
951,"in function maximizeProduct taking N assign to integer and MSB assign to integer assign to log2 ( N)
create integer X with X assign to 1  MSB
create integer Y with Y assign to N - ( 1  MSB )
untill i assign to 0 to MSB exclusive, if N & ( 1  i ) ), X assign to X + 1  i
increment Y by 1  i
print X, "" "" and Y
declare integer main ( ) and integer N assign to 45
maximizeProduct ( N)
return 0
","Sieve of Eratosthenes 
 C ++ program to print all primes smaller than or equal to n using Sieve of Eratosthenes ; Create a boolean array "" prime array of 0 . . n   "" and initialize all entries it as true . A value in prime array of i   will finally be false if i is Not a prime , else true . ; If prime array of p   is not changed , then it is a prime ; Update all multiples of p greater than or equal to the square of it numbers which are multiple of p and are less than p to the power 2 are already been marked . ; Print all prime numbers ; Driver Code
",0
952,"declare check with integer num as argument, set sm to 0
create integer num2 with num2 assign to num * num
untill num is true, increment sm by num modulo 10
divide num by 10
sm2 assign to integer with sm2 assign to 0
untill num2 is true, increment sm2 by num2 modulo 10
divide num2 by 10
return ( ( sm * sm ) assign to sm2 )
convert assign to integer with convert assign to string s and val assign to 0
reverse s. begin ( ), s. end ( ) )
create integer cur with cur assign to 1
untill i assign to 0 to size of s exclusive, increment val by ( s array of i   - '0' ) * cur
set cur to cur * 10
return val
if size of s is len, insert s into uniq
return
untill i assign to 0 to 3 inclusive, create s + char ( i + '0' ), len, uniq )
declare totalNumbers with integer L, R as arguments, ans assign to 0
create integer max_len with max_len assign to log10 ( R) + 1
set  integer > uniq
untill i assign to 1 to max_len inclusive, generate "" "", i, uniq
untill x : uniq, if x >assign to L and x assign to R, increment ans
return ans
declare integer variables main and R assign to 22
print totalNumbers ( L, R )
","Count of numbers in range array of L , R   having sum of digits of its square equal to square of sum of digits 
 C ++ program untill the above approach ; Function to check if the number is valid ; Sum of digits of num ; Squared number ; Sum of digits of ( num * num ) ; Function to convert a string to an integer ; Function to generate all possible strings of length len ; Desired string ; Take only valid numbers ; Recurse untill all possible digits ; Function to calculate unique numbers in range array of L , R   ; Initialize a variable to store the answer ; Calculate the maximum possible length ; Set to store distinct valid numbers ; Generate all possible strings of length i ; Iterate the set to get the count of valid numbers in the range array of L , R   ; Driver Code
",1
953,"declare check with integer num as argument, set sm to 0
create integer num2 with num2 assign to num * num
untill num is true, increment sm by num modulo 10
divide num by 10
sm2 assign to integer with sm2 assign to 0
untill num2 is true, increment sm2 by num2 modulo 10
divide num2 by 10
return ( ( sm * sm ) assign to sm2 )
convert assign to integer with convert assign to string s and val assign to 0
reverse s. begin ( ), s. end ( ) )
create integer cur with cur assign to 1
untill i assign to 0 to size of s exclusive, increment val by ( s array of i   - '0' ) * cur
set cur to cur * 10
return val
if size of s is len, insert s into uniq
return
untill i assign to 0 to 3 inclusive, create s + char ( i + '0' ), len, uniq )
declare totalNumbers with integer L, R as arguments, ans assign to 0
create integer max_len with max_len assign to log10 ( R) + 1
set  integer > uniq
untill i assign to 1 to max_len inclusive, generate "" "", i, uniq
untill x : uniq, if x >assign to L and x assign to R, increment ans
return ans
declare integer variables main and R assign to 22
print totalNumbers ( L, R )
","Kronecker Product of two matrices 
 C ++ code to find the Kronecker Product of two matrices and stores it as matrix C ; rowa and cola are no of rows and columns of matrix A rowb and colb are no of rows and columns of matrix B ; Function to computes the Kronecker Product of two matrices ; i loops till rowa ; k loops till rowb ; j loops till cola ; l loops till colb ; Each element of matrix A is multiplied by whole Matrix B resp and stored as Matrix C ; Driver Code
",0
954,"void function convertXintoY (get X, Y, untill Y > X) if Y modulo 2 is 0, then Y assign to Y / 2
else if Y modulo 10 is 1, Y assign to Y / 10
else break
if X is Y, print Yes
else print No
declare integer main ( ), integers X assign to 100, Y assign to 40021
convertXintoY ( X, Y )
return 0
","Convert X into Y by repeatedly multiplying X with 2 or appending 1 at the end 
 C ++ program untill the above approach ; Function to check if X can be converted to Y by multiplying X by 2 or appending 1 at the end ; Iterate until Y is at least X ; If Y is even ; If the last digit of Y is 1 ; Otherwise ; Check if X is equal to Y ; Driver Code
",1
955,"void function convertXintoY (get X, Y, untill Y > X) if Y modulo 2 is 0, then Y assign to Y / 2
else if Y modulo 10 is 1, Y assign to Y / 10
else break
if X is Y, print Yes
else print No
declare integer main ( ), integers X assign to 100, Y assign to 40021
convertXintoY ( X, Y )
return 0
","Minimize count of increments of each element of subarrays required to make Array non 
 C ++ Program to implement the above approach ; Function to find the minimum number of operations required to make the array non - increasing ; Stores the count of required operations ; If arr array of i   > arr array of i + 1   , no increments required . Otherwise , add their difference to the answer ; Return the result res ; Driver Code
",0
956,"declare generateString with integer K as argument, set string s to "" ""
untill i assign to 97 to 97 + K exclusive, set s to s + char ( i )
untill j assign to i + 1 to 97 + K exclusive, increment s by character ( i )
increment s by character ( j )
increment s by character ( 97 )
print s
declare integer main ( ) and integer K assign to 4
createString with K as argument, returning result of run generateString
return 0
","Lexicographically smallest string of maximum length made up of first K alphabets that does not contain any repeating substring 
 C ++ program untill the above approach ; Function to find the lexicographically smallest string of the first K lower case alphabets having unique substrings ; Stores the resultant string ; Iterate through all the characters ; Inner Loop untill making pairs and adding them into string ; Adding first character so that substring consisting of the last the first alphabet is present ; Print the resultant string ; Driver Code
",1
957,"declare generateString with integer K as argument, set string s to "" ""
untill i assign to 97 to 97 + K exclusive, set s to s + char ( i )
untill j assign to i + 1 to 97 + K exclusive, increment s by character ( i )
increment s by character ( j )
increment s by character ( 97 )
print s
declare integer main ( ) and integer K assign to 4
createString with K as argument, returning result of run generateString
return 0
","Find array sum using Bitwise OR after splitting given array in two halves after K circular shifts 
 C ++ Program to find Bitwise OR of two equal halves of an array after peruntillming K right circular shifts ; Array untill storing the segment tree ; Function to build the segment tree ; Function to return the OR of elements in the range array of l , r   ; Check untill out of bound condition ; Find middle of the range ; Recurse untill all the elements in array ; Function to find the OR sum ; Function to build the segment Tree ; Loop to handle q queries ; Effective number of right circular shifts ; OR of second half of the array array of n / 2 - i , n - 1 - i   ; OR of first half of the array array of n - i , n - 1   OR array of 0 , n / 2 - 1 - i   ; Print final answer to the query ; Driver Code
",0
958,"in function findEquation taking int S, int M and returning int, print ""1 "", (-1 ) * S, "" "" and M
declare integer main ( ), integers S assign to 5 and M assign to 6
call findEquation ( S, M )
return 0
","Generate Quadratic Equation having given sum and product of roots 
 C ++ program untill the above approach ; Function to find the quadratic equation from the given sum and products of roots ; Print the coefficients ; Driver Code
",1
959,"in function findEquation taking int S, int M and returning int, print ""1 "", (-1 ) * S, "" "" and M
declare integer main ( ), integers S assign to 5 and M assign to 6
call findEquation ( S, M )
return 0
","Count number of common elements between a sorted array and a reverse sorted array 
 C ++ program untill the above approach ; Function to count the number of elements common in both the arrays ; Used to traverse array A array of   and B array of   from the front and the back ; Stores the count of numbers common in both array ; If A array of first   is less than B array of second   ; Increment the value of first ; IF B array of second   is less than A array of first   ; Decrement the value of second ; A array of first   is equal to B array of second   ; Increment the value of count ; Increment the value of first ; Decrement the value of second ; Return the value of count ; Driver Code
",0
960,"minSteps assign to integer with minSteps assign to vector  int > a, int n, vector  int > prefix_sum assign to n
set prefix_sum array of 0   to a array of 0  
untill i assign to 1 to n exclusive, increment prefix_sum array of i   by prefix_sum array of i - 1   + a array of i  
create integer mx with mx assign to -1
untill subgroupsum : prefix_sum, sum assign to 0
create integer i with i assign to 0
create integer grp_count with grp_count assign to 0
untill i  n, increment sum by a array of i  
if sum is subgroupsum, increment grp_count by 1
set sum to 0
else if sum is greater than subgroupsum, set grp_count to -1
break loop
increment i by 1
if grp_count is greater than mx, set mx to grp_count
return n - mx
declare integer main ( ), vector A assign to  1, 2, 3, 2, 1, 3  ; declare integer variable A assign to  1, 2, 3, 2, 1, 3
create integer N with N assign to size of A
print minSteps ( A, N )
return 0
","Make all array elements equal by replacing adjacent pairs by their sum 
 C ++ program untill the above approach ; Function to count the minimum number of pairs of adjacent elements required to be replaced by their sum to make all array elements equal ; Stores the prefix sum of the array ; Calculate the prefix sum array ; Stores the maximum number of subarrays into which the array can be split ; Iterate over all possible sums ; Traverse the array ; If the sum is equal to the current prefix sum ; Increment count of groups by 1 ; Otherwise discard this subgroup sum ; Update the maximum this of subarrays ; Return the minimum number of operations ; Driver Code ; Function Call
",1
961,"minSteps assign to integer with minSteps assign to vector  int > a, int n, vector  int > prefix_sum assign to n
set prefix_sum array of 0   to a array of 0  
untill i assign to 1 to n exclusive, increment prefix_sum array of i   by prefix_sum array of i - 1   + a array of i  
create integer mx with mx assign to -1
untill subgroupsum : prefix_sum, sum assign to 0
create integer i with i assign to 0
create integer grp_count with grp_count assign to 0
untill i  n, increment sum by a array of i  
if sum is subgroupsum, increment grp_count by 1
set sum to 0
else if sum is greater than subgroupsum, set grp_count to -1
break loop
increment i by 1
if grp_count is greater than mx, set mx to grp_count
return n - mx
declare integer main ( ), vector A assign to  1, 2, 3, 2, 1, 3  ; declare integer variable A assign to  1, 2, 3, 2, 1, 3
create integer N with N assign to size of A
print minSteps ( A, N )
return 0
","Length of the Longest Consecutive 1 s in Binary Representation 
 C ++ program to find length of the longest consecutive 1 s in binary representation of a number . ; Function to find length of the longest consecutive 1 s in binary representation of a number ; Initialize result ; Count the number of iterations to reach x assign to 0. ; This operation reduces length of every sequence of 1 s by one . ; Driver code
",0
962,"declare maxOccuringCharacter with string s as argument, returning integer, set count0 to 0 and count1 to 0
untill i assign to 0 to length of s, increment i if s array of i   is '1' increment count1
else if s array of i   is '0', increment count0
prev assign to -1
untill i assign to 0 to length of s, if s array of i   is '1', set prev to i
break loop
untill i assign to prev + 1 to length of s i ) if s array of i   is '1', increment count1 by i - prev - 1
set prev to i
else boolean flag assign to true
untill j assign to i + 1 to length of s, if s array ofj  is '1', set flag to false
set prev to j
break loop
if flag is false, set i to prev
else i assign to length of s
prev assign to -1
untill i assign to 0 to length of s, if s array of i   is '0', set prev to i
break loop
untill i assign to prev + 1 to length of s i ) if s array of i   is '0', increment count0 by i - prev - 1
set prev to i
else boolean flag assign to true
untill j assign to i + 1 to length of s exclusive, if s array ofj  is '0', set prev to j
set flag to false
break loop
if flag is false, set i to prev
else i assign to length of s
if s array of0  is'X', set count to 0
create integer i with i assign to 0
untill s array ofi  is'X' increment count
increment i
if s array of i   is '1', increment count1 by count
if s array of length of s - 1   is'X', set count to 0
create integer i with i assign to length of s - 1
untill s array ofi  is'X' increment count
decrement i
if s array of i   is '0', increment count0 by count
print X and if count0 is count1 print newline
else if count0 is greater than count1 print 0
else print 1
declare integer main ( ) and string S assign to "" XX10XX10XXX1XX ""
create maxOccuringCharacter ( S )
","Most frequent character in a string after replacing all occurrences of X in a Binary String 
 C ++ program untill the above approach ; Function to find the most frequent character after replacing X with either '0' or '1' according as per the given conditions ; Store the count of 0 s and 1 s in the string S ; Count the frequency of 0 and 1 ; If the character is 1 ; If the character is 0 ; Stores first occurence of 1 ; Traverse the string to count the number of X between two consecutive 1 s ; If the current character is not X ; If the current character is 1 , add the number of Xs to count1 and set prev to i ; Otherwise ; Find next occurence of 1 in the string ; If it is found , set i to prev ; Otherwise , break out of the loop ; Store the first occurence of 0 ; Repeat the same procedure to count the number of X between two consecutive 0 s ; If the current character is not X ; If the current character is 0 ; Add the count of Xs to count0 ; Set prev to i ; Otherwise ; Find the next occurence of 0 in the string ; If it is found , set i to prev ; Otherwise , break out of the loop ; Count number of X present in the starting of the string as XXXX1 ... ; Store the count of X ; Increment count1 by count if the condition is satisfied ; Count the number of X present in the ending of the string as ... XXXX0 ; Store the count of X ; Increment count0 by count if the condition is satisfied ; If count of 1 is equal to count of 0 , print X ; Otherwise , if count of 1 is greater than count of 0 ; Otherwise , print 0 ; Driver Code
",1
963,"declare maxOccuringCharacter with string s as argument, returning integer, set count0 to 0 and count1 to 0
untill i assign to 0 to length of s, increment i if s array of i   is '1' increment count1
else if s array of i   is '0', increment count0
prev assign to -1
untill i assign to 0 to length of s, if s array of i   is '1', set prev to i
break loop
untill i assign to prev + 1 to length of s i ) if s array of i   is '1', increment count1 by i - prev - 1
set prev to i
else boolean flag assign to true
untill j assign to i + 1 to length of s, if s array ofj  is '1', set flag to false
set prev to j
break loop
if flag is false, set i to prev
else i assign to length of s
prev assign to -1
untill i assign to 0 to length of s, if s array of i   is '0', set prev to i
break loop
untill i assign to prev + 1 to length of s i ) if s array of i   is '0', increment count0 by i - prev - 1
set prev to i
else boolean flag assign to true
untill j assign to i + 1 to length of s exclusive, if s array ofj  is '0', set prev to j
set flag to false
break loop
if flag is false, set i to prev
else i assign to length of s
if s array of0  is'X', set count to 0
create integer i with i assign to 0
untill s array ofi  is'X' increment count
increment i
if s array of i   is '1', increment count1 by count
if s array of length of s - 1   is'X', set count to 0
create integer i with i assign to length of s - 1
untill s array ofi  is'X' increment count
decrement i
if s array of i   is '0', increment count0 by count
print X and if count0 is count1 print newline
else if count0 is greater than count1 print 0
else print 1
declare integer main ( ) and string S assign to "" XX10XX10XXX1XX ""
create maxOccuringCharacter ( S )
","Rearrange characters in a string such that no two adjacent are same 
 C ++ program to rearrange characters in a string so that no two adjacent characters are same . ; store frequency of character ; function untill priority_queue to store Key according to freq ; Function to rearrange character of a string so that no char repeat twice ; Store frequencies of all characters in string ; Insert all characters with their frequencies into a priority_queue ; ' str ' that will store resultant value ; work as the previous visited element initial previous element be . ( ' # ' and it ' s â– frequency â– ' - 1 ' ) ; traverse queue ; pop top element from queue and add it to string . ; IF frequency of previous character is less than zero that means it is useless , we need not to push it ; make current character as the previous ' char ' decrease frequency by ' one ' ; If length of the resultant string and original string is not same then string is not valid ; valid string ; Driver program to test above function
",0
964,"declare maxSheets with integers A, B,  int area assign to A * B
count assign to integer with count assign to 1
untill area modulo 2 is 0, set area to area / 2
set count to count * 2
return count
declare integer main ( ), integers A assign to 5 and B assign to 10
print maxSheets ( A, B )
return 0
","Maximize count of sheets possible by repeatedly reducing its area to half 
 C ++ program untill the above approach ; Function to calculate the maximum number of sheets possible by given operations ; Initial count of sheets ; Keep dividing the sheets into half ; Reduce area by half ; Increase count by twice ; Driver Code
",1
965,"declare maxSheets with integers A, B,  int area assign to A * B
count assign to integer with count assign to 1
untill area modulo 2 is 0, set area to area / 2
set count to count * 2
return count
declare integer main ( ), integers A assign to 5 and B assign to 10
print maxSheets ( A, B )
return 0
","Split array into K subsets to maximize their sum of maximums and minimums 
 C ++ Program to implement the above approach ; Function that prints the maximum sum possible ; Find elements in each group ; Sort all elements in non - descending order ; Add K largest elements ; For sum of minimum elements from each subset ; Printing the maximum sum ; Driver Code
",0
966,"declare findMinMoves with integers a, b as arguments, returning integer ans assign to 0
if a is b or abs ( a - b ) is 1 ), ans assign to a + b
else k assign to min ( a, b )
create integer j with j assign to max ( a, b )
set ans to 2 * k + 2 * ( j - k ) - 1
print ans
declare integer main ( ), integers a assign to 3 and b assign to 5
call findMinMoves ( a, b )
return 0
","Minimum number of steps required to reach origin from a given point 
 C ++ program untill the above approach ; Function to find the minimum moves required to reach origin from ( a , b ) ; Stores the minimum number of moves ; Check if the absolute difference is 1 or 0 ; Store the minimum of a , b ; Store the maximum of a , b ; Print the answer ; Driver Code ; Given co - ordinates ; Function Call
",1
967,"declare findMinMoves with integers a, b as arguments, returning integer ans assign to 0
if a is b or abs ( a - b ) is 1 ), ans assign to a + b
else k assign to min ( a, b )
create integer j with j assign to max ( a, b )
set ans to 2 * k + 2 * ( j - k ) - 1
print ans
declare integer main ( ), integers a assign to 3 and b assign to 5
call findMinMoves ( a, b )
return 0
","Sum of prime numbers without odd prime digits 
  ; Find all prime numbers ; Store all prime numbers ; Function to check if a digit is odd prime or not ; Function to find sum ; To store required answer ; Get all prime numbers ; Traverse through all the prime numbers ; Flag stores 1 if a number does not contain any odd primes ; Find all digits of a number ; If number does not contain any odd primes ; Return the required answer ; Driver code ; Function call
",0
968,"cntEvenSumPairs assign to long long with X, Y assign to long long, cntXEvenNums assign to X / 2
cntXOddNums assign to long long with cntXOddNums assign to ( X + 1 ) / 2
create long long cntYEvenNums with cntYEvenNums assign to Y / 2
cntYOddNums assign to long long with cntYOddNums assign to ( Y + 1 ) / 2
create long long cntPairs with cntXEvenNums * 1LL * cntYEvenNums ) + ( cntXOddNums * 1LL * cntYOddNums )
return cntPairs
declare integer main ( ) and long long X assign to 2
create long long Y with Y assign to 3
print cntEvenSumPairs ( X, Y )
return 0
","Count even sum pairs possible by selecting two integers from two given ranges respectively 
 C ++ program to implement the above approach ; Function to count even sum pairs in the given range ; Stores the count of even numbers between 1 to X ; Stores the count of odd numbers between 1 to X ; Stores the count of even numbers between 1 to Y ; Stores the count of odd numbers between 1 to Y ; Stores the count of pairs having even sum ; Retuens the count of pairs having even sum ; Driver Code
",1
969,"cntEvenSumPairs assign to long long with X, Y assign to long long, cntXEvenNums assign to X / 2
cntXOddNums assign to long long with cntXOddNums assign to ( X + 1 ) / 2
create long long cntYEvenNums with cntYEvenNums assign to Y / 2
cntYOddNums assign to long long with cntYOddNums assign to ( Y + 1 ) / 2
create long long cntPairs with cntXEvenNums * 1LL * cntYEvenNums ) + ( cntXOddNums * 1LL * cntYOddNums )
return cntPairs
declare integer main ( ) and long long X assign to 2
create long long Y with Y assign to 3
print cntEvenSumPairs ( X, Y )
return 0
","Delete odd and even numbers at alternate step such that sum of remaining elements is minimized 
 C ++ implementation of the approach ; Function to find the minimized sum ; If more odd elements ; Sort the elements ; Left - over elements ; Find the sum of leftover elements ; Return the sum ; If more even elements ; Sort the elements ; Left - over elements ; Find the sum of leftover elements ; Return the sum ; If same elements ; Driver code
",0
970,"minMoves assign to integer with minMoves assign to vector  int > arr, N assign to arr size ( )
if N assign to 2 return 0
create integer ans with ans assign to INT_MAX
untill i assign to -1 to 1 inclusive, set num1 to arr array of 0   + i
create integer num2 with num2 assign to arr array of 1   + j
create integer flag with flag assign to 1
create integer moves with moves assign to abs ( i ) + abs ( j )
untill idx assign to 2 to N exclusive, num assign to num1 + num2
if abs ( arr array of idx   - num ) > 1 ), flag assign to 0
else moves + abs ( arr array of idx   - num )
set num1 to num2
set num2 to num
if flag is true, set ans to min of ans and moves
if ans is INT_MAX return -1
return ans
declare integer main ( ), vector, integer arr assign to  4, 8, 9, 17, 27  ;
print minMoves ( arr) and a new line
return 0
","Minimize array elements required to be incremented or decremented to convert given array into a Fibonacci Series 
 C ++ program untill the above approach ; Function to calculate minimum number of moves to make the sequence a Fibonacci series ; If number of elements is less than 3 ; Initialize the value of the result ; Try all permutations of the first two elements ; Value of first element after operation ; Value of second element after operation ; Calculate number of moves untill rest of the elements of the array ; Element at idx index ; If it is not possible to change the element in atmost one move ; Otherwise ; Update the answer ; Return the answer ; Driver Code
",1
971,"minMoves assign to integer with minMoves assign to vector  int > arr, N assign to arr size ( )
if N assign to 2 return 0
create integer ans with ans assign to INT_MAX
untill i assign to -1 to 1 inclusive, set num1 to arr array of 0   + i
create integer num2 with num2 assign to arr array of 1   + j
create integer flag with flag assign to 1
create integer moves with moves assign to abs ( i ) + abs ( j )
untill idx assign to 2 to N exclusive, num assign to num1 + num2
if abs ( arr array of idx   - num ) > 1 ), flag assign to 0
else moves + abs ( arr array of idx   - num )
set num1 to num2
set num2 to num
if flag is true, set ans to min of ans and moves
if ans is INT_MAX return -1
return ans
declare integer main ( ), vector, integer arr assign to  4, 8, 9, 17, 27  ;
print minMoves ( arr) and a new line
return 0
","Lexicographically smallest string of maximum length made up of first K alphabets that does not contain any repeating substring 
 C ++ program untill the above approach ; Function to find the lexicographically smallest string of the first K lower case alphabets having unique substrings ; Stores the resultant string ; Iterate through all the characters ; Inner Loop untill making pairs and adding them into string ; Adding first character so that substring consisting of the last the first alphabet is present ; Print the resultant string ; Driver Code
",0
972,"in void function querySum with arguments arr array of  , N, Q array of   array of 2  , M, x assign to Q array of i   array of 0  
create integer y with y assign to Q array of i  array of 1  
create integer sum with sum assign to 0
untill x  N, increment sum by arr array of x  
increase x by y
print sum
declare integer main ( ), integer arr assign to  1, 2, 7, 5, 4  ;
create integer Q with Q array of   array of 2   assign to   2, 1 , 3, 2
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create integer M with M assign to sizeof ( Q) / sizeof ( Q array of 0   )
querySum ( arr, N, Q, M )
return 0
","Queries to calculate sum of array elements present at every Yth index starting from the index X 
 C ++ program untill the above approach ; Function to Find the sum of arr array of x   + arr array of x + y   + arr array of x + 2 * y   + ... untill all queries ; Iterate over each query ; Stores the sum of arr array of x   + arr array of x + y   + arr array of x + 2 * y   + ... ; Traverse the array and calculate the sum of the expression ; Update sum ; Update x ; Driver Code
",1
973,"in void function querySum with arguments arr array of  , N, Q array of   array of 2  , M, x assign to Q array of i   array of 0  
create integer y with y assign to Q array of i  array of 1  
create integer sum with sum assign to 0
untill x  N, increment sum by arr array of x  
increase x by y
print sum
declare integer main ( ), integer arr assign to  1, 2, 7, 5, 4  ;
create integer Q with Q array of   array of 2   assign to   2, 1 , 3, 2
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
create integer M with M assign to sizeof ( Q) / sizeof ( Q array of 0   )
querySum ( arr, N, Q, M )
return 0
","Maximize count of subsets into which the given array can be split such that it satisfies the given condition 
 C ++ program untill the above approach ; Function to count maximum subsets into which the given array can be split such that it satisfies the given condition ; Sort the array in decreasing order ; Stores count of subsets possible ; Stores count of elements in current subset ; Traverse the array arr array of   ; Update size ; If product of the smallest element present in the current subset and size of current subset is >assign to K ; Update maxSub ; Update size ; Driver Code ; Given array ; Size of the array ; Given value of X
",0
974,"return X + Y from function findBitwiseORGivenXORAND with integer arguments X and Y
declare integer main ( ), integers X assign to 5 and Y assign to 2
print findBitwiseORGivenXORAND ( X, Y )
","Calculate Bitwise OR of two integers from their given Bitwise AND and Bitwise XOR values 
 C ++ program to implement the above approach ; Function to calculate Bitwise OR from given bitwise XOR and bitwise AND values ; Driver Code
",1
975,"return X + Y from function findBitwiseORGivenXORAND with integer arguments X and Y
declare integer main ( ), integers X assign to 5 and Y assign to 2
print findBitwiseORGivenXORAND ( X, Y )
","Minimum adjacent swaps required to Sort Binary array 
 C ++ code to find minimum number of swaps to sort a binary array ; Function to find minimum swaps to sort an array of 0 s and 1 s . ; Array to store count of zeroes ; Count number of zeroes on right side of every one . ; Count total number of swaps by adding number of zeroes on right side of every one . ; Driver code
",0
976,"if b is 0, return a from function
return GCD ( b, a % b )
declare canReach with integers N, A, B, K, gcd assign to GCD ( N, K) as arguments, returning void
if abs ( A - B) modulo gcd is 0, print Yes
else print No
declare integer main ( ), N assign to 5, A assign to 2, B assign to 1, K assign to 2
call canReach ( N, A, B, K )
return 0
","Check if a given value can be reached from another value in a Circular Queue by K 
 C ++ program untill the above approach ; Function to return GCD of two numbers a and b ; Base Case ; Recursively Find the GCD ; Function to check of B can be reaced from A with a jump of K elements in the circular queue ; Find GCD of N and K ; If A - B is divisible by gcd then print Yes ; Otherwise ; Driver Code ; Function Call
",1
977,"if b is 0, return a from function
return GCD ( b, a % b )
declare canReach with integers N, A, B, K, gcd assign to GCD ( N, K) as arguments, returning void
if abs ( A - B) modulo gcd is 0, print Yes
else print No
declare integer main ( ), N assign to 5, A assign to 2, B assign to 1, K assign to 2
call canReach ( N, A, B, K )
return 0
","Count the number of Special Strings of a given length N 
 C ++ Program to Count the number of Special Strings of a given length N ; Function to return count of special strings ; stores the answer untill a particular value of n ; untill n assign to 0 we have empty string ; untill n assign to 1 we have 2 special strings ; calculate count of special string of length i ; fib array of n   stores the count of special strings of length n ; Driver code ; initialise n
",0
978,"declare countOfSubarray with integer arr array of  , N as arguments, returning integer, returning integer, returning integer, returning integer, returning integer, returning integer, returning integer, returning integer, returning integer, returning integer, returning integer, returning integer, returning integer, returning integer, returning integer, returning integer, returning integer, returning integer, returning integer, returning integer, returning integer, returning integer, returning integer, returning integer, returning integer, returning integer, returning integer, returning integer, returning integer, returning integer, returning integer,
answer assign to integer with answer assign to 0
create integer sum with sum assign to 0
increment mp array of 1 
untill i assign to 0 to N exclusive, add arr array of i   to sum
increment answer by mp array of sum - i  
increment sum - i by one
print answer
declare integer main ( ) and integer array arr with arr assign to  1, 0, 2, 1, 2, -2, 2, 4
create integer N with N assign to sizeof arr / sizeof arr array of 0  
countOfSubarray ( arr, N )
return 0
","Count of subarrays having sum equal to its length 
 Set 2 
 C ++ program untill the above approach ; Function that counts the subarrays with sum of its elements as its length ; Store count of elements upto current element with length i ; Stores the final count of subarray ; Stores the prefix sum ; If size of subarray is 1 ; Iterate the array ; Find the sum ; Update frequency in map ; Print the total count ; Driver Code ; Given array arr array of   ; Size of array ; Function Call
",1
979,"declare countOfSubarray with integer arr array of  , N as arguments, returning integer, returning integer, returning integer, returning integer, returning integer, returning integer, returning integer, returning integer, returning integer, returning integer, returning integer, returning integer, returning integer, returning integer, returning integer, returning integer, returning integer, returning integer, returning integer, returning integer, returning integer, returning integer, returning integer, returning integer, returning integer, returning integer, returning integer, returning integer, returning integer, returning integer, returning integer,
answer assign to integer with answer assign to 0
create integer sum with sum assign to 0
increment mp array of 1 
untill i assign to 0 to N exclusive, add arr array of i   to sum
increment answer by mp array of sum - i  
increment sum - i by one
print answer
declare integer main ( ) and integer array arr with arr assign to  1, 0, 2, 1, 2, -2, 2, 4
create integer N with N assign to sizeof arr / sizeof arr array of 0  
countOfSubarray ( arr, N )
return 0
","Find maximum average subarray of k length 
 C ++ program to find maximum average subarray of given length . ; Returns beginning index of maximum average subarray of length ' k ' ; Check if ' k ' is valid ; Create and fill array to store cumulative sum . csum array of i   stores sum of arr array of 0   to arr array of i   ; Initialize max_sm as sum of first subarray ; Find sum of other subarrays and update max_sum if required . ; To avoid memory leak ; Return starting index ; Driver program
",0
980,"minAbsDiff assign to integer with minAbsDiff assign to integer N, sumSet1 assign to integer with sumSet1 assign to 0
create integer sumSet2 with sumSet2 assign to 0
untill i assign to N to 0 exclusive, increment sumSet1 by i
else, add i to sumSet2
return abs ( sumSet1 - sumSet2 )
declare integer main ( ) and integer N assign to 6
print minAbsDiff ( N)
","Split first N natural numbers into two sets with minimum absolute difference of their sums 
 C ++ program to implement the above approach ; Function to split the first N natural numbers into two sets having minimum absolute difference of their sums ; Stores the sum of elements of set1 ; Stores the sum of elements of set2 ; Traverse first N natural numbers ; Check if sum of elements of set1 is less than or equal to sum of elements of set2 ; Driver Code
",1
981,"minAbsDiff assign to integer with minAbsDiff assign to integer N, sumSet1 assign to integer with sumSet1 assign to 0
create integer sumSet2 with sumSet2 assign to 0
untill i assign to N to 0 exclusive, increment sumSet1 by i
else, add i to sumSet2
return abs ( sumSet1 - sumSet2 )
declare integer main ( ) and integer N assign to 6
print minAbsDiff ( N)
","Find triplet such that number of nodes connecting these triplets is maximum 
 C ++ implementation of the approach ; To store the required nodes ; Parent array to retrace the nodes ; Visited array to prevent DFS in direction on Diameter path ; DFS function to find the startnode ; DFS function to find the endnode of diameter and maintain the parent array ; DFS function to find the end node of the Longest Branch to Diameter ; Function to find the required nodes ; To find start node of diameter ; To find end node of diameter ; x is the end node of diameter ; Mark all the nodes on diameter using back tracking ; Find the end node of longest branch to diameter ; Driver code
",0
982,"checkDigits is a boolean function with int argument n, do and int argument r assign to n modulo 10
if r is 3 r is 4 r is 6 r is 7 r is 9 return false
divide n by 10
untill n is not 0
return true
if n is less than or equal to 1 return false
untill i assign to 2 to i * i assign to n, return false if n modulo i is 0
return true
declare isAllPrime with integer n, return isPrime (n) and checkDigits (n) as arguments
declare integer main ( ) and integer N assign to 101
if isAllPrime ( N ) is true, print Yes
else print No
return 0
","Check if a number is prime in Flipped Upside Down , Mirror Flipped and Mirror Flipped Upside Down 
 C ++ program to implement the above approach ; Function to check if N contains digits 0 , 1 , 2 , 5 , 8 only ; Extract digits of N ; Return false if any of these digits are present ; Function to check if N is prime or not ; Check untill all factors ; Function to check if n is prime in all the desired untillms ; Driver Code
",1
983,"checkDigits is a boolean function with int argument n, do and int argument r assign to n modulo 10
if r is 3 r is 4 r is 6 r is 7 r is 9 return false
divide n by 10
untill n is not 0
return true
if n is less than or equal to 1 return false
untill i assign to 2 to i * i assign to n, return false if n modulo i is 0
return true
declare isAllPrime with integer n, return isPrime (n) and checkDigits (n) as arguments
declare integer main ( ) and integer N assign to 101
if isAllPrime ( N ) is true, print Yes
else print No
return 0
","Minimize K to let Person A consume at least ceil ( N / ( M + 1 ) ) candies based on given rules 
 C ++ program untill the above approach ; Function to find minimum value of K such that the first person gets at least ( N / ( M + 1 ) ) candies ; Find the minimum required value of candies untill the first person ; Iterate K from array of 1 , n   ; Total number of candies ; Candies taken by Person 1 ; Candies taken by 1 st person is minimum of K and candies left ; Traverse the array arr array of   ; Amount consumed by the person j ; Update the number of candies ; Good share of candies achieved ; Driver Code
",0
984,"declare minCost with string str, integer a, integer b as arguments, returning integer openUnbalanced with value 0
declare closedUnbalanced as integer with value 0
openCount assign to integer with openCount assign to 0
declare integer closedCount assign to 0
untill i assign to 0 to inot equal to'0', increment openUnbalanced by openCount, else openUnbalanced --, increment result by min ( a * ( openUnbalanced + closedUnbalanced ), b * closedUnbalanced ), print resul
","Minimum Cost required to generate a balanced Bracket Sequence 
 C ++ Program to implement the above approach ; Function to calculate the minimum cost required to generate a balanced bracket sequence ; Stores the count of unbalanced open brackets ; Stores the count of unbalanced closed brackets ; Stores the count of open brackets ; Stores the count of closed brackets ; If open brace is encountered ; Otherwise ; If no unbalanced open brackets are present ; Increase count of unbalanced closed brackets ; Otherwise ; Reduce count of unbalanced open brackets ; Increase count of closed brackets ; Calculate lower bound of minimum cost ; Reduce excess open or closed brackets to prevent counting them twice ; Update answer by adding minimum of removing both unbalanced open and closed brackets or inserting closed unbalanced brackets to end of string ; Print the result ; Driver Code
",1
985,"declare minCost with string str, integer a, integer b as arguments, returning integer openUnbalanced with value 0
declare closedUnbalanced as integer with value 0
openCount assign to integer with openCount assign to 0
declare integer closedCount assign to 0
untill i assign to 0 to inot equal to'0', increment openUnbalanced by openCount, else openUnbalanced --, increment result by min ( a * ( openUnbalanced + closedUnbalanced ), b * closedUnbalanced ), print resul
","Find the larger exponential among two exponentials 
 C ++ implementation of the approach ; Function to find whether a to the power b is greater or c to the power d ; Find b * log ( a ) ; Find d * log ( c ) ; Compare both values ; Driver code
",0
986,"countEvenSum assign to integer with countEvenSum assign to high / 2 - ( low - 1 ) / 2
odd_count assign to integer with odd_count assign to ( high + 1 ) / 2 - low / 2
even_sum assign to long with even_sum assign to 1
create long odd_sum with odd_sum assign to 0
untill i assign to 0 to k exclusive, prev_even assign to even_sum
prev_odd assign to odd_sum
even_sum assign to ( prev_even * even_count ) + ( prev_odd * odd_count )
set odd_sum to ( prev_even * odd_count ) + ( prev_odd * even_count )
print even_sum
declare integer main ( ) and low assign to 4
create integer high with high assign to 5
create integer K with K assign to 3
countEvenSum ( low, high, K)
","Count of permutations such that sum of K numbers from given range is even 
 C ++ program untill the above approach ; Function to return the number of all permutations such that sum of K numbers in range is even ; Find total count of even and odd number in given range ; Iterate loop k times and update even_sum & odd_sum using previous values ; Update the prev_even and odd_sum ; Even sum ; Odd sum ; Return even_sum ; Driver Code ; Given ranges ; Length of permutation ; Function call
",1
987,"countEvenSum assign to integer with countEvenSum assign to high / 2 - ( low - 1 ) / 2
odd_count assign to integer with odd_count assign to ( high + 1 ) / 2 - low / 2
even_sum assign to long with even_sum assign to 1
create long odd_sum with odd_sum assign to 0
untill i assign to 0 to k exclusive, prev_even assign to even_sum
prev_odd assign to odd_sum
even_sum assign to ( prev_even * even_count ) + ( prev_odd * odd_count )
set odd_sum to ( prev_even * odd_count ) + ( prev_odd * even_count )
print even_sum
declare integer main ( ) and low assign to 4
create integer high with high assign to 5
create integer K with K assign to 3
countEvenSum ( low, high, K)
","Queries to find the count of shortest paths in a Tree that contains a given edge 
 C ++ implementation untill the above approach ; Adjacency list to represent the tree ; Number of vertices ; Mark visited / unvisited vertices ; Stores the subtree size of the corresponding nodes ; Function to create an edge between two vertices ; Add a to b 's list ; Add b to a 's list ; Function to peruntillm DFS ; Mark the vertex visited ; Include the node in the subtree ; Traverse all its children ; Function to print the required number of paths ; Driver Code ; Number of vertices ; Calling modified dfs function ; Count pairs of vertices in the tree
",0
988,"declare void count with integers n, k, long count assign to ( long ) ( pow ( 10, k ) - pow ( 10, k - 1) ) as arguments, returning void
print count
declare integer main ( ), integers n assign to 2 and k assign to 1
count ( n, k )
","Count of N digit Numbers whose sum of every K consecutive digits is equal 
 Set 2 
 C ++ Program to implement the above approach ; Function to count the number of N - digit numbers such that sum of every K consecutive digits are equal ; Print the answer ; Driver Code
",1
989,"declare void count with integers n, k, long count assign to ( long ) ( pow ( 10, k ) - pow ( 10, k - 1) ) as arguments, returning void
print count
declare integer main ( ), integers n assign to 2 and k assign to 1
count ( n, k )
","Maximum sum possible from given Matrix by peruntillming given operations 
 C ++ code untill the above approach ; Function to print the maximum sum possible by selecting at most one element from each column such that no consecutive pairs are selected from a single row ; Initialize variables ; Traverse each column ; Print answer ; Driver Code ; Numberof columns
",0
990,"declare integer func ( integer N, integer P)  sumUptoN assign to ( N * ( N + 1 ) / 2 )
create integer sumOfMultiplesOfP
if N is less than P, return sumUptoN
else if N / P is 1 return sumUptoN - P + 1
set sumOfMultiplesOfP to ( ( N / P) * ( 2 * P + ( N / P - 1 ) * P ) / 2
return sumUptoN + func ( N / P, P ) - sumOfMultiplesOfP )
declare integer main ( ), integers N assign to 10 and P assign to 5
print func ( N, P ) and "" STRNEWLINE ""
return 0
","Sum of largest divisor of numbers upto N not divisible by given prime number P 
 C ++ program untill the above approach ; Function to find the sum of largest divisors of numbers in range 1 to N not divisible by prime number P ; Total sum upto N ; If no multiple of P exist up to N ; If only P itself is in the range from 1 to N ; Sum of those that are divisible by P ; Recursively function call to find the sum untill N / P ; Driver Code ; Given N and P ; Function Call
",1
991,"declare integer func ( integer N, integer P)  sumUptoN assign to ( N * ( N + 1 ) / 2 )
create integer sumOfMultiplesOfP
if N is less than P, return sumUptoN
else if N / P is 1 return sumUptoN - P + 1
set sumOfMultiplesOfP to ( ( N / P) * ( 2 * P + ( N / P - 1 ) * P ) / 2
return sumUptoN + func ( N / P, P ) - sumOfMultiplesOfP )
declare integer main ( ), integers N assign to 10 and P assign to 5
print func ( N, P ) and "" STRNEWLINE ""
return 0
","Count of unordered pairs ( x , y ) of Array which satisfy given equation 
 C ++ Program to find the number of unordered pairs ( x , y ) which satisfy the given equation untill the array ; Return the number of unordered pairs satisfying the conditions ; ans stores the number of unordered pairs ; Making each value of array to positive ; Sort the array ; For each index calculating the right boundary untill the unordered pairs ; Return the final result ; Driver code
",0
992,"declare findShifts with integers A array of  , N, shift array of N   as arguments, returning void
untill i assign to 0 to N exclusive, change array of i   assign to 0
else shift array of i   assign to ( A array of i   - 1 - i + N ) % N
untill i assign to 0 to N exclusive, print shift array of i  print "" ""
declare integer main ( ), integer arr array of   assign to  1, 4, 3, 2, 5  ;
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
call findShifts ( arr, N )
return 0
","Count of right shifts untill each array element to be in its sorted position 
 C ++ Program to implement the approach ; Function to find the right shifts required untill each element to reach its sorted array position in A array of   ; Stores required number of shifts untill each element ; If the element is at sorted position ; Otherwise ; Calculate right shift ; Print the respective shifts ; Driver Code
",1
993,"declare findShifts with integers A array of  , N, shift array of N   as arguments, returning void
untill i assign to 0 to N exclusive, change array of i   assign to 0
else shift array of i   assign to ( A array of i   - 1 - i + N ) % N
untill i assign to 0 to N exclusive, print shift array of i  print "" ""
declare integer main ( ), integer arr array of   assign to  1, 4, 3, 2, 5  ;
create integer N with N assign to sizeof ( arr ) / sizeof ( arr array of 0   )
call findShifts ( arr, N )
return 0
","Counts paths from a point to reach Origin 
 C ++ program to count total number of paths from a point to origin ; Recursive function to count number of paths ; If we reach bottom or top left , we are have only one way to reach ( 0 , 0 ) ; Else count sum of both ways ; Driver Code
",0
994,"declare constructmatrix with integer N as argument, change boolean check to true
untill i assign to 0 to N exclusive, print 1 and "" ""
else if check is true, print 2 and "" ""
set check to false
else print -2 print "" ""
set check to true
print newline
declare integer main ( ) and integer N assign to 5
create constructmatrix ( 5 )
return 0
","Construct a matrix with sum equal to the sum of diagonal elements 
 C ++ program to implement the above approach ; Function to construct matrix with diagonal sum equal to matrix sum ; If diagonal position ; Positive element ; Negative element ; Driver Code
",1
995,"declare constructmatrix with integer N as argument, change boolean check to true
untill i assign to 0 to N exclusive, print 1 and "" ""
else if check is true, print 2 and "" ""
set check to false
else print -2 print "" ""
set check to true
print newline
declare integer main ( ) and integer N assign to 5
create constructmatrix ( 5 )
return 0
","Generate all numbers up to N in Lexicographical Order 
 C ++ program untill the above approach ; Driver code
",0
996," int check ( int unit_digit , int X ) { int times , digit ;
 untill ( int times assign to 1 ; times <assign to 10 ; times ++ ) { digit assign to ( X * times ) % 10 ;
 if ( digit equal to unit_digit ) return times ;
 } return -1 ;
 } int getNum ( int N , int X ) { int unit_digit ;
 unit_digit assign to N % 10 ;
 int times assign to check ( unit_digit , X ) ;
 if ( times equal to -1 ) return times ;
 else { if ( N >assign to ( times * X ) ) return times ;
 else return -1 ;
 } } int main ( ) { int N assign to 58 , X assign to 7 ;
 cout << getNum ( N , X ) << endl ;
 return 0 ;
 }
","Minimum count of numbers required with unit digit X that sums up to N 
 C ++ Program to implement the above approach ; Function to calculate and return the minimum number of times a number with unit digit X needs to be added to get a sum N ; Calculate the number of additions required to get unit digit of N ; If unit digit of N cannot be obtained ; Function to return the minimum number required to represent N ; Stores unit digit of N ; Stores minimum addition of X required to obtain unit digit of N ; If unit digit of N cannot be obtained ; Otherwise ; If N is greater than or equal to ( X * times ) ; Minimum count of numbers that needed to represent N ; Representation not possible ; Driver Code
",1
997," int check ( int unit_digit , int X ) { int times , digit ;
 untill ( int times assign to 1 ; times <assign to 10 ; times ++ ) { digit assign to ( X * times ) % 10 ;
 if ( digit equal to unit_digit ) return times ;
 } return -1 ;
 } int getNum ( int N , int X ) { int unit_digit ;
 unit_digit assign to N % 10 ;
 int times assign to check ( unit_digit , X ) ;
 if ( times equal to -1 ) return times ;
 else { if ( N >assign to ( times * X ) ) return times ;
 else return -1 ;
 } } int main ( ) { int N assign to 58 , X assign to 7 ;
 cout << getNum ( N , X ) << endl ;
 return 0 ;
 }
","Rearrange array such that sum of same indexed elements is atmost K 
 C ++ program untill the above approach ; Function to rearrange array such that sum of similar indexed elements does not exceed K ; Sort the array B array of   in descending order ; If condition fails ; Print the array ; Driver Code ; Given arrays
",0
998," int minPoints ( int n , int m ) { int ans assign to 0 ;
 if ( ( n % 2 not equal to 0 ) && ( m % 2 not equal to 0 ) ) { ans assign to ( ( n * m ) / 2 ) + 1 ;
 } else { ans assign to ( n * m ) / 2 ;
 } return ans ;
 } int main ( ) { int N assign to 5 , M assign to 7 ;
 cout << minPoints ( N , M ) ;
 return 0 ;
 }","Minimum number of points required to cover all blocks of a 2 
 C ++ program untill the above approach ; Function to find the minimum number of Points required to cover a grid ; If number of block is even ; Return the minimum points ; Driver Code ; Given size of grid ; Function Call
",1
999," int minPoints ( int n , int m ) { int ans assign to 0 ;
 if ( ( n % 2 not equal to 0 ) && ( m % 2 not equal to 0 ) ) { ans assign to ( ( n * m ) / 2 ) + 1 ;
 } else { ans assign to ( n * m ) / 2 ;
 } return ans ;
 } int main ( ) { int N assign to 5 , M assign to 7 ;
 cout << minPoints ( N , M ) ;
 return 0 ;
 }","Sort the matrix row 
 C ++ implementation to sort the matrix row - wise and column - wise ; function to sort each row of the matrix ; sorting row number ' i ' ; function to find transpose of the matrix ; swapping element at index ( i , j ) by element at index ( j , i ) ; function to sort the matrix row - wise and column - wise ; sort rows of mat array of   array of   ; get transpose of mat array of   array of   ; again sort rows of mat array of   array of   ; again get transpose of mat array of   array of   ; function to print the matrix ; Driver program to test above
",0